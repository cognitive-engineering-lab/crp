# Concepts, interfaces, and static dispatch

In C++ static dispatch over an interface is achieved by implementing a template
function or template method that interacts with the type using some expected
interface.

The template function `twiceArea` in the example below makes use of an `area()`
method on the template type parameter.

To achieve the same goal in Rust involves defining a trait (`Shape`) with the
desired method (`twice_area`) and using the trait as a bound on the type
parameter for the generic function.

<div class="comparison">

```cpp
#include <iostream>

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() {
    return 0.5 * base * height;
  }
};

// Generic function using interface
template <class T>
double twiceArea(T &shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout << twiceArea(triangle) << std::endl;
  return 0;
}
```

```rust
// Interface that generic function will use
trait Shape {
    fn area(&self) -> f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implementation of interface for type
impl Shape for Triangle {
    fn area(&self) -> f64 {
        0.5 * self.base * self.height
    }
}

// Generic function using interface
fn twice_area<T: Shape>(shape: &T) -> f64 {
    2.0 * shape.area()
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    println!("{}", twice_area(&triangle));
}
```

</div>

Note that in the Rust example, the definition of the trait and the struct have
not changed from the example in the chapter on [virtual methods and dynamic
dispatch](/idioms/data_modeling/pure_virtual_classes.md). Even so, this example
does use static dispatch.

The difference between Rust and C++ in the above examples arises from Rust being
nominally typed (types must opt in to supporting a specific interface, merely
having the right methods isn't enough) and C++'s template meta-programming
enabling a kind of structural or duck typing (types only need to have the
methods actually used, and there is no need to explicitly opt in to supporting
an interface).

## Templates vs generic functions

The reason why Rust is nominally typed instead of structurally typed has to do
with the difference between C++ templates and Rust generic functions. In
particular, C++ templates are only type checked after all of the template
arguments are provided and they are fully expanded, while Rust generic functions
are type checked independently of the type arguments.

Since the functions are checked before the type arguments are known, the methods
and functions that can be applied to values of those types also need to be known
before the type arguments are known.

This point in the programming language design space favors simplicity of
reasoning about these functions over the flexibility that comes from the
template programming approach. This becomes especially valuable when writing
libraries that both provide generic functions and that use generic functions,
for which a C++ compiler can give many fewer static guarantees, since it would
not be possible to test all possible instantiations.

In both C++ and Rust, however, multiple implementations are generated by the
compiler in order to achieve static dispatch.

## C++ concepts

Rust's approach to static dispatch over an interface can be partially (but only
partially) modeled with a strict application of C++ concepts.

The usual way to apply concepts is still structural and does not model Rust's
approach: it only requires that a method with specific properties be present on
the type.

```cpp
#include <concepts>

template <typename T>
concept shape = requires(T t) {
  { t.area() } -> std::same_as<double>;
};

template <shape T>
double twiceArea(T shape) {
  return shape.area() * 2;
}
```

A closer equivalent to the above Rust program in C++ is to use a combination of
pure virtual classes and concepts.

```cpp
#include <concepts>

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template <typename T>
concept shape = std::derived_from<T, Shape>;

struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() override {
    return 0.5 * base * height;
  }
};

template <shape T>
double twiceArea(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout << twiceArea(triangle) << std::endl;
  return 0;
}
```

This is still not the same, however, because the concept only creates a
requirement on the use of the template, not on the use of values of type `T`
within the template. In Rust, the trait bound constrains both. So the following
still compiles in C++.

```cpp
#include <concepts>

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template <typename T>
concept shape = std::derived_from<T, Shape>;

template <shape T>
double twiceArea(T shape) {
  // note the call to a method not defined in Shape
  return shape.volume() * 2;
}
```

However, the equivalent does not compile in Rust and instead produces an error.

```rust,ignore
trait Shape {
    fn area(&self) -> f64;
}

fn twice_area<T: Shape>(shape: &T) -> f64 {
    // note the call to a method not defined in Shape
    2.0 * shape.volume()
}
```

```text
error[E0599]: no method named `volume` found for reference `&T` in the current scope
 --> example.rs:7:17
  |
7 |     2.0 * shape.volume()
  |                 ^^^^^^ method not found in `&T`
```

These additional static checks mean that in many situations where C++ templates
would be useful but hard to implement correctly, Rust generics are freely used.

## Required traits and ergonomics

In the above examples, the function requiring a trait was defined like the following.

```rust,ignore
fn twice_area<T: Shape>(shape: &T) -> f64 {
    2.0 * shape.area()
}
```

This is a commonly used shorthand for the following:

```rust,ignore
fn twice_area<T>(shape: &T) -> f64
where
    T: Shape,
{
    2.0 * shape.area()
}
```

The more verbose form is preferred used when there are many type parameters or
those type parameters must implement many traits.
