# RTTI and `dynamic_cast`

Rust does not built-in support for general RTTI or have a direct analog to
`dynamic_cast`.

The Rust standard library does provide an [`Any`
trait](https://doc.rust-lang.org/std/any/trait.Any.html) that supports similar
uses to `std::any` in C++. However, `Any` does not enable testing for
implementation of or converting to another trait, it only enables testing for
and converting to a concrete type.

Every type with a `'static` lifetime bound (i.e., that does not contain
non-static lifetime references) implements `Any` via a blanket implementation in
the standard library.

<div class="comparison">

```cpp
#include <any>
#include <iostream>
#include <string>

void print_if_string(const std::any &x) {
  try {
    const std::string &s =
        any_cast<std::string const &>(x);
    std::cout << s << std::endl;
  } catch (std::bad_any_cast &e) {
    std::cout << "Not a string!" << std::endl;
  }
}

int main() {
  print_if_string(std::string("hello world"));

  print_if_string(5);
}
```

```rust
use std::any::Any;

fn print_if_string(x: &dyn Any) {
    if let Some(s) = x.downcast_ref::<String>() {
        println!("{}", s);
    } else {
        println!("Not a string!");
    }
}

fn main() {
    print_if_string(&"hello world".to_string());
    print_if_string(&5);
}
```

</div>

## Event handling

One practical use of RTTI and `dynamic_cast` in C++ is for event handling in
situations where both the subsystem generating events and the events themselves
need to be decoupled from the handling logic. This is usually because the events
are generated by a framework, such as a GUI or game framework, while the
response to the events is application-specific.

<div class="comparison">

```cpp
struct Event {
  virtual ~Event() = default;
};

struct ClickEvent : public Event {
  int x;
  int y;
};

struct ResizeEvent : public Event {
  int old_height;
  int old_width;
  int new_height;
  int new_width;
};

void handle_event(Event *e) {
  if (auto click_event =
          dynamic_cast<ClickEvent *>(e)) {
    // ...
  } else if (auto resize_event =
                 dynamic_cast<ResizeEvent *>(e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}

// register event handler in main
```

```rust
enum Event {
    ClickEvent {
        x: i32,
        y: i32,
    },
    ResizeEvent {
        old_height: i32,
        old_width: i32,
        new_height: i32,
        new_width: i32,
    },
}

fn handle_event(e: Event) {
    match e {
        Event::ClickEvent { x, y } => {
            // ...
        }
        Event::ResizeEvent {
            old_height,
            old_width,
            new_height,
            new_width,
        } => {
            // ...
        }
    }
}
```

</div>

Even when the a client of the library is needs to be able to define custom
events, it is usually possible to make use of an event enum. This is the
approach taken by the [winit
crate](https://docs.rs/winit/latest/winit/event/enum.Event.html), which does
cross-platform window and event loop management.

<div class="comparison">

```cpp
$struct Event {
$  virtual ~Event() = default;
$};
$
$struct ClickEvent : public Event {
$  int x;
$  int y;
$};
$
$struct ResizeEvent : public Event {
$  int old_height;
$  int old_width;
$  int new_height;
$  int new_width;
$};
$
struct DoSomething : public Event {
  double how_much;
}

struct DoSomethingElse : public Event {
  double how_many;
}

void handle_event(Event *e) {
$  if (auto click_event =
$          dynamic_cast<ClickEvent *>(e)) {
$    // ...
$  } else if (auto resize_event =
$                 dynamic_cast<ResizeEvent *>(e)) {
$    // ...
  // ...
  } else if (auto user_event =
                 dynamic_cast<DoSomething *>(e)) {
    // ...
  } else if (auto user_event =
                 dynamic_cast<DoSomethingElse *>(
                     e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}
```

```rust
enum Event<T> {
#     ClickEvent {
#         x: i32,
#         y: i32,
#     },
#     ResizeEvent {
#         old_height: i32,
#         old_width: i32,
#         new_height: i32,
#         new_width: i32,
#     },
    // ...
    UserEvent(T),
}

enum UserEvent {
    DoSomething { how_much: f64 },
    DoSomethingElse { how_many: i32 },
}

fn handle_event(e: Event<UserEvent>) {
    match e {
#         Event::ClickEvent { x, y } => {
#             // ...
#         }
#         Event::ResizeEvent {
#             old_height,
#             old_width,
#             new_height,
#             new_width,
#         } => {
#             // ...
#         }
        // ...
        Event::UserEvent(
            UserEvent::DoSomething { how_much },
        ) => {
            // ...
        }
        Event::UserEvent(
            UserEvent::DoSomethingElse {
                how_many,
            },
        ) => {
            // ...
        }
    }
}
```

</div>

When representing events as an enum truly isn't feasible, sometimes [double
dispatch](/patterns/visitor.md) can be used instead. Otherwise it may be
necessary to use the `Any` trait or to define an `Event` trait that exposes a
type identifier that an be used for safe downcasting (via `Any`) or unsafe
downcasting behind a safe interface.[^safe-event-handler]

[^safe-event-handler]: Such an interface usually involves providing individual
    event handling functions for specific types, rather than a single large
    event handling function, so that the underlying implementation can managing
    the enforcement of the invariants required to make the casting safe.

## Library support for reflection via macros

Some of the use cases of RTTI can be achieved by using one of the third-party
reflection libraries. These libraries implement reflection by providing macros
for deriving traits to support common reflection operations.

One commonly used [library](../etc/libraries.md) for reflection at the time of
writing is [bevy\_reflect](https://docs.rs/bevy_reflect/latest/bevy_reflect/).
The crate has extensive documentation, including examples of usage.

This approach to reflection essentially makes it opt-in, so that software that
does not use reflection does not have to pay the performance price for it. The
cost of the opt-in approach is ease of use.
