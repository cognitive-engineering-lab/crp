<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Phrasebook for C++ Programmers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Phrasebook for C++ Programmers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h1>
<blockquote>
<ol start="10">
<li>Get into a rut early: Do the same process the same way. Accumulate idioms.
Standardize. The only difference(!) between Shakespeare and you was the
size of his idiom list - not the size of his vocabulary.</li>
</ol>
</blockquote>
<p>—Alan Perlis, Epigrams on Programming</p>
<p>The goal of this book is to make programming in Rust less frustrating for C++
programmers by providing translations of common C++ idioms and patterns into
idiomatic Rust, along with explanations of the reasons for and engineering
trade-offs with the differences.</p>
<p>The translations are often not straightforward transliterations, but rather are
more comprehensive changes of to how to approach, using stable Rust, the kinds
of problems that the C++ idioms and patterns are intended to address.</p>
<p>The book is structured to make it possible to read it front-to-back. Ideally,
after reading this book, one's "idiom list" for Rust should be significantly
more fleshed out, leading to a more enjoyable and productive experience
programming in Rust.</p>
<p>The chapters are also organized around C++ concepts instead of Rust concepts, to
aid C++ programmers in finding a specific solution to a problem in terms that
will be natural to them while they are learning Rust.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>If you are not primarily a C or C++ programmer, <a href="https://rust-book.cs.brown.edu/">The Rust Programming
Language</a> may be a better starting point.</p>
<p>If you are primarily an embedded systems programmer using C or C++, this book is
a complement to <a href="https://docs.rust-embedded.org/book/">The Embedded Rust Book</a>.</p>
<h2 id="feedback-on-this-book"><a class="header" href="#feedback-on-this-book">Feedback on this book</a></h2>
<p>TODO: add ask for feedback on missing content</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-modeling"><a class="header" href="#data-modeling">Data modeling</a></h1>
<p>In C++ the mechanisms available for data modeling are classes, enums, and
unions.</p>
<p>Rust, on the other hand, uses records
(<a href="https://doc.rust-lang.org/book/ch05-00-structs.html">structs</a>) and algebraic
data types (<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">enums</a>).</p>
<p>One major difference between C++ and Rust that arises from this is that C++
types are open (i.e., you can define a new variant of a type by defining a
subclass), while Rust types are closed (that the set of variants for a Rust type
are fixed at the time of definition). The other side of this trade-off is that
in C++ the set of interfaces that are supported by a type is closed, while in
Rust the set of interfaces is open. In both languages, there are ways to work
around the restrictions of the other (e.g., the adapter pattern in C++).</p>
<p>This section gives examples of common constructions used when programming in C++
data and how to achieve the same effects using Rust's features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>In C++, enums are often used to model fixed set alternatives, especially when
each of those enumerators maps to a specific integer value, such as is needed
when working with hardware, system calls, or protocol implementations.</p>
<p>For example, the various modes for a GPIO pin could be modeled as an enum, which
would restrict methods using the mode to valid values.</p>
<pre><code class="language-c++">#include &lt;cstdint&gt;

enum Pin : uint8_t {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04
};

enum PinMode : uint8_t {
    Output            = 0x03,
    Pullup            = 0x04,
    Analog            = 0x27
    // ...
};

void lowLevelSetPin(uint8_t pin, uint8_t mode);

void setPinMode(Pin pin, PinMode mode) {
    lowLevelSetPin(pin, mode);
}
</code></pre>
<p>While Rust enums are more general (which will be show in later chapters), they
also can be used for this sort of modeling.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

#[repr(u8)]
#[derive(Clone, Copy)]
enum Mode {
    Output = 0x03,
    Pullup = 0x04,
    Analog = 0x27,
    // ...
}

extern "C" {
    fn low_level_set_pin(pin: u8, mode: u8);
}

fn set_pin_mode(pin: Pin, mode: Mode) {
    unsafe { low_level_set_pin(pin as u8, mode as u8) };
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[repr(u8)]</code> attribute ensure that the representation of the enum is the
same as a byte (like declaring the underlying type of an enum in C++). The enum
values can then be freely converted to the underlying type with the <code>as</code>.</p>
<p>In C++ the standard way to convert from an integer to an enum is a static cast.
However, this <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1766">requires that the user check the validity of the cast
themselves</a>.
Often the conversion is done by a function that checks that the value to convert
is a valid enum value.</p>
<pre><code class="language-c++">Pin cast_to_pin(uint8_t pin) {
    return static_cast&lt;Pin&gt;(pin);
}

struct InvalidPin {
    uint8_t pin;
};

Pin to_pin(uint8_t pin) {
    switch (pin) {
	case 0x1: { return Pin1; }
	case 0x2: { return Pin2; }
    case 0x4: { return Pin3; }
	default: { throw InvalidPin{pin}; }
    }
}
</code></pre>
<p>In Rust the standard way to perform the conversion is to implement the <code>TryFrom</code>
trait for the type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Pin {
</span><span class="boring">    Pin1 = 0x01,
</span><span class="boring">    Pin2 = 0x02,
</span><span class="boring">    Pin3 = 0x04,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Mode {
</span><span class="boring">    Output = 0x03,
</span><span class="boring">    Pullup = 0x04,
</span><span class="boring">    Analog = 0x27,
</span><span class="boring">    // ...
</span><span class="boring">}
</span>
use std::convert::TryFrom;

struct InvalidPin(u8);

impl TryFrom&lt;u8&gt; for Pin {
    type Error = InvalidPin;

    fn try_from(value: u8) -&gt; Result&lt;Self, Self::Error&gt; {
       match value {
           0x01 =&gt; Ok(Pin::Pin1),
           0x02 =&gt; Ok(Pin::Pin2),
           0x04 =&gt; Ok(Pin::Pin3),
           pin =&gt; Err(InvalidPin(pin)),
       }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="idioms/data_modeling//idioms/exceptions.html">Exceptions and error handling</a> for examples of how
to ergonomically handle the result of <code>try_from</code>.</p>
<p>If low level performance more of a concern than memory safety,
<code>std::mem::transmute</code> is analogous to a C++ reinterpret cast, but requires
unsafe Rust because its use can result in undefined behavior. Uses of
<code>std::mem::transmute</code> for this purpose should not be hidden behind an interface
that can be called from safe Rust unless the interface can actually guarantee
that the call will never happen with an invalid value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-unions-and-stdvariant"><a class="header" href="#tagged-unions-and-stdvariant">Tagged unions and <code>std::variant</code></a></h1>
<h2 id="c-style-tagged-unions"><a class="header" href="#c-style-tagged-unions">C-style tagged unions</a></h2>
<p>Because unions cannot be used for type punning in C++, when they are used it is
usually with a tag to discriminate between which variant of the union is active.</p>
<pre><code class="language-c++">enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union Value {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  } value;

  double area() {
    switch (this-&gt;tag) {
    case Rectangle: {
      return this-&gt;value.rectangle.width * this-&gt;value.rectangle.height;
    }
    case Triangle: {
      return 0.5 * this-&gt;value.triangle.base * this-&gt;value.triangle.height;
    }
    }
  }
};
</code></pre>
<p>Rust's equivalent to union types are always tagged. They are a generalization of
Rust enums, where additional data may be associated with the enum variants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Triangle { base, height } =&gt; 0.5 * base * height,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-the-value-without-checking-the-discriminant"><a class="header" href="#accessing-the-value-without-checking-the-discriminant">Accessing the value without checking the discriminant</a></h2>
<p>Unlike with C-style unions, Rust always requires matching on the discriminant
before accessing the values. If the variant is already known, e.g., due to an
earlier check, then the code can usually be refactored to encode the knowledge
in the type so that the second check (and corresponding error handling) can be
omitted.</p>
<p>A C++ program like the following requires more restructuring of the types to
achieve the same goal in Rust.</p>
<pre><code class="language-c++">#include &lt;ranges&gt;
#include &lt;vector&gt;

std::vector&lt;Shape&gt; get_shapes() {
  return std::vector&lt;Shape&gt;{
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},
  };
}

std::vector&lt;Shape&gt; get_shapes();

int main() {
  std::vector&lt;Shape&gt; shapes = get_shapes();

  auto is_triangle = [](Shape shape) { return shape.tag == Triangle; };

  // Create an iterator that only sees the triangles. (std::views::filter is
  // from C++20, but the same effect can be acheived with a custom iterator.)
  auto triangles = shapes | std::views::filter(is_triangle);

  double total_base = 0.0;
  for (auto &amp;triangle : triangles) {
    // Skip checking the tag because we know we have only triangles.
    total_base += triangle.value.triangle.base;
  }

  return 0;
}
</code></pre>
<p>The corresponding Rust program requires defining separate types for each variant
of the <code>Shape</code> enum so that the fact that all of the value are of a given type
can be expressed in the type system by having an array of <code>Triangle</code> instead of
an array of <code>Shape</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle { width: f64, height: f64 }
struct  Triangle { base: f64, height: f64 }

enum Shape {
    Rectangle(Rectangle),
    Triangle(Triangle),
}


fn get_shapes() -&gt; Vec&lt;Shape&gt; {
    vec![
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Rectangle(Rectangle {
            width: 1.0,
            height: 1.0,
        }),
    ]
}

fn main() {
    let shapes = get_shapes();

    // Create an iterator that only sees the triangles.
    let triangles = shapes
        .iter()
        // Keep only the triangles
        .filter_map(|shape| match shape {
            Shape::Triangle(t) =&gt; Some(t),
            _ =&gt; None,
        });

    let mut total_base = 0.0;
    for triangle in triangles {
        total_base += triangle.base;
    }
}</code></pre></pre>
<p>This kind of use is common enough that the variants are often designed to have
their own types from the start.</p>
<h2 id="stdvariant-since-c17"><a class="header" href="#stdvariant-since-c17"><code>std::variant</code> (since C++17)</a></h2>
<p>In more modern C++, <code>std::variant</code> is more similar in usage to Rust.</p>
<pre><code class="language-c++">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        } else if constexpr (std::is_same_v&lt;T, Triangle&gt;) {
          return 0.5 * arg.base * arg.height;
        }
      },
      shape);
}
</code></pre>
<p>Because Rust doesn't depend on templates for this language feature, error
messages when a variant is missed or when a new variant is added are easier to
read, which removes one of the barriers to using tagged unions more frequently.
Compare the errors in C++ (using gcc) and Rust when the <code>Triangle</code> case is
omitted.</p>
<pre><code class="language-c++">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        }
      },
      shape);
}
</code></pre>
<pre><code class="language-text">$ g++ -o example example.cc
example.cc: In instantiation of ‘area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt; [with auto:27 = const Triangle&amp;]’:
/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from ‘constexpr _Res std::__invoke_impl(__invoke_other, _Fn&amp;&amp;, _Args&amp;&amp; ...) [with _Res = double; _Fn = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}]’
   61 |     { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from ‘constexpr typename std::__invoke_result&lt;_Functor, _ArgTypes&gt;::type std::__invoke(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}; typename __invoke_result&lt;_Functor, _ArgTypes&gt;::type = double]’
   96 |       return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   97 |                                         std::forward&lt;_Args&gt;(__args)...);
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1060:24:   required from ‘static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl&lt;std::__detail::__variant::_Multi_array&lt;_Result_type (*)(_Visitor, _Variants ...)&gt;, std::integer_sequence&lt;long unsigned int, __indices ...&gt; &gt;::__visit_invoke(_Visitor&amp;&amp;, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;&amp;&amp;; _Variants = {const std::variant&lt;Rectangle, Triangle&gt;&amp;}; long unsigned int ...__indices = {1}]’
 1060 |           return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),
      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1061 |               __element_by_index_or_cookie&lt;__indices&gt;(
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1062 |                 std::forward&lt;_Variants&gt;(__vars))...);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1820:5:   required from ‘constexpr decltype(auto) std::__do_visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Result_type = __detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}]’
 1820 |                   _GLIBCXX_VISIT_CASE(1)
      |                   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1882:34:   required from ‘constexpr std::__detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; std::visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}; __detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; = double]’
 1882 |             return std::__do_visit&lt;_Tag&gt;(
      |                    ~~~~~~~~~~~~~~~~~~~~~^
 1883 |               std::forward&lt;_Visitor&gt;(__visitor),
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1884 |               static_cast&lt;_Vp&gt;(__variants)...);
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
example.cc:17:20:   required from here
   17 |   return std::visit(
      |          ~~~~~~~~~~^
   18 |       [](auto &amp;&amp;arg) -&gt; double {
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 |         using T = std::decay_t&lt;decltype(arg)&gt;;
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 |         if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 |           return arg.width * arg.height;
      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   22 |         }
      |         ~
   23 |       },
      |       ~~
   24 |       shape);
      |       ~~~~~~
example.cc:23:7: error: no return statement in ‘constexpr’ function returning non-void
   23 |       },
      |       ^
example.cc: In lambda function:
example.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<pre><code class="language-rust ignore">enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
        }
    }
}</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `&amp;Shape::Triangle { .. }` not covered
 --&gt; example.rs:8:15
  |
8 |         match self {
  |               ^^^^ pattern `&amp;Shape::Triangle { .. }` not covered
  |
note: `Shape` defined here
 --&gt; example.rs:1:6
  |
1 | enum Shape {
  |      ^^^^^
2 |     Rectangle { width: f64, height: f64 },
3 |     Triangle { base: f64, height: f64 },
  |     -------- not covered
  = note: the matched value is of type `&amp;Shape`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
9 ~             Shape::Rectangle { width, height } =&gt; width * height,
10~             &amp;Shape::Triangle { .. } =&gt; todo!(),
  |

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0004`.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pure-virtual-classes-interfaces-and-dynamic-dispatch"><a class="header" href="#pure-virtual-classes-interfaces-and-dynamic-dispatch">Pure virtual classes, interfaces, and dynamic dispatch</a></h1>
<p>Pure virtual classes are used to model interfaces when objects meeting the
interface will be used with dynamic dispatch to resolve the invoked method.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Shape {
  Shape() {};
  virtual ~Shape() {};
  virtual double area() = 0;
};

struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() override { return 0.5 * base * height; }
};

struct Rectangle : Shape {
  double width;
  double height;

  Rectangle(double width, double height) : width(width), height(height) {}

  double area() override { return width * height; }
};

int main() {
  Shape &amp;&amp;triangle = Triangle{1.0, 1.0};
  std::unique_ptr&lt;Shape&gt; rectangle = std::make_unique&lt;Rectangle&gt;(1.0, 1.0);

  std::cout &lt;&lt; triangle.area() &lt;&lt; std::endl;
  std::cout &lt;&lt; rectangle-&gt;area() &lt;&lt; std::endl;
}
</code></pre>
<p>In Rust the interface is given by a trait, which is then implemented for the
types that support that trait. Programs can then be written over trait objects
that use that trait as their base type.</p>
<p>Similarly to how in C++ programs use of an object via a pure virtual superclass
interface requires accessing that object via a pointer, in Rust the same kind of
indirection is required. In the example below, one trait object is a reference
(with type <code>&amp;dyn Shape</code>) and the other is a heap-allocated owned value (with
type <code>Box&lt;dyn Shape&gt;</code>). These correspond to the reference and <code>std::unique_ptr</code>
used in the above C++ example.</p>
<pre><pre class="playground"><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }
}

fn main() {
    let triangle: &amp;dyn Shape = &amp;Triangle {
        base: 1.0,
        height: 1.0,
    };
    let rectangle: Box&lt;dyn Shape&gt; = Box::new(Rectangle {
        width: 1.0,
        height: 1.0,
    });

    println!("{}", triangle.area());
    println!("{}", rectangle.area());
}</code></pre></pre>
<p>Not all traits can be used as the base trait for trait objects. The most
commonly encountered restriction is that traits that require knowledge of the
object's size via a <code>Sized</code> supertrait are not <code>dyn</code> compatible. There are
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">additional
restrictions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-interfaces-and-static-dispatch"><a class="header" href="#concepts-interfaces-and-static-dispatch">Concepts, interfaces, and static dispatch</a></h1>
<p>When static dispatch over an interface is desired in C++, there are three
approaches that can be used, two of which are purely structural (i.e., they rely
only on the type having a matching method defined) and one of which is nominal.</p>
<p>The first is to define a template function that uses an <code>area()</code> method and rely
on it failing when it is used with a type that does not have that method. This
is significantly less restrictive than the other two C++ approaches, because it
does not require that <code>area()</code> return a <code>double</code>, only that it return a value
that can be promoted to a double.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() { return 0.5 * base * height; }
};

template &lt;class T&gt;
double twice_area(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twice_area(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>The second C++ approach uses a concept to restrict the return type, but
otherwise is the same as the first.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

template &lt;typename T&gt;
concept shape = requires(T t) {
  { t.area() } -&gt; std::same_as&lt;double&gt;;
};

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() { return 0.5 * base * height; }
};

template &lt;shape T&gt;
double twice_area(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twice_area(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>The closest equivalent to this in Rust is the following. Note that the
definition of the trait and the struct have not changed from the original
example using virtual methods and dynamic dispatch. Despite this, this example
does use static dispatch.</p>
<pre><pre class="playground"><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

fn twice_area&lt;T: Shape&gt;(shape: T) -&gt; f64 {
    2.0 * shape.area()
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    println!("{}", twice_area(triangle));
}</code></pre></pre>
<p>This is not quite the same as the above C++ programs because Rust requires that
the <code>Triangle</code> type explicitly declare that it implements the <code>Shape</code> interface,
while in the above C++ program the type implements the concept simply by virtue
of having defined a compatible method.</p>
<p>A closer equivalent to the above Rust program in C++ would be the following,
which uses a combination of pure virtual classes and concepts to achieve both
static dispatch and nominal typing.</p>
<pre><code class="language-c++">#include &lt;concepts&gt;
#include &lt;iostream&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() override { return 0.5 * base * height; }
};

template &lt;shape T&gt;
double twice_area(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twice_area(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<h2 id="templates-vs-generic-functions"><a class="header" href="#templates-vs-generic-functions">Templates vs generic functions</a></h2>
<p>The reason why Rust is nominally typed instead of structurally typed has to do
with the difference between C++ templates and Rust generic functions. In
particular, C++ templates are only type checked after all of the template
arguments are provided and they are fully expanded, while Rust generic functions
are type checked independently of the type arguments.</p>
<p>Since the functions are checked before the type arguments are known, the methods
and functions that can be applied to values of those types also need to be known
before the type arguments are known.</p>
<p>This point in the programming language design space favors simplicity of
reasoning about these functions over the flexibility that comes from the
template programming approach. This becomes especially valuable when writing
libraries that both provide generic functions and that use generic functions,
for which a C++ compiler can give many fewer static guarantees, since it would
not be possible to test all possible instantiations.</p>
<p>In both C++ and Rust, however, multiple implementations are generated by the
compiler in order to achieve static dispatch.</p>
<h2 id="required-traits-and-ergonomics"><a class="header" href="#required-traits-and-ergonomics">Required traits and ergonomics</a></h2>
<p>In the above examples, the function requiring a trait was defined like the following.</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T: Shape&gt;(shape: T) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
<p>This is a commonly used shorthand for the following:</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T&gt;(shape: T) -&gt; f64
where
    T: Shape,
{
    2.0 * shape.area()
}</code></pre>
<p>The more verbose form is preferred used when there are many type parameters or
those type parameters must implement many traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance-and-implementation-reuse"><a class="header" href="#inheritance-and-implementation-reuse">Inheritance and implementation reuse</a></h1>
<p>Rust does not have inheritance and so the primary means of reuse of
implementations in Rust are composition, aggregation, and <a href="idioms/data_modeling/TODO">generics</a>.</p>
<p>However, Rust traits do have support for default methods which resemble one
simple case of using inheritance for reuse of implementations. For example, in
the following example two virtual methods are used to support a method whose
implementation is provided by the abstract class.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;

class Device {
public:
    virtual void powerOn() = 0;
    virtual void powerOff() = 0;

    virtual void resetDevice() {
        std::cout &lt;&lt; "Resetting device..." &lt;&lt; std::endl;
        powerOff();
        powerOn();
    }

    virtual ~Device() {}
};

class Printer : public Device {
    bool powered = false;
public:
    void powerOn() override {
        this.powered = true;
        std::cout &lt;&lt; "Printer is powered on." &lt;&lt; std::endl;
    }

    void powerOff() override {
        this.powered = false;
        std::cout &lt;&lt; "Printer is powered off." &lt;&lt; std::endl;
    }
};

int main() {
    Printer myPrinter;
    myPrinter.resetDevice();
    return 0;
}
</code></pre>
<p>In practice, the <code>resetDevice()</code> method in the <code>Device</code> class might be made
non-virtual in C++ if it is not expected that it will be overridden. In order to
make it align with the Rust example, we have made it virtual here, since the
vtable for <a href="idioms/data_modeling/./idioms/data_modeling/pure_virtual_classes.html">trait objects</a> in
Rust includes all methods defined by the trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Device {
    fn power_on(&amp;mut self);
    fn power_off(&amp;mut self);

    fn reset_device(&amp;mut self) {
        println!("Resetting device...");
        self.power_on();
        self.power_off();
    }
}

struct Printer {
    powered: bool,
}

impl Device for Printer {
    fn power_on(&amp;mut self) {
        self.powered = true;
        println!("Printer is powered on");
    }

    fn power_off(&amp;mut self) {
        self.powered = false;
        println!("Printer is powered off");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust traits are more differ from abstract classes in a few ways. For example,
Rust traits cannot define data members and cannot define private or protected
methods. This limits the use of traits to implement patterns such as the
<a href="idioms/data_modeling/TODO">template method pattern</a>.</p>
<p>Traits can, however, inherit from each other, including multiple inheritance. As
in modern C++, inheritance hierarchies in Rust tend to be shallow. In situations
with complex multiple inheritance, however, the diamond problem cannot arise in
Rust because traits cannot override other traits implementations. Therefore, all
paths to a common parent trait resolve to the same implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-classes-functions-and-methods"><a class="header" href="#template-classes-functions-and-methods">Template classes, functions, and methods</a></h1>
<p>The most common uses of templates in C++ are to define classes, methods, traits,
or functions that work for any type, or for any type that provides certain
methods. This use case is common in the STL for container classes (such as
<code>&lt;vector&gt;</code>) and for the algorithms library (<code>&lt;algorithm&gt;</code>).</p>
<p>The following example defines a template for a directed graph represented as an
adjacency list, where the graph is generic in the type of the labels on the
nodes. Though the example shows a template class, the same comparisons with Rust
apply to template methods and template functions.</p>
<pre><code class="language-c++">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
private:
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  std::vector&lt;Label&gt; nodeLabels;

public:
  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(label);
    return numNodes() - 1;
  }

  void addEdge(size_t from, size_t to) {
    if (from &gt;= numNodes() || to &gt;= numNodes()) {
      throw std::invalid_argument("Node index out of range");
    }
    adjacencies[from].push_back(to);
  }

  size_t numNodes() const { return adjacencies.size(); }
};
</code></pre>
<p>The same can be achieved in Rust using generic types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DirectedGraph&lt;Label&gt; {
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    node_labels: Vec&lt;Label&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }

    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
            Err("Node not in graph.")
        } else {
            self.adjacencies[from].push(to);
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this use case so far, there are few practical differences between using C++
template to define a class and using and Rust's generics to define a struct.
Whenever one would use a template that takes a <code>typename</code> or <code>class</code> parameter
in C++, one can instead take a type parameter in Rust.</p>
<h2 id="operations-on-the-parameterized-type"><a class="header" href="#operations-on-the-parameterized-type">Operations on the parameterized type</a></h2>
<p>The differences become more apparent when one attempts to perform operations on
the values. For example, adding a method to get the smallest node in the graph.</p>
<pre><code class="language-c++">#include &lt;optional&gt;
//...

template &lt;typename Label&gt;
class DirectedGraph {
  // ...

public:
  std::optional&lt;size_t&gt; smallestNode() {
    if (nodeLabels.empty()) {
      return std::nullopt;
    }
    Label &amp;least = nodeLabels[0];
    size_t index = 0;

    for (int i = 1; i &lt; nodeLabels.size(); i++) {
      if (least &gt; nodeLabels[i]) {
        least = nodeLabels[i];
        index = i;
      }
    }
    return std::optional(index);
  }
}
</code></pre>
<p>In Rust, the same method would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    // Matches the C++, but is not the idomatic implementation!
    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        if self.node_labels.is_empty() {
            None
        } else {
            let mut least = &amp;self.node_labels[0];
            let mut index = 0;
            for i in 1..self.node_labels.len() {
                if *least &gt; self.node_labels[i] {
                    least = &amp;self.node_labels[i];
                    index = i;
                }
            }
            Some(index)
        }
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The major difference between these implementations is that in the C++ version
<code>operator&gt;</code> is used on the values without knowing whether the operator is
defined for the type, while in the Rust version, there is a constraint requiring
that the <code>Label</code> type implement the <code>Ord</code> trait. (See the chapter on <a href="idioms/data_modeling/./idioms/data_modeling/concepts.html">concepts,
interfaces, and static dispatch</a> for more
details on Rust traits and how they relate to C++ concepts.)</p>
<p>Unlike C++ templates, generic definitions in Rust are type checked at the point
of definition rather than at the point of use. This means that for operations to
be used on values with the type of a type parameter the parameter has to be
constrained to types that implement some trait. As can be seen in the above
example, much like with C++ concepts, the constraint can be required for
individual methods rather than for the whole generic class.</p>
<p>Best practice in Rust to put the trait bounds on the specific things that
require the bounds, in order to make the overall use of the types more flexible.</p>
<p>Also, a more idiomatic implementation of <code>smallest_node</code> is</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
where
    Label: Ord,
{
    self.node_labels
        .iter()
        .enumerate()
        .map(|(i, l)| (l, i))
        .min()
        .map(|(_, i)| i)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="constexpr-template-parameters"><a class="header" href="#constexpr-template-parameters"><code>constexpr</code> template parameters</a></h2>
<p>Rust also supports the equivalent of constexpr template parameters. For example,
one can define a generic function that returns an array consecutive integers
starting from a specific value and whose size is determined at compile time.</p>
<pre><code class="language-c++">#include &lt;array&gt;

template &lt;constexpr N&gt;
std::array&lt;int, N&gt; makeSequentialArray(int start) {
    array&lt;int, N&gt; arr;
    for (size_t i = 0; i &lt; N; i++) {
        arr[i] = start + i;
    }
}
</code></pre>
<p>The corresponding idiomatic Rust function uses the helper <code>std::array::from_fn</code>
to construct the array. <code>from_fn</code> itself takes as type parameters the element
type and the constant. Those arguments are elided because Rust can infer them,
because both are part of the type of the produced array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_sequential_array&lt;const N: usize&gt;(start: i32) -&gt; [i32; N] {
    std::array::from_fn(|i| start + i as i32)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-self-type"><a class="header" href="#rusts-self-type">Rust's <code>Self</code> type</a></h2>
<p>Within a class definition, there is a <code>Self</code> type that is in scope. The <code>Self</code>
type is the type of the class being defined with all of the generic type
parameters filled in. It can be useful to refer to this type especially in cases
where there are many parameters that would otherwise have to be listed out.</p>
<p>The <code>Self</code> type can also be used when implementing generic traits to refer to
the concrete implementing type. Because Rust does not have inheritance between
concrete types and does not have method overriding, this is sufficient to avoid
the need to pass the implementing type as a type parameter.</p>
<p>TODO example</p>
<h2 id="a-note-on-type-checking-and-type-errors"><a class="header" href="#a-note-on-type-checking-and-type-errors">A note on type checking and type errors</a></h2>
<p>The checking of generic types at the point of definition rather than at the
point of template expansion impacts when errors are detected and how they are
reported. Some of this difference cannot be achieved by consistently using C++
concepts to declare the operations required.</p>
<p>For example, one might accidentally make the <code>nodeLabels</code> member a vector of
integers instead of a vector of the label parameter. If all of the test cases
for the graph used label types that were convertible to integers, the error
would not be detected.</p>
<p>A similar Rust program fails to compile, even without a function that
instantiates the generic structure with a concrete type.</p>
<h2 id="lifetimes-parameters"><a class="header" href="#lifetimes-parameters">Lifetimes parameters</a></h2>
<p>Rust's generics are also used for classes, methods, traits, and functions that
are generic in the lifetimes of the references they manipulate. Unlike other
type parameters, the using a function with different lifetimes does not cause
additional copies of the function to be generated in the compiled code, because
lifetimes do not impact the runtime representation.</p>
<p>TODO example with and without lifetime elision.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>TODO talk about lifetime bounds on type parameters.</p>
<p>TODO example of lifetime bounds on type parameters</p>
<p>The lifetime elision rules do not always follow the initial intuition one might
have. If a program produces surprising lifetime errors and elided lifetimes are
involved, it may be helpful to review the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision
rules</a>.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>One significant difference between C++ templates and Rust generics is that C++
templates are actually a more general purpose macro language, supporting things
like conditional compilation. Rust supports these use cases with its macro
system, which differs significantly from C++. The most common use of the macro
system, conditional compilation, is provided by <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">the <code>cfg</code> attribute and <code>cfg!</code>
macro</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-length-arrays"><a class="header" href="#zero-length-arrays">Zero-length arrays</a></h1>
<p>In C++ codebases that are written in a C style or that make use of C libraries,
null pointers may be used to represent empty arrays. This is because there is
little practical difference between an array of size zero and a null pointer.</p>
<pre><code class="language-c++">#include &lt;cstddef&gt;
#include &lt;cassert&gt;

int c_style_sum(std::size_t len, int arr[]) {
    int sum = 0;
    for (size_t i = 0; i &lt; len; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int sum = c_style_sum(0, nullptr);
    assert(sum == 0);
    return 0;
}
</code></pre>
<p>In Rust, arrays of arbitrary size are represented as
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html">slices</a>. These slices can
have zero length. Since <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Deref-for-Vec%3CT,+A%3E">Rust vectors are convertible to
slices</a>,
defining functions that work with slices enables them to be used with vectors as
well.</p>
<pre><pre class="playground"><code class="language-rust">fn sum_slice(arr: &amp;[i32]) -&gt; i32 {
    let mut sum = 0;
    for x in arr {
        sum += x;
    }
    sum
}

fn main() {
    let sum = sum_slice(&amp;[]);
    assert!(sum == 0);

    let sum2 = sum_slice(&amp;vec![]);
    assert!(sum2 == 0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moved-members"><a class="header" href="#moved-members">Moved members</a></h1>
<p>One common use of null pointers in modern C++ is as values for the members of
moved objects so that the destructor can still safely be called. E.g.,</p>
<pre><code class="language-c++ hidelines=#"><span class="boring"> #include &lt;cstdlib&gt;
</span><span class="boring"> #include &lt;cstring&gt;
</span><span class="boring">
</span>// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t*);
void copy_widget(widget_t* dst, widget_t* src);

// widget.cc
class Widget {
    widget_t* widget;
public:
<span class="boring">    Widget() : widget(alloc_widget()) {}
</span><span class="boring">
</span><span class="boring">    Widget(const Widget &amp;other) : widget(alloc_widget()) {
</span><span class="boring">        copy_widget(widget, other.widget);
</span><span class="boring">    }
</span><span class="boring">
</span>    Widget(Widget &amp;&amp;other) : widget(other.widget) {
        other.widget = nullptr;
    }

    ~Widget() {
        free_widget(widget);
    }
};
</code></pre>
<p>Rust's notion of moving objects does not involve leaving behind an object on
which a destructor will be called, and so this use of null does not have a
corresponding idiom. See the chapter on <a href="idioms/null//idioms/constructors/copy_and_move_constructors.html">copy and move
constructors</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-files"><a class="header" href="#header-files">Header files</a></h1>
<p>One use of header files in C++ is to expose declarations that are defined in one
translation units to other translation units without requiring the duplication
of the declarations in multiple files. By convention, declarations that are not
included in the header are considered to be private to the defining translation
unit (though, to enforce this convention other mechanisms, such as <a href="idioms/encapsulation//idioms/encapsulation/anonymous_namespaces.html">anonymous
namespaces</a>, are required).</p>
<pre><code class="language-c++">// person.h
class Person {
    std::string name;
public:
    Person(std::string name) : name(name) {}
    const std::string&amp; getName();
};

// person.cc
std::string&amp; Person::getName() {
    return this.name;
}

// client.cc
#include "person.h"

int go() {
    Person p("Alice");
    std::string&amp; name = p.getName();

    // ...

    return 0;
}
</code></pre>
<p>Rust does uses neither textually-included header files nor forward declarations.
Instead, Rust modules control visibility and linkage simultaneously and expose
public definitions for use by other modules. Using Rust modules, something like
the above definitions becomes</p>
<pre><code class="language-rust ignore">// person.rs
pub struct Person {
    name: String,
}

impl Person {
    pub fn new(name: String) -&gt; Person {
        Person { name }
    }

    pub fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

// client.rs
mod person;

use person::*;

fn go() {
    let p = Person::new("Alice");
    let name = p.name();

    //...
}</code></pre>
<p>In the <code>person.rs</code>, the <code>Person</code> type is public by the <code>name</code> field is not. This
prevents both direct construction of values of the type (similar to private
members preventing aggregate initialization) and field access (including
preventing pattern matching). The static method <code>new</code> and method <code>name</code> are
exposed to clients of the module by the <code>pub</code> visibility declarations.</p>
<p>In the <code>client</code> module, the <code>mod</code> declaration defines the content of <code>person.rs</code>
as a submodule named <code>person</code>. The <code>use</code> declaration brings the contents of the
<code>person</code> module into scope.</p>
<h2 id="the-essence-of-the-difference"><a class="header" href="#the-essence-of-the-difference">The essence of the difference</a></h2>
<p>A C++ program is a collection of translation units. Header files are required to
make the providing of forward declarations of definitions from other translation
units manageable.</p>
<p>A Rust program is a tree of modules. Definitions in one module may access items
from other modules based on visibility declarations given in the definitions of
the module themselves.</p>
<h2 id="submodules-and-additional-visibility-features"><a class="header" href="#submodules-and-additional-visibility-features">Submodules and additional visibility features</a></h2>
<p>Modules and visibility declarations are more powerful than shown in the above
example. More details on how to use modules, <code>pub</code>, and <code>use</code> to achieve
encapsulation goals are described in the chapter on <a href="idioms/encapsulation/./idioms/encapsulation/private_members.html">private members and
friends</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-namespaces-and-static"><a class="header" href="#anonymous-namespaces-and-static">Anonymous namespaces and <code>static</code></a></h1>
<p>Anonymous namespaces are used in C++ to prevent symbols defined in one
translation unit from colliding with those defined in another, which would
result in a linking error at best and possibly undefined behavior at runtime.</p>
<p>For example, without the use of anonymous namespaces, the following would result
in undefined behavior (and no linking error, due to the use of inline producing
weak symbols in the object files).</p>
<pre><code class="language-c++">/// a.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}

/// b.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}
</code></pre>
<p>C++ static declarations are also used to achieve the same goal by making it so that
a declaration has internal linkage (and so is not visible outside of the
translation unit).</p>
<p>Thus, the following Rust program achieves the same goal as the C++ program above
in terms of avoiding the collision of the two functions while making them
available for use within the defining files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.rs
<span class="boring">mod a {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span>
// b.rs
<span class="boring">mod b {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Rust avoids the linkage problem by controlling linkage and visibility
simultaneously, with declarations always also being definitions. Instead of
translation units, programs are structured in terms of
<a href="idioms/encapsulation//idioms/encapsulation/headers.html">modules</a>, which provide both namespaces and
visibility controls over definitions, enabling the Rust compiler to guarantee
that symbol collision issues cannot happen.</p>
<p>Additionally,</p>
<ol>
<li>Unlike C++ namespaces, Rust modules (which provide namespacing as well as
visibility controls) can only be defined once, and this is checked by the
compiler.</li>
<li>Each file <a href="https://doc.rust-lang.org/stable/book/ch07-05-separating-modules-into-different-files.html">defines a module which has to be explicitly included in the module
hierarchy</a>.</li>
<li>Modules from Rust crates (libraries) are always qualified with some root
module name, so they cannot conflict. If the would conflict, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">the root module
name must be replaced with some user-chosen
name</a>.</li>
</ol>
<h2 id="a-caveat-about-using-c-and-c-libraries"><a class="header" href="#a-caveat-about-using-c-and-c-libraries">A caveat about using C and C++ libraries</a></h2>
<p>When using libraries not managed by Rust, such as C or C++ static or dynamic
libraries or when producing Rust static or dynamic libraries to be used by C or
C++ programs, the usual problems can occur if there are symbol collisions in the
object files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>In C++, constructors initialize objects.</p>
<pre><code class="language-c++">class Person {
  int age;
public:
  Person(int a) : age(a) {}
};
</code></pre>
<p>At the point when a constructor is executed, storage for the object has been
allocated and the constructor is only performing initialization.</p>
<pre><code class="language-c++">class Person {
  int age;
  A* best_friend;
public:
  A(int a) : age(a), best_friend(this) {}
};
</code></pre>
<h2 id="constructors-in-rust"><a class="header" href="#constructors-in-rust">Constructors in Rust</a></h2>
<p>Rust does not have constructors in the same way as C++. Instead the term
"constructor" in Rust refers to a static method associated with a type (i.e., a
method that does not have a <code>self</code> parameter), which returns a value of the
type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32
}

impl Person {
    pub const fn with_age(a: i32) -&gt; Self {
        Self { age: a }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Typically the primary constructor for a type is named <code>new</code>, especially if it
takes no arguments. See the chapter on <a href="idioms/constructors/default_constructors.html">default
constructors</a>. Additional constructors
are usually named <code>with_details</code> (e.g., <code>Person::with_name</code>). See the <a href="https://rust-lang.github.io/api-guidelines/naming.html">naming
guidelines</a> for the
conventions on how to name constructor methods in Rust.</p>
<p>If the fields to be initialized are public, there is a reasonable default value,
and the value does not manage a resource, then it is also common to use record
update syntax to initialize a value based on some default value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl Point {
    pub const fn zero() -&gt; Self {
        Self { x: 0, y: 0, z: 0 }
    }
}

fn go() {
    let x_unit = Point {
        x: 1,
        ..Point::zero()
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>A similar approach in C++ would likely be discouraged because it would require
mutating a value, and so would prevent the variable from being <code>const</code>. In Rust
this is not required. This way of creating values is idiomatic.</p>
<h2 id="storage-allocation-vs-initialization"><a class="header" href="#storage-allocation-vs-initialization">Storage allocation vs initialization</a></h2>
<p>The actual construction of a structure or enum value in Rust occurs where the
structure construction syntax <code>A { ... }</code> is, after the evaluation of the
expressions for the fields.</p>
<p>A significant implication of this difference is that storage is not allocated
for a struct in Rust at the point where the "constructor" is called, and in fact
is not allocated until after the values of the fields of a struct have been
computed (in terms of the semantics of the language--the optimizer may still
avoid the copy). Therefore there is no way in Rust to write the C++ example
above where the class stores a pointer to itself upon construction.</p>
<!-- TODO refer to resource on how to model self-referential data structures. -->
<h2 id="fallible-constructors"><a class="header" href="#fallible-constructors">Fallible constructors</a></h2>
<p>In C++ the only way constructors can indicate failure is by throwing exceptions.</p>
<pre><code class="language-c++">#include &lt;stdexcept&gt;

class Person {
  int age;
public:
  A(int a) : age(a) {
    if myint &lt; 0 {
        throw std::domain_error("Bad argument");
    }
  }
};
</code></pre>
<p>In Rust, because constructors are normal static methods, fallible constructors
can instead return <code>Result</code> (akin to <code>std::expected</code>) or <code>Option</code> (akin to
<code>std::optional</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
}

impl Person {
<span class="boring">    // TODO showcase better practice for error type?
</span>    pub fn with_age(a: i32) -&gt; Result&lt;Self, &amp;'static str&gt; {
        if a &lt; 0 {
            Err("Bad argument")
        } else {
            Ok(Self { age: a })
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="idioms//exceptions.html">the chapter on exceptions</a> for more information on how C++
exceptions and exception handling translate to Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-constructors"><a class="header" href="#default-constructors">Default constructors</a></h1>
<h2 id="default-constructors-in-c"><a class="header" href="#default-constructors-in-c">Default constructors in C++</a></h2>
<p>C++ has a special concept of default constructors to support several scenarios
where they are implicitly called. For example,</p>
<ul>
<li>
<p>Initialization of class members without explicit initialization,</p>
<pre><code class="language-c++">class A {
  int m;

public:
  A() : m(42) {}
}

class S {
  A a;
}
</code></pre>
</li>
<li>
<p>Array declarations without explicit initialization of values,</p>
<pre><code class="language-c++">class A {
  int m;

public:
  A() : m(42) {}
}

void f() {
  A many_a[3];
  // ...
}
</code></pre>
</li>
<li>
<p>Initialization of the base class object when no other constructor is specified,</p>
<pre><code class="language-c++">class Base {
}

class Derived : Base {
  // default constructor implicitly defined
}
</code></pre>
</li>
<li>
<p>Container element initialization (until C++11) (one element is default
constructed, and the elements are copy constructed from that initial element):</p>
<pre><code class="language-c++">#include &lt;vector&gt;

class A {
  int m;

public:
  A() : m(42) {}
}

void f() {
  std::vector&lt;A&gt; v(3);
  // ...
}
</code></pre>
</li>
<li>
<p>Local variable definitions without explicit initialization,</p>
<pre><code class="language-c++">class A {
  int m;

public:
  A() : m(42) {}
}

void f() {
  A a;
  // ...
}
</code></pre>
</li>
</ul>
<h2 id="equivalents-in-rust"><a class="header" href="#equivalents-in-rust">Equivalents in Rust</a></h2>
<p>Rust does not have a notion of a default constructor in the same way as in C++.
Some of the uses cases are achieved via a different mechanism or with different
conventions, and others do not apply to Rust.</p>
<p>If a structure has a useful default value (such as would be constructed by a
default constructor in C++), then the type should provide
<a href="https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits">both</a>
a <code>new</code> method that takes no arguments and an implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code>
trait</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
   m: u32,
}

impl A {
    pub const fn new() -&gt; Self {
        Self { m: 42 }
    }
}

impl Default for A {
    fn default() -&gt; Self {
        Self::new()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If all of the members of the structure have an implementation of <code>Default</code>, then
an implementation for the structure can be provided by the compiler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct A {
    m: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>This is equivalent to writing</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    m: u32,
}

impl Default for A {
    fn default() -&gt; Self {
        A {
            m: Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The default value for the base integer and floating point types is zero.</p>
<p>The <code>Default</code> trait can be used to achieve many of the same things that are done
using the default constructor in C++. For example, to initialize a subset of
members of a struct to their default values one can use the <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update
syntax</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct A {
    m: u32,
}

#[derive(Default)]
struct B {
    a: A,
    b: u32,
    c: u32,
    d: f32,
}

impl B {
    pub fn with_c(c: u32) -&gt; Self {
        B {
            c,
            ..Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The trait is also used to support various standard library functions, such as:</p>
<ul>
<li>
<p>the <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-Debug-for-Box%3CT,+A%3E">implementation of the <code>Default</code> trait for the <code>Box</code>
type</a>,
which enables the construction of something similar to a <code>unique_ptr</code>,
initialized with a default value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct A {
</span><span class="boring">    m: u32,
</span><span class="boring">}
</span><span class="boring">
</span>fn make_boxed() -&gt; Box&lt;A&gt; {
    Default::default()
}
<span class="boring">}</span></code></pre></pre>
<p>This is similar to the following in C++:</p>
<pre><code class="language-c++">#include &lt;memory&gt;

template &lt;class T&gt; std::unique_ptr&lt;T&gt; default_unique_ptr() {
  return std::unique_ptr&lt;T&gt;(new T());
}
</code></pre>
</li>
<li>
<p>the <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default">implementation of
<code>Option::unwrap_or_default</code></a>,
which makes getting a default value when the <code>Option</code> does not contain a value
more convenient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: Option&lt;i32&gt;) {
    let a: i32 = x.unwrap_or_default();
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This is similar to the following in C++:</p>
<pre><code class="language-c++">#include &lt;optional&gt;

template &lt;class T&gt; T unwrap_or_default(std::optional&lt;T&gt; x) {
  if (x) {
    return *x;
  } else {
    return T();
  }
}
</code></pre>
<p>or in C++ since C++23:</p>
<pre><code class="language-c++">#include &lt;optional&gt;

template &lt;class T&gt; T unwrap_or_default(std::optional&lt;T&gt; x) {
  return x.or_else([] { return T(); });
}
</code></pre>
</li>
</ul>
<h2 id="situations-with-no-equivalent"><a class="header" href="#situations-with-no-equivalent">Situations with no equivalent</a></h2>
<p>Initialization of collections in Rust requires that a value be provided, in the
same way as in C++ since C++11. Also, much like how in C++ the copy constructor
is used to produce the elements of the vector, in Rust the <code>Clone</code>
implementation is used. See the chapter on <a href="idioms/constructors/copy_constructors.html">copy
constructors</a> for more details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone)]
struct A {
    m: u32,
}

fn foo() {
    let v: Vec&lt;A&gt; = vec![Default::default(); 3];
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Additionally, local variables in Rust must always be explicitly initialized
before use.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct A {
    m: u32,
}

fn foo() {
    let a: A; // this is NOT initialized with Default::&lt;A&gt;::default()
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Since Rust structures do not have inheritance, there is not a direct equivalent
to using the default constructor for initializing a base class. However, see the
chapter on <a href="idioms/constructors//idoms/implementation-reuse.html">implementation reuse</a> or the
section on <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits in the Rust
book</a> for alternatives.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-move-constructors"><a class="header" href="#copy-and-move-constructors">Copy and move constructors</a></h1>
<p>In both C++ and Rust you will rarely have to write copy or move constructors (or
their Rust equivalents) by hand. In C++ this is because the implicit definitions
are good enough for most purposes, especially if you make use of smart pointers.
(I.e., if you follow <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of
zero</a>.) In Rust this
is because move semantics are the default, and the automatically derived
implementations of the <code>Clone</code> and <code>Copy</code> traits are good enough for most
purposes.</p>
<p>For the following C++ classes, the implicitly defined copy and move constructors
are sufficient.</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;memory&gt;

struct Age {
  unsigned int years;

  Age(unsigned int years) : years(years) {}

  // copy and move constructors and destructor implicilty declared and defined
};

struct Person {
  Age age;
  std::string name;
  std::shared_ptr&lt;Person&gt; best_friend;

  Person(Age age, std::string name, std::shared_ptr&lt;Person&gt; best_friend)
      : age(age), name(name), best_friend(best_friend) {}

  // copy and move constructors and destructor implicilty declared and defined
};
</code></pre>
<p>The equivalent in Rust is</p>
<pre><code class="language-Rust">use std::rc::Rc;

#[derive(Clone, Copy)]
struct Age {
    years: u32,
}

#[derive(Clone)]
struct Person {
    age: Age,
    name: String,
    best_friend: Rc&lt;Person&gt;,
}
</code></pre>
<h2 id="user-defined-constructors"><a class="header" href="#user-defined-constructors">User-defined constructors</a></h2>
<p>On the other hand, the following example require a user-defined copy and move
constructor because it manages a resource (a pointer acquired from a C library).</p>
<pre><code class="language-c++">#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t*);
void copy_widget(widget_t* dst, widget_t* src);

// widget.cc
class Widget {
    widget_t* widget;
public:
    Widget() : widget(alloc_widget()) {}

    Widget(const Widget &amp;other) : widget(alloc_widget()) {
        copy_widget(widget, other.widget);
    }

    Widget(Widget &amp;&amp;other) : widget(other.widget) {
        other.widget = nullptr;
    }

    ~Widget() {
        free_widget(widget);
    }
};
</code></pre>
<p>The equivalent in Rust is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod example {
</span>mod widget_ffi {
    // Models an opaque type. See https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs
    #[repr(C)]
    pub struct CWidget {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    extern "C" {
        pub fn make_widget() -&gt; *mut CWidget;
        pub fn copy_widget(dst: *mut CWidget, src: *mut CWidget);
        pub fn free_widget(ptr: *mut CWidget);
    }
}

use self::widget_ffi::*;

struct Widget {
    widget: *mut CWidget,
}

impl Widget {
    fn new() -&gt; Self {
        Widget {
            widget: unsafe { make_widget() },
        }
    }
}

impl Clone for Widget {
    fn clone(&amp;self) -&gt; Self {
        let widget = unsafe { make_widget() };
        unsafe {
            copy_widget(widget, self.widget);
        }
        Widget { widget }
    }
}

impl Drop for Widget {
    fn drop(&amp;mut self) {
        unsafe { free_widget(self.widget) };
    }
}
}
<span class="boring">}</span></code></pre></pre>
<p>Just as with how in C++ it is uncommon to need user-defined implementations for
copy and move constructors or user-defined implementations for destructors, in
Rust it is rare to need to implement the <code>Clone</code> and <code>Drop</code> traits by hand.</p>
<p>There is one exception to this. If the type has type parameters, you might want
to implement <code>Clone</code> (and <code>Copy</code>) manually even if the clone should be done
field-by-field. See the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#how-can-i-implement-clone">standard library documentation of
<code>Clone</code></a>
and <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#how-can-i-implement-copy">of
<code>Copy</code></a>
for details.</p>
<h2 id="trivially-copyable-types"><a class="header" href="#trivially-copyable-types">Trivially copyable types</a></h2>
<p>Rust indicates whether types are trivially copyable with the <code>Copy</code> trait. Just
as with trivially copyable types in C++, types that implement <code>Copy</code> in Rust can
be copied bit-for-bit. Rust requires explicit calls to the <code>clone</code> method to
make copies of values of types that do not implement <code>Copy</code>.</p>
<p>Rust will prevent you from implementing <code>Copy</code> for a type if any of its fields
are not <code>Copy</code>, but will not prevent you from implementing <code>Copy</code> for types
which should not be copied bit-for-bit due to the intended meaning of the type
(which is usually reflected by a user-defined <code>Clone</code> implementation). Rust will
also not allow you to implement both <code>Copy</code> and <code>Drop</code> for the same type (which
matches the C++ standard's requirement that trivially copyable types not
implement a user-defined destructor).</p>
<p>Notice, for example that in the first Rust example, <code>Age</code> implements the <code>Copy</code>
trait but <code>Person</code> does not. This is because neither <code>std::String</code> nor
<code>Rc&lt;Person&gt;</code> implement <code>Copy</code>. They do not implement <code>Copy</code> because they own
data that lives on the heap, and so are not trivially copyable.</p>
<h2 id="move-constructors"><a class="header" href="#move-constructors">Move constructors</a></h2>
<p>In Rust, all types support move semantics by default, and custom move semantics
cannot be (and do not need to be) defined. This is because what "move" means in
Rust is not the same as it is in C++. In Rust, moving a value means changing
what owns the value. In particular, there is no "old" object to be destructed
after a move, because the compiler will prevent you from using a variable whose
value has been moved.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buffer {
    len: usize,
    buffer: Box&lt;[u8]&gt;,
}

impl Buffer {
    fn new(len: usize) {
        let other_buffer: Box&lt;[u8]&gt; = vec![0; len].into_boxed_slice();
    }
}

impl Clone for Buffer {
    fn clone(&amp;self) -&gt; Self {
        Buffer {
            len: self.len,
            buffer: self.buffer.clone(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment operators</a></h2>
<p>Rust does not have a copy or move assignment operator. Instead, assignment
either moves (by transferring ownership), explicitly clones and then moves, or
implicitly copies and then moves.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go() {
    let x = Box::&lt;u32&gt;::new(5);
    let y = x; // moves
    let z = y.clone(); // explicitly clones and then moves the clone
    let w = *y; // implicitly copies the content of the Box and then moves the copy
}
<span class="boring">}</span></code></pre></pre>
<p>For situations where something like a user-defined copy assignment could avoid
allocations, the <code>Clone</code> trait has an additional method called <code>clone_from</code>.
The method is usually automatically defined, but can be overridden when
implementing the <code>Clone</code> trait.</p>
<p>The method is not used for normal assignments, but can be explicitly used in
situations where the performance of the assignment is significant and would be
improved.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: &amp;Vec&lt;u32&gt;) {
    let mut y = vec![0; x.len()];
    // ...
    y.clone_from(&amp;x);
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-concerns-and-copy"><a class="header" href="#performance-concerns-and-copy">Performance concerns and <code>Copy</code></a></h2>
<p>The decision to implement <code>Copy</code> should be based on the semantics of the type,
not on performance. If you are worried about the size of objects being copied,
then use a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) or put it on the heap (<code>Box&lt;T&gt;</code>). These
situations correspond to passing by reference or using a <code>shared_ptr</code> in C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rule-of-threefivezero"><a class="header" href="#rule-of-threefivezero">Rule of three/five/zero</a></h1>
<h2 id="rule-of-three"><a class="header" href="#rule-of-three">Rule of three</a></h2>
<p>In C++ the rule of three is a rule of thumb that if a class has a user-defined
destructor, copy constructor or copy assignment operator, it probably should
have all three.</p>
<p>The corresponding rule for Rust is that if a type has a user-defined <code>Clone</code> or
<code>Drop</code> implementation, it probably needs both or to have no <code>Clone</code>
implementation at all.</p>
<p>This is for the same reason as the rule of three in C++: if a type has a
user-defined implementation for <code>Clone</code> or <code>Drop</code>, it is probably because the
type manages a resource, and both <code>Clone</code> and <code>Drop</code> will need to take special
actions for the resource.</p>
<h2 id="rule-of-five"><a class="header" href="#rule-of-five">Rule of five</a></h2>
<p>The rule of five in C++ states that if move semantics are needed for a type with
a user-defined copy constructor or copy assignment operator, then a user-defined
move constructor and move assignment should also be provided, because no
implicit move constructor or move assignment operator will be generated.</p>
<p>In Rust, this rule does not apply because of the <a href="idioms/constructors/copy_and_move_constructors.html#move-constructors">difference in move semantics
between C++ and Rust.</a></p>
<h2 id="rule-of-zero"><a class="header" href="#rule-of-zero">Rule of zero</a></h2>
<p>The rule of zero states that classes with user-defined copy/move constructors,
assignment operators, and destructors should deal only with ownership, and other
classes should not have those constructors or destructors. In practice, most
classes should make use of types from the STL (<code>shared_ptr</code>, <code>vector</code>, etc.) for
dealing with ownership concerns so that the implicitly defined copy and move
constructors are sufficient.</p>
<p>In Rust, the same is true...</p>
<p>TODO Move the following to a separate chapter on type equivalents and link to it
here.</p>
<p>The following table maps the ownership-managing classes from C++ to equivalents
types in Rust:</p>
<div class="table-wrapper"><table><thead><tr><th>C++ name</th><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>Owned in-place</td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td>Single ownership on heap</td><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>std::box::Box&lt;T&gt;</code></td></tr>
<tr><td>Shared ownership on heap</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;T&gt; or std::sync::Arc&lt;T&gt;</code></td></tr>
<tr><td>Shared ownership on heap of mutable value</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;RefCell&lt;T&gt;&gt; or std::sync::Arc&lt;RefCell&lt;T&gt;&gt;</code></td></tr>
<tr><td>Const observation pointer</td><td><code>const *T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable observation pointer</td><td><code>*T</code></td><td><code>&amp;mut T</code></td></tr>
<tr><td>Const reference</td><td><code>const &amp;T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable reference</td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr>
</tbody></table>
</div>
<p>There are also types that manage ownership while also providing other
functionality...</p>
<p>In some cases, multiple types might be needed to achieve the same effect. A C++
<code>shared_ptr</code> allows all of the sharing owners to mutate the object, even if
there is more than one owner. In Rust, this is not allowed. Instead, the <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">type
<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> must be
used</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separate-construction-and-initialization"><a class="header" href="#separate-construction-and-initialization">Separate construction and initialization</a></h1>
<p>A second common use is for partially constructed objects, e.g., in codebases
that make initialization a separate step from construction.</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;memory&gt;

struct Movie {
    std::string title;
};

class Person {
	std::shared_ptr&lt;Movie&gt; favorite_movie;
public:
    Person() : favorite_movie(nullptr) {}

    Person&amp; init(std::shared_ptr&lt;Movie&gt; favorite_movie) {
        this-&gt;favorite_movie = favorite_movie;

        return *this;
    }
};
</code></pre>
<p>This pattern may be used for one of two reasons:</p>
<ul>
<li>A desire to incrementally initialize the object using some kind of builder
pattern. This usually involves returning a reference to the object so that the
initialization methods can be chained together, as <code>init</code> does in the above
example.</li>
<li>A desire to re-use allocated objects, in which case the class usually also has
some kind of <code>clear()</code> method to prepare the object to be reused. This is most
common in embedded programming as an alternative to dynamic allocation.</li>
</ul>
<p>In Rust, the normal approach to the first reason is to use a builder pattern.
This involves defining a second type to represent the partially constructed
object, where each field in the original object of type <code>T</code> has type <code>Option&lt;T&gt;</code>
in the builder. For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
    name: String,
}

struct PersonBuilder {
    age: Option&lt;i32&gt;,
    name: Option&lt;String&gt;,
}

impl PersonBuilder {
    fn new() -&gt; PersonBuilder {
        PersonBuilder { age: None, name: None }
    }

    fn age(&amp;mut self, age: i32) -&gt; &amp;mut Self {
        self.age = Some(age);
        self
    }

    fn name(&amp;mut self, name: String) -&gt; &amp;mut Self {
        self.name = Some(name);
        self
    }

    fn build(&amp;self) -&gt; Option&lt;Person&gt; {
        Some(Person {
            age: self.age?,
            name: match self.name {
                Some(ref name) =&gt; name.clone(),
                None =&gt; return None,
            },
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern is sufficiently common that there are libraries to support it, such
as the <a href="https://crates.io/crates/derive_builder"><code>derive_builder</code> crate</a>. Using
that crate, the above example would just be</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Person {
    age: i32,
    name: String,
}</code></pre>
<p>and the resulting API would include additional features, such as the <code>build</code>
method returning a <code>Result</code> with an informative error, rather than just <code>None</code>,
when not all of required fields are set.</p>
<p>If there is a reasonable default value for the object, then instead of the
builder pattern, the <code>Default</code> trait can be implemented, and <a href="idioms/constructors//idioms/constructors/default_constructors.html#equivalents-in-rust">values can be
constructed based on a default
value</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructors-and-resource-cleanup"><a class="header" href="#destructors-and-resource-cleanup">Destructors and resource cleanup</a></h1>
<p>In C++, destructors are defined by providing a special member function. To
achieve the equivalent in Rust, implement the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code>
trait</a>.</p>
<p>For an example, see <a href="idioms/constructors/copy_and_move_constructors.html#user-defined-constructors">the example in the chapter on copy and move
constructors</a>.</p>
<p><code>Drop</code> implementations play the same role as destructors in C++ for types that
manage resources. That is, they enable cleanup of resources owned by the value
at the end of the value's lifetime (i.e., <a href="idioms//idioms/raii.html">RAII</a>).</p>
<p>In Rust the <code>Drop::drop</code> method is called the "destructor", but we will refer to
it as "the drop method" here, to clearly distinguish between it and C++
destructors.</p>
<h2 id="lifetimes-and-destructors"><a class="header" href="#lifetimes-and-destructors">Lifetimes and destructors</a></h2>
<p>C++ destructors are called in reverse order of construction when variables go out
of scope, of for dynamically allocated objects, when they are deleted. Because
of how move constructors work, this includes destructors of moved objects.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A {
    int id;

    A(int id) : id(id) {}

    // copy constructor
    A(A&amp; other) : id(other.id) {}

    // move constructor
    A(A&amp;&amp; other) : id(other.id) {
        other.id = 0;
    }

    // deconstructor
    ~A() {
        std::cout &lt;&lt; id &lt;&lt; std::endl;
    }
};

int accept(A x) {
    return x.id;
} // the destructor of x is called after the return expression is evaluated

// Prints:
// 2
// 3
// 0
// 1
int main() {
    A x(1);
    A y(2);

    accept(std::move(y));

	A z(3);

    return 0;
}
</code></pre>
<p>In Rust, the drop order is similar to that of C++ (reverse order of
declaration). If additional specific details about the drop order are needed
(e.g., for writing unsafe code), the full rules for the drop order are described
in <a href="https://doc.rust-lang.org/reference/destructors.html">the language
reference</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct A {
    id: i32,
}

impl Drop for A {
    fn drop(&amp;mut self) {
        println!("{}", self.id)
    }
}

fn accept(x: A) -&gt; i32 {
    return x.id;
}

// Prints:
// 2
// 3
// 1
fn main() {
    let x = A { id: 1 };
    let y = A { id: 2 };

    accept(y);

    let z = A { id: 3 };
}</code></pre></pre>
<p>One particular difference between C++ and Rust is that after ownership of <code>y</code> is
moved into the function <code>acccept</code>, there is no additional object remaining, and
so there is no additional <code>Drop::drop</code> call (which in the C++ example prints <code>0</code>).</p>
<p>Rust's drop methods do run when leaving scope due to a panic, though not if the
panic occurs in a destructor that was called in response to an initial panic.</p>
<h2 id="early-cleanup-and-explicitly-destroying-values"><a class="header" href="#early-cleanup-and-explicitly-destroying-values">Early cleanup and explicitly destroying values</a></h2>
<p>In C++ you can explicitly destroy an object. This is mainly useful for
situations where placement new has been used to allocate the object at a
specific memory location, and so the destructor will not be implicitly called.</p>
<p>However, once the destructor has been explicitly called, <a href="https://eel.is/c++draft/class.dtor#note-8">it may not be called
again, even implicitly</a>. Thus the
destructor can't be used for early cleanup. Instead, either the class must be
designed with a separate cleanup method that releases the resources but leaves
the object in a state where the destructor can be called or the function using
the object must be structured so that the variable goes out of scope at the
desired time.</p>
<p>In Rust, values can be dropped early for early cleanup by using
<a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>. This works
because (<a href="idioms//idioms/constructors/copy_and_move_constructors.html#trivially-copyable-types">for non-<code>Copy</code>
types</a>)
ownership of the object is actually transferred to <code>std::mem::drop</code> function,
and so <code>Drop::drop</code> is called at the end of <code>std::mem::drop</code>.</p>
<p>Thus, <code>std::mem::drop</code> can be used for early cleanup of resources without having
to restructure a function to force variables out of scope early.</p>
<p>For example, the following allocates a large vector on the heap, but explicitly
drops it before allocating a second large vector on the heap, reducing the
overall memory usage.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![0u32; 100000];
    // ... use v

    std::mem::drop(v);
    // can no longer use v here

    let v2 = vec![0u32; 100000];
    // ... use v2
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h1>
<p>One idiom for returning multiple values in C++ is to pass in references to which
the values can be assigned. E.g.,</p>
<pre><code class="language-c++">void get_point(int &amp;x, int &amp;y) {
    x = 5;
    y = 6;
}

int compute_norm() {
    int x, y;

    get_point(x, y);

    return x + y;
}
</code></pre>
<p>There are several reasons why this idiom might be used:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, or</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic translation of this program into Rust makes use of either
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> or a named
structure for the return type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_point() -&gt; (i32, i32) {
    (5, 6)
}

pub fn compute_norm() -&gt; i32 {
    let (x, y) = get_point();
    x + y
}
<span class="boring">}</span></code></pre></pre>
<p>Rust has a dedicated tuple syntax and pattern matching with <code>let</code> bindings in
part to support use cases like this one.</p>
<h2 id="problems-with-the-direct-transliteration"><a class="header" href="#problems-with-the-direct-transliteration">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate this to Rust, but Rust requires the
initialization of the variables. The resulting program is not idiomatic Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOT IDIOIMATIC RUST
fn get_point(x: &amp;mut i32, y: &amp;mut i32) {
    *x = 5;
    *y = 6;
}

fn compute_norm() -&gt; i32 {
    let mut x = 0; // initliazed to arbitrary values
    let mut y = 0;

    get_point(&amp;mut x, &amp;mut y);

    x + y
}
<span class="boring">}</span></code></pre></pre>
<p>In addition to sacrificing conciseness, this approach requires assigning
arbitrary initial values to the variables and making the variables mutable, both
of which make it harder for the compiler to help with avoiding programming
errors.</p>
<p>Additionally, the Rust compiler is tuned for optimizing the idiomatic version of
the program, and does produce a significantly faster binary for that version.</p>
<p>In situations where the performance of memory allocation is a concern (such as
when it is necessary to reuse entire buffers in memory), the trade-offs may be
different. That situation is discussed in the chapter on <a href="idioms/out_params//idioms/out_params/pre-allocated_buffers.html">pre-allocated
buffers</a>.</p>
<h2 id="similarities-with-idiomatic-c-since-c11"><a class="header" href="#similarities-with-idiomatic-c-since-c11">Similarities with idiomatic C++ since C++11</a></h2>
<p>In C++11 and later, it <code>std::pair</code> and <code>std::tuple</code> are available for returning
multiple values instead of assigning to reference parameters.</p>
<pre><code class="language-c++">#include &lt;utility&gt;
#include &lt;tuple&gt;

std::pair&lt;int,int&gt; get_point() {
	return std::pair&lt;int,int&gt;(5, 6);
}

int compute_norm() {
	int x, y;
	std::tie(x, y) = get_point();

    return x + y;
}
</code></pre>
<p>This more closely aligns with the normal Rust idiom for returning multiple
values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-return-values"><a class="header" href="#optional-return-values">Optional return values</a></h1>
<p>Similarly to with multiple return values, a common idiom in C++ code is to use a
reference parameter along with a boolean or integer return value to return an
optional result from a function. This might be done for the same reasons as for
using out parameters for multiple return values:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, and</li>
<li>performance concerns.</li>
</ul>
<p>For example,</p>
<pre><code class="language-c++">bool safe_divide(int dividend, int divisor, int &amp;quotient) {
	if (divisor != 0) {
		quotient = dividend/divisor;
		return true;
    } else {
        return false;
    }
}

void go(int dividend, int divisor) {
    int quotient;
    if (safe_divide(dividend, divisor, quotient)) {
        // use quotient
    } else {
        // handle edge case
    }
}
</code></pre>
<p>The idiomatic Rust approach for both of these situations is to return a value of
type <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>.</p>
<p>The first case becomes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_divide(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor != 0 {
        Some(dividend / divisor)
    } else {
        None
    }
}

fn go(dividend: i32, divisor: i32) {
    match safe_divide(dividend, divisor) {
        Some(quotient) =&gt; {
            // use quotient
        }
        None =&gt; {
            // handle other case
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When the value being returned is a pointer, another common idiom in C++ is to
use <code>nullptr</code> to represent the optional case. For the Rust translation of that,
see <a href="idioms/out_params/TODO">the chapter on nullable types</a>.</p>
<!-- TODO move to chapter on nullable types

When the returned value is a pointer, a null pointer is often used instead of
this pattern.

```c++
#include <memory>
struct Person {
    int age;
	Person(int age) : age(age) {}
};

std::unique_ptr<Person> maybe_create(int age) {
    if (age >= 0) {
        return std::make_unique<Person>(age);
    } else {
        return nullptr;
    }
}
```

Additionally, Rust has [an optimization for
`Option`](https://doc.rust-lang.org/std/option/#representation) when the
contained type is part of the standard library and can represent the `None` case
without an extra word of memory.

-->
<p>Normally the constructors of an <code>enum</code> have to be qualified by the type (as in
<code>Option::None</code>), but Rust's <code>Option</code> type is actually so commonly used that
<a href="https://doc.rust-lang.org/std/prelude/index.html">the prelude</a> exports the
variants directly, so that program above can be written instead without the
<code>Option::</code> prefixes.</p>
<h2 id="problems-with-the-direct-transliteration-1"><a class="header" href="#problems-with-the-direct-transliteration-1">Problems with the direct transliteration</a></h2>
<p>This can be transliterated into Rust, but the result is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOT IDIOIMATIC RUST
fn safe_divide(dividend: i32, divisor: i32, quotient: &amp;mut i32) -&gt; bool {
	if (divisor != 0) {
		*quotient = dividend/divisor;
        true
    } else {
        false
    }
}

fn go(dividend: i32, divisor: i32) {
    let mut quotient: i32 = 0; // initliazed to arbitrary value
    if safe_divide(dividend, divisor, &amp;mut quotient) {
        // use quotient
    } else {
        // handle other case
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This shares the same problems as with using out-parameters for <a href="idioms/out_params//idioms/out_params/multiple_return.html">multiple return
values</a>.</p>
<h2 id="c-stdoptional"><a class="header" href="#c-stdoptional">C++ <code>std::optional</code></a></h2>
<p>C++17 and later offer <code>std::optional</code>, which can be used to express optional
return values in a way similar to the idiomatic Rust, but which have fewer
safety guarantees around the use of the returned value.</p>
<pre><code class="language-c++">#include &lt;optional&gt;

std::optional&lt;int&gt; safe_divide(int dividend, int divisor) {
	if (divisor != 42) {
		return std::optional&lt;int&gt;(dividend/divisor);
    } else {
        return std::nullopt;
    }
}

void go(int dividend, int divisor) {
    int quotient;
    if (auto quotient = foo(x)) {
		// use quotient
    } else {
		// handle other case
    }
}
</code></pre>
<h2 id="helpful-option-utilities"><a class="header" href="#helpful-option-utilities">Helpful <code>Option</code> utilities</a></h2>
<p>When the <code>None</code> case really is an edge case, the <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let-else</code>
syntax</a>
can be used to make that clearer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn safe_divide(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: i32, divisor: i32) {
    let Some(x) = safe_divide(dividend, divisor) else {
        // handle other case
        return;
    };
    // use quotient
}
<span class="boring">}</span></code></pre></pre>
<p>If there is a default value that should be used in the <code>None</code> case, the
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>Option::unwrap_or</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option::unwrap_or_else</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>,
or
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
methods can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn safe_divide(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn expensive_computation() -&gt; i32 {
    // ...
<span class="boring">   0
</span>}

fn go(dividend: i32, divisor: i32) {
    // If None, returns the given value.
    let result = safe_divide(dividend, divisor).unwrap_or(0);

    // If None, returns the result of calling the given function.
    let result2 = safe_divide(dividend, divisor).unwrap_or_else(expensive_computation);

    // If None, returns Default::default(), which is 0 for i32.
    let result3 = safe_divide(dividend, divisor).unwrap_or_default();

    // If None, panics. Prefer the other methods!
    let result3 = safe_divide(dividend, divisor).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>In performance-sensitive code where you have manually checked that the result is
guaranteed to be <code>Some</code>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_unchecked"><code>Option::unwrap_unchecked</code></a>
can be used, but is an unsafe method.</p>
<p>There are <a href="https://doc.rust-lang.org/std/option/#boolean-operators">additional utility
methods</a> that enable
concise handling of <code>Option</code> values, which this book covers in the chapter on
<a href="idioms/out_params//idioms/exceptions.html">exceptions and error handling</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-allocated-buffers"><a class="header" href="#pre-allocated-buffers">Pre-allocated buffers</a></h1>
<p>There are situations where large quantities of data need to be returned from a
function that will be called repeatedly, so that incurring the copies involved
in returning by value or repeated heap allocations would be cost prohibitive.
Some of these situations include:</p>
<ul>
<li>performing file or network IO,</li>
<li>communicating with graphics hardware,</li>
<li>communicating with hardware on embedded systems, or</li>
<li>implementing cryptography algorithms.</li>
</ul>
<p>In these situations, C++ programs tend to pre-allocate buffers that are reused
for all calls. This also usually enables allocating the buffer on the stack,
rather than having to perform dynamic allocation. For example,</p>
<pre><code class="language-c++">#include &lt;fstream&gt;

int main() {
    std::ifstream file("/path/to/file");
    if (!file.is_open()) {
        return -1;
    }

    char buf[1024];
    while (file.good()) {
        file.read(buf, sizeof buf);
        std::streamsize count = file.gcount();

        // use data in buf
    }

    return 0;
}
</code></pre>
<p>An equivalent Rust program is:</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{Read, BufReader};

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut f = BufReader::new(File::open("/path/to/file")?);

    let mut buf = [0u8; 1024];

    while let count = f.read(&amp;mut buf)? {
        if count == 0 {
            break;
        }
        // use data in buf
    }

    Ok(())
}</code></pre></pre>
<p>The major difference between the C++ program and the Rust program is that in the
Rust program the buffer must be initialized before it can be used. In most
cases, this one-time initialization cost is not significant. When it is, unsafe
Rust is required to avoid the initialization.</p>
<p>The technique makes use of
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>std::mem::MaybeUninit</code></a>.
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#examples">Examples of safe usage of
<code>MaybeUninit</code></a>
are given in the API documentation for the type.</p>
<p>The IO API in stable Rust does not include support for <code>MaybeUninit</code>. Instead,
there is a <a href="idioms/out_params/pre-allocated_buffers.html#upcoming-changes-and-borrowedbuf">new safe API being developed</a>
that will enable avoiding initialization without requiring unsafe Rust in code
that uses the API.</p>
<p>If the callee might need to grow the provided buffer and dynamic allocation is
allowed, then a <code>&amp;mut Vec&lt;T&gt;</code> can be used instead of <code>&amp;mut [T]</code>. This is similar
to providing a <code>std::vector&lt;T&gt;&amp;</code> in C++. To avoid unnecessary allocations, the
vector can be created using <code>Vec::&lt;T&gt;::with_capacity(n)</code>.</p>
<h2 id="a-note-on-reading-files"><a class="header" href="#a-note-on-reading-files">A note on reading files</a></h2>
<p>While the examples here use IO to demonstrate re-using pre-allocated buffers,
there are higher-level interfaces available for reading from <code>File</code>s, both from
the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> traits, and
from convenience functions in
<a href="https://doc.rust-lang.org/std/io/index.html#functions-1"><code>std::io</code></a> and in
<a href="https://doc.rust-lang.org/std/fs/index.html#functions-1"><code>std::fs</code></a>.</p>
<p>The techniques described here are useful, however, in other situations where a
reusable buffer is required, such as when interacting with hardware APIs, when
using existing C or C++ libraries, or when implementing algorithms that produce
larges amount of data in chunks, such as cryptography algorithms.</p>
<h2 id="upcoming-changes-and-borrowedbuf"><a class="header" href="#upcoming-changes-and-borrowedbuf">Upcoming changes and <code>BorrowedBuf</code></a></h2>
<p>The Rust community is refining approaches to working with uninitialized buffers.
If you can use the nightly branch of Rust, you can use
<a href="https://doc.rust-lang.org/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a> to
achieve the same results as when using slices of <code>MaybeUninit</code>, but without
having to write any unsafe code yourself. The IO APIs for avoiding unnecessary
initialization use <code>BorrowedBuf</code> instead of slices of <code>MaybeUninit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions-and-error-handling"><a class="header" href="#exceptions-and-error-handling">Exceptions and error handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-identity"><a class="header" href="#object-identity">Object identity</a></h1>
<p>In C++ the pointer to an object is sometimes used to represent its identity in
terms of the logic of a program.</p>
<p>In some cases, this is a standard optimization, such as when implementing the
copy assignment operator.</p>
<p>In other cases the pointer value is used as a logical identity to distinguish
between specific instances of an object that otherwise have the same properties.
For example, representing a labeled graph where there may be distinct nodes that
have the same label.</p>
<p>In Rust, some of these cases are not applicable, and others cases are typically
handled by instead by implementing a synthetic notion of identity for the
values.</p>
<h2 id="overloading-copy-assignment-and-equality-comparison-operators"><a class="header" href="#overloading-copy-assignment-and-equality-comparison-operators">Overloading copy assignment and equality comparison operators</a></h2>
<p>For example, when implementing the copy-assignment operator, one might
short-circuit when the copied object and the assignee are the same.
Not that in this use the pointer values are not stored.</p>
<pre><code class="language-c++">struct Person
{
    std::string name;
    // many other expensive-to-copy fields

    Person&amp; operator=(const Person&amp; other) {
        // compare object identity first
        if (this != &amp;other) {
            this.name = other.name;
            // copy the other expensive-to-copy fields
        }

        return *this;
    }
};
</code></pre>
<p>This kind of optimization is unnecessary when implementing <a href="idioms//idioms/constructors/copy_and_move_constructors.html#assignment-operators">Rust's equivalent to
the copy assignment
operator</a>
<code>Clone::clone_from</code>. The type of <code>Clone::clone_from</code> prevents the same object
from being passed as both arguments, because one of the arguments is a mutable
reference, which is exclusive, and so prevents the other reference argument from
referring to the same object.</p>
<p>In cases in C++ where most comparisons are between an object and itself (e.g.,
the object's primary use is to be stored in a hash set), and comparison of
unequal objects is expensive, comparing object identity might be used as
optimization for the equality comparison operator overload.</p>
<pre><code class="language-c++">struct Person
{
    std::string name;
    // many other expensive-to-compare fields
};


bool operator==(const Person&amp; lhs, const Person&amp; rhs) {
    // compare object identity first
    if (&amp;lhs == &amp;rhs) {
        return true;
    }

    // compare the other expensive-to-compare fields

    return true;
}
</code></pre>
<p>For supporting similar operations in Rust,
<a href="https://doc.rust-lang.org/std/ptr/fn.eq.html"><code>std::ptr::eq</code></a> can be used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    // many other expensive-to-compare fields
}

impl PartialEq for Person {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if std::ptr::eq(self, other) {
            return true;
        }
        // compare other expensive-to-compare fields

        true
    }
}

impl Eq for Person {}
<span class="boring">}</span></code></pre></pre>
<h2 id="distinguishing-between-values-in-a-relational-structure"><a class="header" href="#distinguishing-between-values-in-a-relational-structure">Distinguishing between values in a relational structure</a></h2>
<p>The other use is when relationships between values are represented using a data
structure external to the values, such as when representing a labeled graph in
which multiple nodes might share the same label, but have edges between
different sets of other nodes. This differs from the earlier case because the
pointer value is preserved.</p>
<p>One real-world example of this is in the LLVM codebase, where occurrences of
declarations, statements, and expressions in the AST are distinguished by object
identity. For example, variable expressions (<code>class DeclRefExpr</code>) contain the
<a href="https://github.com/llvm/llvm-project/blob/ddc48fefe389789f64713b5924a03fb2b7961ef3/clang/include/clang/AST/Expr.h#L1265C1-L1275C16">pointer to the occurrence of the declaration to which the variable
refers</a>.</p>
<p>Similarly, when comparing whether two variable declarations represent
declarations of the same variable, <a href="https://github.com/llvm/llvm-project/blob/aa33c095617400a23a2b814c4defeb12e7761639/clang/lib/AST/Stmt.cpp#L1476-L1485">a pointer to some canonical <code>VarDecl</code> is
used</a>:</p>
<pre><code class="language-c++">VarDecl *VarDecl::getCanonicalDecl();

bool CapturedStmt::capturesVariable(const VarDecl *Var) const {
  for (const auto &amp;I : captures()) {
    if (!I.capturesVariable() &amp;&amp; !I.capturesVariableByCopy())
      continue;
    if (I.getCapturedVar()-&gt;getCanonicalDecl() == Var-&gt;getCanonicalDecl())
      return true;
  }

  return false;
}
</code></pre>
<p>This kind of use is often discouraged in C++ because of the risk of
use-after-free bugs, but might be used in performance sensitive applications
where either storing the memory to represent the mapping or the additional
indirection to resolve an entity's value from its identity is cost prohibitive.</p>
<p>In Rust it is generally preferred to represent the identity of the objects with
synthetic identifiers. This is in part as a technique for modeling
self-referential data structures.</p>
<p>As an example, one popular Rust graph library
<a href="https://docs.rs/petgraph/latest/petgraph/">petgraph</a> uses <code>u32</code> as its default
node identity type. This incurs the cost of an extra call to dereference the
synthetic identifier to the label of the represented node as well as the extra
memory required to store the mapping from nodes to labels.</p>
<p>A simplified graph representation using the same synthetic identifier technique
would look like the following, which represents the node identities by their
index in the vectors that represent the labels and the edges.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Blue
}

struct Graph {
    /// Maps from node id to node labels, which here are colors.
    nodes_labels: Vec&lt;Color&gt;,

    /// Maps from node id to adjacent nodes ids.
    edges: Vec&lt;Vec&lt;usize&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If performance requirements make the use of synthetic identifiers unacceptable,
then it may be necessary to use prevent the value from being moved by using
<a href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code></a>, which is similar to
deleting the move constructor in C++.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
