<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Phrasebook for C++ Programmers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Phrasebook for C++ Programmers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-phrasebook-for-c-programmers"><a class="header" href="#rust-phrasebook-for-c-programmers">Rust Phrasebook for C++ Programmers</a></h1>
<p>The goal of this book is to make programming in Rust less frustrating for C++
programmers by providing translations of common C++ idioms and patterns into
idiomatic Rust. Along with the translations, there are explanations of the
reasons for the differences and descriptions of the and engineering trade-offs
involved.</p>
<p>The translations are often not straightforward transliterations. Instead, they
are more comprehensive changes of to how to approach, using Rust, the kinds of
problems that the C++ idioms and patterns are intended to address.</p>
<p>The book is structured to make it possible to read it front-to-back. Ideally,
after reading this book, one's "idiom list" for Rust should be significantly
more robust, leading to a more enjoyable and productive experience programming
in Rust.</p>
<p>The chapters are also organized around C++ concepts instead of Rust concepts, to
aid C++ programmers in finding a specific solution to a problem in terms that
will be natural to them while they are learning Rust.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>If you are not primarily a C or C++ programmer, <a href="https://rust-book.cs.brown.edu/">The Rust Programming
Language</a> may be a better starting point.</p>
<p>If you are primarily an embedded systems programmer using C or C++, this book is
a complement to <a href="https://docs.rust-embedded.org/book/">The Embedded Rust Book</a>.</p>
<h2 id="feedback-on-this-book"><a class="header" href="#feedback-on-this-book">Feedback on this book</a></h2>
<p>TODO: add ask for feedback on missing content</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-modeling"><a class="header" href="#data-modeling">Data modeling</a></h1>
<p>In C++ the mechanisms available for data modeling are classes, enums, and
unions.</p>
<p>Rust, on the other hand, uses records
(<a href="https://doc.rust-lang.org/book/ch05-00-structs.html">structs</a>) and algebraic
data types (<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">enums</a>).</p>
<p>Although Rust supports one major piece of object oriented design, interface
polymorphism, Rust also has language features for modeling things using
algebraic data types (which in simple cases are like a much more ergonomic
<code>std::variant</code>).</p>
<p>This section gives examples of common constructions used when programming in C++
data and how to achieve the same effects using Rust's features.</p>
<h2 id="fixed-operations-varying-data"><a class="header" href="#fixed-operations-varying-data">Fixed operations, varying data</a></h2>
<p>In situations where one needs to model a fixed set of operations that clients
will use, but the data that implements those operations are not fixed ahead of
time, the approach in C++ and the approach in Rust are the same. In both cases
interfaces that defines the required operations are defined. Concrete types,
possibly defined by the client, implement those interfaces.</p>
<p>This way of modeling data can make use of either
<a href="idioms//idioms/data_modeling/pure_virtual_classes.html">dynamic</a> or <a href="idioms//idioms/data_modeling/concepts.html">static
dispatch</a>, each of which is covered in its
own section.</p>
<h2 id="fixed-data-varying-operations"><a class="header" href="#fixed-data-varying-operations">Fixed data, varying operations</a></h2>
<p>In situations where there is a fixed set of data but the operations that the
data must support vary, there are a few approaches in C++. Which approaches are
available to use depend on the version of the standard in use.</p>
<p>In older versions of the standard, one might use manually defined tagged unions.
In newer versions, <code>std::variant</code> is available to improve the safety and
ergonomics of tagged unions. <a href="idioms//idioms/data_modeling/tagged_unions.html">Both of these approaches map to the same approach
in Rust</a>.</p>
<p>Additionally, despite it not being strictly necessary to model a fixed set of
variants, the visitor pattern is sometimes used for this situation, especially
when using versions of the C++ standard before the introduction of
<code>std::variant</code>. In most of these cases the idiomatic Rust solution is the same
as what one would do when converting a C++ solution that uses tagged unions. The
chapter on the <a href="idioms/TODO">visitor pattern</a> describes when to use a Rust version of
the visitor pattern or when to use Rust's enums (which are closer to
<code>std::variant</code> than to C++ enums) to model the data.</p>
<h2 id="varying-data-and-operations"><a class="header" href="#varying-data-and-operations">Varying data and operations</a></h2>
<p>When both data and operations may be extended by a client, the <a href="idioms/TODO">visitor pattern
is used in both C++ and in Rust</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>In C++, enums are often used to model fixed set alternatives, especially when
each of those enumerators maps to a specific integer value, such as is needed
when working with hardware, system calls, or protocol implementations.</p>
<p>For example, the various modes for a GPIO pin could be modeled as an enum, which
would restrict methods using the mode to valid values.</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

enum Pin : uint8_t {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04
};

enum Mode : uint8_t {
    Output            = 0x03,
    Pullup            = 0x04,
    Analog            = 0x27
    // ...
};

void lowLevelSetPin(uint8_t pin, uint8_t mode);

void setPinMode(Pin pin, Mode mode) {
    lowLevelSetPin(pin, mode);
}
</code></pre>
<p>While Rust enums are <a href="idioms/data_modeling/./idioms/data_modeling/tagged_unions.html">more general</a>,
they also can be used for this sort of modeling.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

#[repr(u8)]
#[derive(Clone, Copy)]
enum Mode {
    Output = 0x03,
    Pullup = 0x04,
    Analog = 0x27,
    // ...
}

extern "C" {
    fn low_level_set_pin(pin: u8, mode: u8);
}

fn set_pin_mode(pin: Pin, mode: Mode) {
    unsafe { low_level_set_pin(pin as u8, mode as u8) };
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[repr(u8)]</code> attribute ensures that the representation of the enum is the
same as a byte (like declaring the underlying type of an enum in C++). The enum
values can then be freely converted to the underlying type with the <code>as</code>.</p>
<p>In C++ the standard way to convert from an integer to an enum is a static cast.
However, this <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1766">requires that the user check the validity of the cast
themselves</a>.
Often the conversion is done by a function that checks that the value to convert
is a valid enum value.</p>
<pre><code class="language-cpp">Pin cast_to_pin(uint8_t pin) {
    return static_cast&lt;Pin&gt;(pin);
}

struct InvalidPin {
    uint8_t pin;
};

Pin to_pin(uint8_t pin) {
    switch (pin) {
	case 0x1: { return Pin1; }
	case 0x2: { return Pin2; }
    case 0x4: { return Pin3; }
	default: { throw InvalidPin{pin}; }
    }
}
</code></pre>
<p>In Rust the standard way to perform the conversion is to implement the <code>TryFrom</code>
trait for the type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Pin {
</span><span class="boring">    Pin1 = 0x01,
</span><span class="boring">    Pin2 = 0x02,
</span><span class="boring">    Pin3 = 0x04,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Mode {
</span><span class="boring">    Output = 0x03,
</span><span class="boring">    Pullup = 0x04,
</span><span class="boring">    Analog = 0x27,
</span><span class="boring">    // ...
</span><span class="boring">}
</span>
use std::convert::TryFrom;

struct InvalidPin(u8);

impl TryFrom&lt;u8&gt; for Pin {
    type Error = InvalidPin;

    fn try_from(value: u8) -&gt; Result&lt;Self, Self::Error&gt; {
       match value {
           0x01 =&gt; Ok(Pin::Pin1),
           0x02 =&gt; Ok(Pin::Pin2),
           0x04 =&gt; Ok(Pin::Pin3),
           pin =&gt; Err(InvalidPin(pin)),
       }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="idioms/data_modeling//idioms/exceptions.html">Exceptions and error handling</a> for examples of how
to ergonomically handle the result of <code>try_from</code>.</p>
<p>If low-level performance is more of a concern than memory safety,
<code>std::mem::transmute</code> is analogous to a C++ reinterpret cast, but requires
unsafe Rust because its use can result in undefined behavior. Uses of
<code>std::mem::transmute</code> for this purpose should not be hidden behind an interface
that can be called from safe Rust unless the interface can actually guarantee
that the call will never happen with an invalid value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-unions-and-stdvariant"><a class="header" href="#tagged-unions-and-stdvariant">Tagged unions and <code>std::variant</code></a></h1>
<h2 id="c-style-tagged-unions"><a class="header" href="#c-style-tagged-unions">C-style tagged unions</a></h2>
<p>Because unions cannot be used for type punning in C++, when they are used it is
usually with a tag to discriminate between which variant of the union is active.</p>
<pre><code class="language-cpp">enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union Value {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  } value;

  double area() {
    switch (this-&gt;tag) {
    case Rectangle: {
      return this-&gt;value.rectangle.width * this-&gt;value.rectangle.height;
    }
    case Triangle: {
      return 0.5 * this-&gt;value.triangle.base * this-&gt;value.triangle.height;
    }
    }
  }
};
</code></pre>
<p>Rust's equivalent to union types are always tagged. They are a generalization of
Rust enums, where additional data may be associated with the enum variants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Triangle { base, height } =&gt; 0.5 * base * height,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-the-value-without-checking-the-discriminant"><a class="header" href="#accessing-the-value-without-checking-the-discriminant">Accessing the value without checking the discriminant</a></h2>
<p>Unlike with C-style unions, Rust always requires matching on the discriminant
before accessing the values. If the variant is already known, e.g., due to an
earlier check, then the code can usually be refactored to encode the knowledge
in the type so that the second check (and corresponding error handling) can be
omitted.</p>
<p>A C++ program like the following requires more restructuring of the types to
achieve the same goal in Rust.</p>
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

std::vector&lt;Shape&gt; get_shapes() {
  return std::vector&lt;Shape&gt;{
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},
  };
}

std::vector&lt;Shape&gt; get_shapes();

int main() {
  std::vector&lt;Shape&gt; shapes = get_shapes();

  auto is_triangle = [](Shape shape) { return shape.tag == Triangle; };

  // Create an iterator that only sees the triangles. (std::views::filter is
  // from C++20, but the same effect can be acheived with a custom iterator.)
  auto triangles = shapes | std::views::filter(is_triangle);

  double total_base = 0.0;
  for (auto &amp;triangle : triangles) {
    // Skip checking the tag because we know we have only triangles.
    total_base += triangle.value.triangle.base;
  }

  return 0;
}
</code></pre>
<p>The corresponding Rust program requires defining separate types for each variant
of the <code>Shape</code> enum so that the fact that all of the value are of a given type
can be expressed in the type system by having an array of <code>Triangle</code> instead of
an array of <code>Shape</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle { width: f64, height: f64 }
struct  Triangle { base: f64, height: f64 }

enum Shape {
    Rectangle(Rectangle),
    Triangle(Triangle),
}


fn get_shapes() -&gt; Vec&lt;Shape&gt; {
    vec![
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Rectangle(Rectangle {
            width: 1.0,
            height: 1.0,
        }),
    ]
}

fn main() {
    let shapes = get_shapes();

    // Create an iterator that only sees the triangles.
    let triangles = shapes
        .iter()
        // Keep only the triangles
        .filter_map(|shape| match shape {
            Shape::Triangle(t) =&gt; Some(t),
            _ =&gt; None,
        });

    let mut total_base = 0.0;
    for triangle in triangles {
        total_base += triangle.base;
    }
}</code></pre></pre>
<p>This kind of use is common enough that the variants are often designed to have
their own types from the start.</p>
<h2 id="stdvariant-since-c17"><a class="header" href="#stdvariant-since-c17"><code>std::variant</code> (since C++17)</a></h2>
<p>In more modern C++, <code>std::variant</code> is more similar in usage to Rust.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        } else if constexpr (std::is_same_v&lt;T, Triangle&gt;) {
          return 0.5 * arg.base * arg.height;
        }
      },
      shape);
}
</code></pre>
<p>Because Rust doesn't depend on templates for this language feature, error
messages when a variant is missed or when a new variant is added are easier to
read, which removes one of the barriers to using tagged unions more frequently.
Compare the errors in C++ (using gcc) and Rust when the <code>Triangle</code> case is
omitted.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        }
      },
      shape);
}
</code></pre>
<pre><code class="language-text">$ g++ -o example example.cc
example.cc: In instantiation of ‘area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt; [with auto:27 = const Triangle&amp;]’:
/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from ‘constexpr _Res std::__invoke_impl(__invoke_other, _Fn&amp;&amp;, _Args&amp;&amp; ...) [with _Res = double; _Fn = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}]’
   61 |     { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from ‘constexpr typename std::__invoke_result&lt;_Functor, _ArgTypes&gt;::type std::__invoke(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}; typename __invoke_result&lt;_Functor, _ArgTypes&gt;::type = double]’
   96 |       return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   97 |                                         std::forward&lt;_Args&gt;(__args)...);
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1060:24:   required from ‘static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl&lt;std::__detail::__variant::_Multi_array&lt;_Result_type (*)(_Visitor, _Variants ...)&gt;, std::integer_sequence&lt;long unsigned int, __indices ...&gt; &gt;::__visit_invoke(_Visitor&amp;&amp;, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;&amp;&amp;; _Variants = {const std::variant&lt;Rectangle, Triangle&gt;&amp;}; long unsigned int ...__indices = {1}]’
 1060 |           return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),
      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1061 |               __element_by_index_or_cookie&lt;__indices&gt;(
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1062 |                 std::forward&lt;_Variants&gt;(__vars))...);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1820:5:   required from ‘constexpr decltype(auto) std::__do_visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Result_type = __detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}]’
 1820 |                   _GLIBCXX_VISIT_CASE(1)
      |                   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1882:34:   required from ‘constexpr std::__detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; std::visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}; __detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; = double]’
 1882 |             return std::__do_visit&lt;_Tag&gt;(
      |                    ~~~~~~~~~~~~~~~~~~~~~^
 1883 |               std::forward&lt;_Visitor&gt;(__visitor),
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1884 |               static_cast&lt;_Vp&gt;(__variants)...);
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
example.cc:17:20:   required from here
   17 |   return std::visit(
      |          ~~~~~~~~~~^
   18 |       [](auto &amp;&amp;arg) -&gt; double {
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 |         using T = std::decay_t&lt;decltype(arg)&gt;;
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 |         if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 |           return arg.width * arg.height;
      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   22 |         }
      |         ~
   23 |       },
      |       ~~
   24 |       shape);
      |       ~~~~~~
example.cc:23:7: error: no return statement in ‘constexpr’ function returning non-void
   23 |       },
      |       ^
example.cc: In lambda function:
example.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<pre><code class="language-rust ignore">enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
        }
    }
}</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `&amp;Shape::Triangle { .. }` not covered
 --&gt; example.rs:8:15
  |
8 |         match self {
  |               ^^^^ pattern `&amp;Shape::Triangle { .. }` not covered
  |
note: `Shape` defined here
 --&gt; example.rs:1:6
  |
1 | enum Shape {
  |      ^^^^^
2 |     Rectangle { width: f64, height: f64 },
3 |     Triangle { base: f64, height: f64 },
  |     -------- not covered
  = note: the matched value is of type `&amp;Shape`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
9 ~             Shape::Rectangle { width, height } =&gt; width * height,
10~             &amp;Shape::Triangle { .. } =&gt; todo!(),
  |

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0004`.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes-interfaces-and-dynamic-dispatch"><a class="header" href="#abstract-classes-interfaces-and-dynamic-dispatch">Abstract classes, interfaces, and dynamic dispatch</a></h1>
<p>In C++ when an interface will be used with dynamic dispatch to resolve invoked
methods, the interface is defined using an abstract class. Types that implement
the interface inherit from the abstract class. In Rust the interface is given by
a <em>trait</em>, which is then implemented for the types that support that trait.
Programs can then be written over <em>trait objects</em> that use that trait as their
base type.</p>
<p>The following example defines an interface, two implementations of that
interface, and a function that takes an argument that satisfies the interface.
In C++ the interface is defined with an abstract class where all of the methods
are pure virtual methods, and in Rust the interface is defined with a trait. In
both languages, the function (<code>printArea</code> in C++ and <code>print_area</code> in Rust)
invokes a method using dynamic dispatch.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

// Define an abstract class for an interface
struct Shape {
  Shape() = default;
  virtual ~Shape() = default;
  virtual double area() = 0;
};

// Implement the interface for a concrete class
struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() override {
    return 0.5 * base * height;
  }
};

// Implement the interface for a concrete class
struct Rectangle : Shape {
  double width;
  double height;

  Rectangle(double width, double height)
      : width(width), height(height) {}

  double area() override {
    return width * height;
  }
};

// Use an object via a reference to the interface
void printArea(Shape &amp;shape) {
  std::cout &lt;&lt; shape.area() &lt;&lt; std::endl;
}

int main() {
  Triangle triangle = Triangle{1.0, 1.0};

  printArea(triangle);

  // Use an object via an owned pointer to the
  // interface
  std::unique_ptr&lt;Shape&gt; shape;
  if (true) {
    shape = std::make_unique&lt;Rectangle&gt;(1.0, 1.0);
  } else {
    shape = std::make_unique&lt;Triangle&gt;(
        std::move(triangle));
  }

  // Convert to a reference to the interface
  printArea(*shape);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define an interface
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }
}

// Use a value via a reference to the interface
fn print_area(shape: &amp;dyn Shape) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    print_area(&amp;triangle);

    // Use a value via an owned pointer to the
    // interface
    let shape: Box&lt;dyn Shape&gt; = if true {
        Box::new(Rectangle {
            width: 1.0,
            height: 1.0,
        })
    } else {
        Box::new(triangle)
    };

    // Convert to a reference to the interface
    print_area(shape.as_ref());
}</code></pre></pre>
</div>
<p>Rust does not have an equivalent for the virtual destructor declaration because
in Rust every vtable includes the drop behavior (whether given by a user defined
<code>Drop</code> implementation or not) required for the value.</p>
<h2 id="vtables-and-rust-trait-object-types"><a class="header" href="#vtables-and-rust-trait-object-types">Vtables and Rust trait object types</a></h2>
<p>In C++ dynamic dispatch against an interface defined by an abstract base class
is achieved by accessing the object through a pointer or reference. To make this
possible, objects include a vtable.</p>
<p>Rust requires the same kind of indirection. The type <code>dyn Shape</code> in the above
example is the type of a trait object for the <code>Shape</code> trait. A trait object
includes a vtable along with the underlying value.</p>
<p>In C++ all objects whose class inheriting from a class with a virtual method
have a vtable in their representation, whether dynamic dispatch is used or not.
Pointers or references to objects are the same size as pointers to objects
without virtual methods, but every object includes its vtable.</p>
<p>In Rust, vtables are present only when values are represented as trait objects.
The reference to the trait object is twice the size as a normal reference since
it includes both the pointer to the value and the pointer to the vtable. In the
Rust example above, the local variable <code>triangle</code> in <code>main</code> does not have a
vtable in its representation, but when the reference to it is converted to a
reference to a trait object (so that it can be passed to <code>print_area</code>), that
does include a pointer to the vtable.</p>
<p>Additionally, just as abstract classes in C++ cannot be used as the type of a
local variable, the type of a parameter of a function, or the type of a return
value of a function, trait object types in Rust cannot be used in corresponding
contexts. In Rust, this is enforced by the type <code>dyn Shape</code> not implementing the
<code>Sized</code> marker trait, preventing it from being used in contexts that require
knowing the size of a type statically.</p>
<p>The following example shows some places where a trait object type can and cannot
be used due to not implementing <code>Sized</code>. The uses forbidden in Rust would also
be forbidden in C++ because <code>Shape</code> is an abstract class.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // Local variables must have a known size.
    // let v: dyn Shape = Triangle { base: 1.0, height: 1.0 };

    // References always have a known size.
    let shape: &amp;dyn Shape = &amp;Triangle {
        base: 1.0,
        height: 1.0,
    };
    // Boxes also always have a known size.
    let boxed_shape: Box&lt;dyn Shape&gt; = Box::new(Triangle {
        base: 1.0,
        height: 1.0,
    });

    // Types like Option&lt;T&gt; the value of type T directly, and so also need to
    // know the size of T.
    // let v: Option&lt;dyn Shape&gt; = Some(Triangle { base: 1.0, height: 1.0 });
}

// Parameter types must have a known size.
// fn print_area(shape: dyn Shape) { }
fn print_area(shape: &amp;dyn Shape) {}</code></pre></pre>
<p>The decision to include the vtable in the reference instead of in the value is
one part of what makes it reasonable to use traits both for polymorphism via
dynamic dispatch and for <a href="idioms/data_modeling//idioms/data_modeling/concepts.html">polymorphism via static dispatch, where one would use
concepts in C++</a>.</p>
<h2 id="limitations-of-trait-objects-in-rust"><a class="header" href="#limitations-of-trait-objects-in-rust">Limitations of trait objects in Rust</a></h2>
<p>In Rust, not all traits can be used as the base trait for trait objects. The
most commonly encountered restriction is that traits that require knowledge of
the object's size via a <code>Sized</code> supertrait are not <code>dyn</code>-compatible. There are
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">additional
restrictions</a>.</p>
<h2 id="trait-objects-and-lifetimes"><a class="header" href="#trait-objects-and-lifetimes">Trait objects and lifetimes</a></h2>
<p>Objects which are used with dynamic dispatch may contain pointers or references
to other objects. In C++ the lifetimes of those references must be tracked
manually by the programmer.</p>
<p>Rust checks the bounds on the lifetimes of references that the trait objects may
contain. If the bounds are not given explicitly, they are determined according
to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#r-lifetime-elision.trait-object">lifetime elision
rules</a>.
The bound is part of the type of the trait object.</p>
<p>Usually the elision rules pick the correct lifetime bound. Sometimes, the rules
result in surprising error messages from the compiler. In those situations or
when the compiler cannot determine which lifetime bound to assign, the bound may
be given manually. The following example shows explicitly what the inferred
lifetimes are for a structure storing a trait object and for the <code>print_area</code>
function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Scaled {
    scale: f64,
    // 'static is the lifetime that would be inferred by the lifetime elision
    // rule [lifetime-elision.trait-object.default].
    shape: Box&lt;dyn Shape + 'static&gt;,
}

impl Shape for Scaled {
    fn area(&amp;self) -&gt; f64 {
        self.scale * self.shape.area()
    }
}

// These are the lifetimes that would be inferred by the lifetime elision rule
// [lifetime-elision.function.implicit-lifetime-parameters] for the reference
// and [lifetime-elision.trait-object.containing-type-unique] for the trait
// bound.
fn print_area&lt;'a&gt;(shape: &amp;'a (dyn Shape + 'a)) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };
    print_area(&amp;triangle);

    let scaled_triangle = Scaled {
        scale: 2.0,
        shape: Box::new(triangle),
    };
    print_area(&amp;scaled_triangle);
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;pure_virtual_classes&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;507115c6-4ed1-4a16-9f40-f5a01d3830a8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\ntrait Iterable {\n  type Item;\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nstruct Iterable&lt;Item&gt; {}\nimpl&lt;Item&gt; Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\nstruct Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\ntrait Iterable {\n  type Item;\n  fn new() -&gt; Self;\n  fn drop(self);\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;],&quot;prompt&quot;:&quot;For the following C++ abstract virtual class, which of the following snippets represents the most idiomatic translation into Rust?\n```cpp\ntemplate&lt;typename Item&gt;\nstruct Iterable {\n  Iterable() {};\n  virtual ~Iterable() {};\n  virtual Item* next() = 0;\n};\n```\n&quot;}}]}"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-interfaces-and-static-dispatch"><a class="header" href="#concepts-interfaces-and-static-dispatch">Concepts, interfaces, and static dispatch</a></h1>
<p>In C++ static dispatch over an interface is achieved by implementing a template
function or template method that interacts with the type using some expected
interface.</p>
<p>The template function <code>twiceArea</code> in the example below makes use of an <code>area()</code>
method on the template type parameter.</p>
<p>To achieve the same goal in Rust involves defining a trait (<code>Shape</code>) with the
desired method (<code>twice_area</code>) and using the trait as a bound on the type
parameter for the generic function.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() {
    return 0.5 * base * height;
  }
};

// Generic function using interface
template &lt;class T&gt;
double twiceArea(T &amp;shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Interface that generic function will use
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implementation of interface for type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

// Generic function using interface
fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    println!("{}", twice_area(&amp;triangle));
}</code></pre></pre>
</div>
<p>Note that in the Rust example, the definition of the trait and the struct have
not changed from the example in the chapter on <a href="idioms/data_modeling//idioms/data_modeling/pure_virtual_classes.html">virtual methods and dynamic
dispatch</a>. Even so, this example
does use static dispatch.</p>
<p>The difference between Rust and C++ in the above examples arises from Rust being
nominally typed (types must opt in to supporting a specific interface, merely
having the right methods isn't enough) and C++'s template meta-programming
enabling a kind of structural or duck typing (types only need to have the
methods actually used, and there is no need to explicitly opt in to supporting
an interface).</p>
<h2 id="templates-vs-generic-functions"><a class="header" href="#templates-vs-generic-functions">Templates vs generic functions</a></h2>
<p>The reason why Rust is nominally typed instead of structurally typed has to do
with the difference between C++ templates and Rust generic functions. In
particular, C++ templates are only type checked after all of the template
arguments are provided and they are fully expanded, while Rust generic functions
are type checked independently of the type arguments.</p>
<p>Since the functions are checked before the type arguments are known, the methods
and functions that can be applied to values of those types also need to be known
before the type arguments are known.</p>
<p>This point in the programming language design space favors simplicity of
reasoning about these functions over the flexibility that comes from the
template programming approach. This becomes especially valuable when writing
libraries that both provide generic functions and that use generic functions,
for which a C++ compiler can give many fewer static guarantees, since it would
not be possible to test all possible instantiations.</p>
<p>In both C++ and Rust, however, multiple implementations are generated by the
compiler in order to achieve static dispatch.</p>
<h2 id="c-concepts"><a class="header" href="#c-concepts">C++ concepts</a></h2>
<p>Rust's approach to static dispatch over an interface can be partially (but only
partially) modeled with a strict application of C++ concepts.</p>
<p>The usual way to apply concepts is still structural and does not model Rust's
approach: it only requires that a method with specific properties be present on
the type.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

template &lt;typename T&gt;
concept shape = requires(T t) {
  { t.area() } -&gt; std::same_as&lt;double&gt;;
};

template &lt;shape T&gt;
double twiceArea(T shape) {
  return shape.area() * 2;
}
</code></pre>
<p>A closer equivalent to the above Rust program in C++ is to use a combination of
pure virtual classes and concepts.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  double area() override {
    return 0.5 * base * height;
  }
};

template &lt;shape T&gt;
double twiceArea(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>This is still not the same, however, because the concept only creates a
requirement on the use of the template, not on the use of values of type <code>T</code>
within the template. In Rust, the trait bound constrains both. So the following
still compiles in C++.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

template &lt;shape T&gt;
double twiceArea(T shape) {
  // note the call to a method not defined in Shape
  return shape.volume() * 2;
}
</code></pre>
<p>However, the equivalent does not compile in Rust and instead produces an error.</p>
<pre><code class="language-rust ignore">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    // note the call to a method not defined in Shape
    2.0 * shape.volume()
}</code></pre>
<pre><code class="language-text">error[E0599]: no method named `volume` found for reference `&amp;T` in the current scope
 --&gt; example.rs:7:17
  |
7 |     2.0 * shape.volume()
  |                 ^^^^^^ method not found in `&amp;T`
</code></pre>
<p>These additional static checks mean that in many situations where C++ templates
would be useful but hard to implement correctly, Rust generics are freely used.</p>
<h2 id="required-traits-and-ergonomics"><a class="header" href="#required-traits-and-ergonomics">Required traits and ergonomics</a></h2>
<p>In the above examples, the function requiring a trait was defined like the following.</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
<p>This is a commonly used shorthand for the following:</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T&gt;(shape: &amp;T) -&gt; f64
where
    T: Shape,
{
    2.0 * shape.area()
}</code></pre>
<p>The more verbose form is preferred used when there are many type parameters or
those type parameters must implement many traits.</p>
<h2 id="generics-and-lifetimes"><a class="header" href="#generics-and-lifetimes">Generics and lifetimes</a></h2>
<p>When defining a template in C++ that makes use of a type template parameter, the
lifetimes of references stored within objects of that type must be tracked
manually by the programmer.</p>
<p>Rust checks the bounds on lifetimes of references contained within type
parameters. <a href="idioms/data_modeling//idioms/data_modeling/abstract_classes.html#trait-objects-and-lifetimes">Just as with trait object
types</a>,
these bounds are usually inferred according to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision
rules</a>. When they
cannot be inferred, or they are inferred incorrectly, the bounds can be declared
manually.</p>
<p>In the following example, the bounds have to be given manually because the
inferred bounds are incorrect.</p>
<pre><code class="language-rust ignore">trait Shape {}

fn store&lt;S: Shape&gt;(x: S, data: &amp;mut Box&lt;dyn Shape&gt;) {
    *data = Box::new(x);
}</code></pre>
<pre><code class="language-text">error[E0310]: the parameter type `S` may not live long enough
 --&gt; example.rs:7:5
  |
7 |     *data = Box::new(x);
  |     ^^^^^
  |     |
  |     the parameter type `S` must be valid for the static lifetime...
  |     ...so that the type `S` will meet its required lifetime bounds
  |
</code></pre>
<p>The error message becomes clearer when the inferred lifetime bounds are made
explicit. With the given type for <code>store</code>, the argument for <code>x</code> could be
something that has a lifetime that does not last as long as the lifetimes in the
contents in the box.</p>
<pre><code class="language-rust ignore"><span class="boring">trait Shape {}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {}
</span><span class="boring">
</span>// The type parameter S is assigned no lifetime bound.
fn store&lt;'a, S: Shape&gt;(
    x: S,
    // The reference is assigned a fresh lifetime by rule
    // [lifetime-elision.function.implicit-lifetime-parameters].
    //
    // The trait object is assigned 'static by rule
    // [lifetime-elision.trait-object.default] and
    // [lifetime-elision.trait-object.innermost-type].
    data: &amp;'a mut Box&lt;dyn Shape + 'static&gt;,
) {
    *data = Box::new(x);
}

// An example of how the implementation of store could be misused with
// the given type.
fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 2.0,
    };
    let mut b: Box&lt;dyn Shape&gt; = Box::new(triangle);
    {
        let short_lived_triangle = Triangle {
            base: 5.0,
            height: 10.0,
        };
        store(short_lived_triangle, &amp;mut b);
    }
    // Here b contains a dangling reference.
}</code></pre>
<p>For this specific case, the most general solution is to define a new lifetime
parameter to bound both <code>S</code> and <code>dyn Shape</code>. The type parameter for the
reference can be elided, because it will be assigned a fresh lifetime parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape {}

// Note the common bound
// -----------------here-\
// ----------------------|---------------------------and here-\
//                       v                                    v
fn store&lt;'s, S: Shape + 's&gt;(x: S, data: &amp;mut Box&lt;dyn Shape + 's&gt;) {
    *data = Box::new(x);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance-and-implementation-reuse"><a class="header" href="#inheritance-and-implementation-reuse">Inheritance and implementation reuse</a></h1>
<p>Rust does not have inheritance and so the primary means of reuse of
implementations in Rust are composition, aggregation, and <a href="idioms/data_modeling/TODO">generics</a>.</p>
<p>However, Rust traits do have support for default methods which resemble one
simple case of using inheritance for reuse of implementations. For example, in
the following example two virtual methods are used to support a method whose
implementation is provided by the abstract class.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Device {
public:
    virtual void powerOn() = 0;
    virtual void powerOff() = 0;

    virtual void resetDevice() {
        std::cout &lt;&lt; "Resetting device..." &lt;&lt; std::endl;
        powerOff();
        powerOn();
    }

    virtual ~Device() {}
};

class Printer : public Device {
    bool powered = false;
public:
    void powerOn() override {
        this.powered = true;
        std::cout &lt;&lt; "Printer is powered on." &lt;&lt; std::endl;
    }

    void powerOff() override {
        this.powered = false;
        std::cout &lt;&lt; "Printer is powered off." &lt;&lt; std::endl;
    }
};

int main() {
    Printer myPrinter;
    myPrinter.resetDevice();
    return 0;
}
</code></pre>
<p>In practice, the <code>resetDevice()</code> method in the <code>Device</code> class might be made
non-virtual in C++ if it is not expected that it will be overridden. In order to
make it align with the Rust example, we have made it virtual here, since the
vtable for <a href="idioms/data_modeling/./idioms/data_modeling/pure_virtual_classes.html">trait objects</a> in
Rust includes all methods defined by the trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Device {
    fn power_on(&amp;mut self);
    fn power_off(&amp;mut self);

    fn reset_device(&amp;mut self) {
        println!("Resetting device...");
        self.power_on();
        self.power_off();
    }
}

struct Printer {
    powered: bool,
}

impl Device for Printer {
    fn power_on(&amp;mut self) {
        self.powered = true;
        println!("Printer is powered on");
    }

    fn power_off(&amp;mut self) {
        self.powered = false;
        println!("Printer is powered off");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust traits are more differ from abstract classes in a few ways. For example,
Rust traits cannot define data members and cannot define private or protected
methods. This limits the use of traits to implement patterns such as the
<a href="idioms/data_modeling/TODO">template method pattern</a>.</p>
<p>Traits can, however, inherit from each other, including multiple inheritance. As
in modern C++, inheritance hierarchies in Rust tend to be shallow. In situations
with complex multiple inheritance, however, the diamond problem cannot arise in
Rust because traits cannot override other traits implementations. Therefore, all
paths to a common parent trait resolve to the same implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-classes-functions-and-methods"><a class="header" href="#template-classes-functions-and-methods">Template classes, functions, and methods</a></h1>
<p>The most common uses of templates in C++ are to define classes, methods, traits,
or functions that work for any type, or for any type that provides certain
methods. This use case is common in the STL for container classes (such as
<code>&lt;vector&gt;</code>) and for the algorithms library (<code>&lt;algorithm&gt;</code>).</p>
<p>The following example defines a template for a directed graph represented as an
adjacency list, where the graph is generic in the type of the labels on the
nodes. Though the example shows a template class, the same comparisons with Rust
apply to template methods and template functions.</p>
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
private:
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  std::vector&lt;Label&gt; nodeLabels;

public:
  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(label);
    return numNodes() - 1;
  }

  void addEdge(size_t from, size_t to) {
    if (from &gt;= numNodes() || to &gt;= numNodes()) {
      throw std::invalid_argument("Node index out of range");
    }
    adjacencies[from].push_back(to);
  }

  size_t numNodes() const { return adjacencies.size(); }
};
</code></pre>
<p>The same can be achieved in Rust using generic types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DirectedGraph&lt;Label&gt; {
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    node_labels: Vec&lt;Label&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }

    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
            Err("Node not in graph.")
        } else {
            self.adjacencies[from].push(to);
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this use case so far, there are few practical differences between using C++
template to define a class and using and Rust's generics to define a struct.
Whenever one would use a template that takes a <code>typename</code> or <code>class</code> parameter
in C++, one can instead take a type parameter in Rust.</p>
<h2 id="operations-on-the-parameterized-type"><a class="header" href="#operations-on-the-parameterized-type">Operations on the parameterized type</a></h2>
<p>The differences become more apparent when one attempts to perform operations on
the values. For example, adding a method to get the smallest node in the graph.</p>
<pre><code class="language-cpp">#include &lt;optional&gt;
//...

template &lt;typename Label&gt;
class DirectedGraph {
  // ...

public:
  std::optional&lt;size_t&gt; smallestNode() {
    if (nodeLabels.empty()) {
      return std::nullopt;
    }
    Label &amp;least = nodeLabels[0];
    size_t index = 0;

    for (int i = 1; i &lt; nodeLabels.size(); i++) {
      if (least &gt; nodeLabels[i]) {
        least = nodeLabels[i];
        index = i;
      }
    }
    return std::optional(index);
  }
}
</code></pre>
<p>In Rust, the same method would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    // Matches the C++, but is not the idomatic implementation!
    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        if self.node_labels.is_empty() {
            None
        } else {
            let mut least = &amp;self.node_labels[0];
            let mut index = 0;
            for i in 1..self.node_labels.len() {
                if *least &gt; self.node_labels[i] {
                    least = &amp;self.node_labels[i];
                    index = i;
                }
            }
            Some(index)
        }
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The major difference between these implementations is that in the C++ version
<code>operator&gt;</code> is used on the values without knowing whether the operator is
defined for the type, while in the Rust version, there is a constraint requiring
that the <code>Label</code> type implement the <code>Ord</code> trait. (See the chapter on <a href="idioms/data_modeling/./idioms/data_modeling/concepts.html">concepts,
interfaces, and static dispatch</a> for more
details on Rust traits and how they relate to C++ concepts.)</p>
<p>Unlike C++ templates, generic definitions in Rust are type checked at the point
of definition rather than at the point of use. This means that for operations to
be used on values with the type of a type parameter the parameter has to be
constrained to types that implement some trait. As can be seen in the above
example, much like with C++ concepts, the constraint can be required for
individual methods rather than for the whole generic class.</p>
<p>Best practice in Rust to put the trait bounds on the specific things that
require the bounds, in order to make the overall use of the types more flexible.</p>
<p>As an aside, a more idiomatic implementation of <code>smallest_node</code> is</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(&amp;mut self, label: Label) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(&amp;mut self, from: usize, to: usize) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes() || to &gt; self.num_nodes() {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
where
    Label: Ord,
{
    self.node_labels
        .iter()
        .enumerate()
        .map(|(i, l)| (l, i))
        .min()
        .map(|(_, i)| i)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>TODO explain why this is more idiomatic?</p>
<h2 id="constexpr-template-parameters"><a class="header" href="#constexpr-template-parameters"><code>constexpr</code> template parameters</a></h2>
<p>Rust also supports the equivalent of constexpr template parameters. For example,
one can define a generic function that returns an array consecutive integers
starting from a specific value and whose size is determined at compile time.</p>
<pre><code class="language-cpp">#include &lt;array&gt;

template &lt;constexpr N&gt;
std::array&lt;int, N&gt; makeSequentialArray(int start) {
    array&lt;int, N&gt; arr;
    for (size_t i = 0; i &lt; N; i++) {
        arr[i] = start + i;
    }
}
</code></pre>
<p>The corresponding idiomatic Rust function uses the helper <code>std::array::from_fn</code>
to construct the array. <code>from_fn</code> itself takes as type parameters the element
type and the constant. Those arguments are elided because Rust can infer them,
because both are part of the type of the produced array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_sequential_array&lt;const N: usize&gt;(start: i32) -&gt; [i32; N] {
    std::array::from_fn(|i| start + i as i32)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-self-type"><a class="header" href="#rusts-self-type">Rust's <code>Self</code> type</a></h2>
<p>Within a class definition, there is a <code>Self</code> type that is in scope. The <code>Self</code>
type is the type of the class being defined with all of the generic type
parameters filled in. It can be useful to refer to this type especially in cases
where there are many parameters that would otherwise have to be listed out.</p>
<p>The <code>Self</code> type can also be used when implementing generic traits to refer to
the concrete implementing type. Because Rust does not have inheritance between
concrete types and does not have method overriding, this is sufficient to avoid
the need to pass the implementing type as a type parameter.</p>
<p>TODO example</p>
<h2 id="a-note-on-type-checking-and-type-errors"><a class="header" href="#a-note-on-type-checking-and-type-errors">A note on type checking and type errors</a></h2>
<p>The checking of generic types at the point of definition rather than at the
point of template expansion impacts when errors are detected and how they are
reported. Some of this difference cannot be achieved by consistently using C++
concepts to declare the operations required.</p>
<p>For example, one might accidentally make the <code>nodeLabels</code> member a vector of
integers instead of a vector of the label parameter. If all of the test cases
for the graph used label types that were convertible to integers, the error
would not be detected.</p>
<p>A similar Rust program fails to compile, even without a function that
instantiates the generic structure with a concrete type.</p>
<h2 id="lifetimes-parameters"><a class="header" href="#lifetimes-parameters">Lifetimes parameters</a></h2>
<p>Rust's generics are also used for classes, methods, traits, and functions that
are generic in the lifetimes of the references they manipulate. Unlike other
type parameters, the using a function with different lifetimes does not cause
additional copies of the function to be generated in the compiled code, because
lifetimes do not impact the runtime representation.</p>
<p>TODO example with and without lifetime elision.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>TODO talk about lifetime bounds on type parameters.</p>
<p>TODO example of lifetime bounds on type parameters</p>
<p>The lifetime elision rules do not always follow the initial intuition one might
have. If a program produces surprising lifetime errors and elided lifetimes are
involved, it may be helpful to review the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision
rules</a>.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>One significant difference between C++ templates and Rust generics is that C++
templates are actually a more general purpose macro language, supporting things
like conditional compilation. Rust supports these use cases with its macro
system, which differs significantly from C++. The most common use of the macro
system, conditional compilation, is provided by <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">the <code>cfg</code> attribute and <code>cfg!</code>
macro</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-specialization"><a class="header" href="#template-specialization">Template specialization</a></h1>
<p>Template specialization in C++ makes it possible for a template entity to have
different implementations for different parameters. Most STL implementations
make use of this to, for example, provide a <a href="https://en.cppreference.com/w/cpp/container/vector_bool">space-efficient representation of
<code>std::vector&lt;bool&gt;</code></a>.</p>
<p>In Rust it is not possible to specialize a generic implementation in this way.
This is because unlike C++ templates, Rust's generics are not a mechanism for
metaprogramming.</p>
<p>Instead it is more common in Rust to define traits for interfaces and to
implement generic functions over those interfaces, enabling clients to select
their choice of representation by using a different concrete type. This is more
practical to do in Rust than in C++ because generics not being a metaprogramming
facility means that generic entities can be type checked locally, making them
easier to define.</p>
<p>Additionally, because generic functions can only interact with generic values in
ways defined by the trait bounds, it is easier to test generic implementations.
In particular, code testing a generic implementation only has to consider the
possible behaviors of the given trait.</p>
<p>For a comparison, consider the following Rust program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, T: Ord&gt;(x: &amp;'a T, y: &amp;'a T) -&gt; &amp;'a T {
    if x &gt; y {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <em>parametricity properties</em> of the program mean that (assuming safe Rust)
from the type alone one can tell that if the function returns, it must return
exactly one of <code>x</code> or <code>y</code>. This is because the trait bound <code>Ord</code> doesn't give
any way to construct new values of type <code>T</code>, and the use of references doesn't
give any way for the function to store one of <code>x</code> or <code>y</code> from an earlier call to
return in a later call.</p>
<p>Compare this with a C++ function with a similar signature:</p>
<pre><code class="language-cpp">template &lt;totally_ordered T&gt;
T max(const T &amp;x, const T &amp;y) {
  return (x &gt; y) ? x : y;
}

template &lt;&gt;
int max(const int &amp;x, const int &amp;y) {
  return (x &gt; y) ? x + 1 : y + 1;
}
</code></pre>
<p>In this case, a call to <code>max</code> with <code>int</code> as the template parameter will give a
distinctly different result than with any other parameter because of the
template specialization enabling the behavior of the function to vary based on
the type.</p>
<p>The trade-off is that specialized implementations are harder to use because they
must have different names, but that they are easier to use because it is easier
to write generic code while being confident about its correctness.</p>
<h2 id="niche-optimization"><a class="header" href="#niche-optimization">Niche optimization</a></h2>
<p>There are several cases where the Rust compiler will perform optimizations to
achieve more efficient representations. Those situations are all ones where the
efficiency gains do not otherwise change the observable behavior of the code.</p>
<p><a href="https://doc.rust-lang.org/std/option/index.html#representation">The most common case is with the <code>Option</code>
type</a>. When
<code>Option</code> is used with a type where the compiler can tell that there are unused
values, one f those unused values will be used to represent the <code>None</code> case, so
that <code>Option&lt;T&gt;</code> will not require an extra word of memory to indicate the
discriminant of the enum.</p>
<p>This optimization is applied to reference types (<code>&amp;</code> and <code>&amp;mut</code>), since
references cannot be null. It is also applied to <code>NonNull&lt;T&gt;</code>, which represents
a non-null pointer to a value of type <code>T</code>, and to <code>NonZeroU8</code> and other non-zero
integral types. The optimization for the reference case is what makes
<code>Option&lt;&amp;T&gt;</code> and <code>Option&lt;&amp;mut T&gt;</code> safer equivalents to using non-owning
observation pointers in C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-nullptr"><a class="header" href="#null-nullptr">Null (nullptr)</a></h1>
<p>This section covers idiomatic uses of <code>nullptr</code> in C++ and how to achieve the
same results in Rust.</p>
<p>Some uses of <code>nullptr</code> in C++ don't arise in the first place in Rust because of
other language differences. For example, <a href="idioms//idioms/null/moved_members.html">moved objects don't leave anything
behind that needs to be destroyed</a>. Therefore
there is no to use <code>nullptr</code> as a as placeholder for a moved pointer that can
have <code>delete</code> or <code>free</code> called on it.</p>
<p>Other uses are replaced by <code>Option</code>, which in safe Rust requires checking for
the empty case before accessing the contained value. This use is common enough
that <a href="https://doc.rust-lang.org/std/option/index.html#representation">Rust has an
optimization</a>
for when <code>Option</code> is used with a reference (<code>&amp;</code> or <code>&amp;mut ref</code>), <code>Box</code>
(equivalent of <code>unique_ptr</code>), and <code>NonNull</code> (a non-null raw pointer).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-length-arrays"><a class="header" href="#zero-length-arrays">Zero-length arrays</a></h1>
<p>In C++ codebases that are written in a C style or that make use of C libraries,
null pointers may be used to represent empty arrays. This is because there is
little practical difference between an array of size zero and a null pointer.</p>
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;cassert&gt;

int c_style_sum(std::size_t len, int arr[]) {
    int sum = 0;
    for (size_t i = 0; i &lt; len; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int sum = c_style_sum(0, nullptr);
    assert(sum == 0);
    return 0;
}
</code></pre>
<p>In Rust, arrays of arbitrary size are represented as
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html">slices</a>. These slices can
have zero length. Since <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Deref-for-Vec%3CT,+A%3E">Rust vectors are convertible to
slices</a>,
defining functions that work with slices enables them to be used with vectors as
well.</p>
<pre><pre class="playground"><code class="language-rust">fn sum_slice(arr: &amp;[i32]) -&gt; i32 {
    let mut sum = 0;
    for x in arr {
        sum += x;
    }
    sum
}

fn main() {
    let sum = sum_slice(&amp;[]);
    assert!(sum == 0);

    let sum2 = sum_slice(&amp;vec![]);
    assert!(sum2 == 0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentinel-values"><a class="header" href="#sentinel-values">Sentinel values</a></h1>
<p>Sentinel values are in-band value that indicates a special situation, such as
having reached the end of valid data in an iterator.</p>
<h2 id="nullptr"><a class="header" href="#nullptr"><code>nullptr</code></a></h2>
<p>Many designs in C++ borrow the convention from C of using a null pointer as a
sentinel value for a method that returns owned pointers. For example, a method
that parses a large structure may produce <code>std::nullptr</code> in the case of failure.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

class LargeStructure {
  int field;
  // many fields ...
};

std::unique_ptr&lt;LargeStructure&gt; parse(char *data, size_t len) {
  // ...

  // on failure
  return nullptr;
}
</code></pre>
<p>A similar situation in Rust would make use of the type
<code>Option&lt;Box&lt;LargeStructure&gt;&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LargeStructure {
    field: i32,
    // many fields ...
}

fn parse(data: &amp;[u8]) -&gt; Option&lt;Box&lt;LargeStructure&gt;&gt; {
    // ...

    // on failure
    None
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Box&lt;T&gt;</code> type has the same meaning as <code>std::unique_ptr&lt;T&gt;</code> in terms of being
an uniquely owned pointer to some <code>T</code> on the heap, but unlike <code>std::unique_ptr</code>,
it cannot be null. Rust's <code>Option&lt;T&gt;</code> is like <code>std::optional&lt;T&gt;</code> in C++, except
that it can be used with pointers and references. In <a href="idioms/null//idioms/data_modeling/template_specialization.html#niche-optimization">those cases (and in some
other
cases)</a> the
compiler optimizes the representation to be the same size as <code>Box&lt;T&gt;</code> by
leveraging the fact that <code>Box</code> cannot be null.</p>
<p>In Rust it is also common to pay the cost for the extra byte to use a return
type of <code>Result&lt;T, E&gt;</code> (which is akin to <code>std::expected</code> in C++23) in order to
make the reason for the failure available at runtime.</p>
<h2 id="integer-sentinels"><a class="header" href="#integer-sentinels">Integer sentinels</a></h2>
<p>When a possibly-failing function produces an integer, it is also common to use
an otherwise unused or unlikely integer value as a sentinel value, such as <code>0</code>
or <code>INT_MAX</code>.</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;

int gcd(int a, int b) {
  if (b == 0 || a == 0) {
    // returns 0 to indicate invalid input
    return 0;
  }

  while (b != 0) {
    int temp = b;
    b = a % b;
    a = temp;
  }
  return std::abs(a);
}
</code></pre>
<p>In Rust, the <code>Option</code> type is used for this purpose. In cases where the zero
value really is not possible to produce, as with the gcd algorithm above, the
type <code>NonZero&lt;T&gt;</code> can be used to indicate that fact. As with <code>Option&lt;Box&lt;T&gt;&gt;</code>,
the compiler optimizes the representation to make use of the unused value (in
this case <code>0</code>) to represent the <code>None</code> case to ensure that the representation of
<code>Option&lt;NonZero&lt;T&gt;&gt;</code> is the same as the representation of <code>Option&lt;T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::num::NonZero;

fn gcd(mut a: i32, mut b: i32) -&gt; Option&lt;NonZero&lt;i32&gt;&gt; {
    if a == 0 || b == 0 {
        return None;
    }

    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    // At this point, a is guaranteed to not be zero. The `Some` case from
    // `NonZer::new` has a different meaning than the `Some` returned from this
    // function, but here it happens to coincide.
    NonZero::new(a.abs())
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert!(gcd(5, 0) == None);
</span><span class="boring">    assert!(gcd(0, 5) == None);
</span><span class="boring">    assert!(gcd(5, 1) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(1, 5) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(2 * 2 * 3 * 5 * 7, 2 * 2 * 7 * 11) == NonZero::new(2 * 2 * 7));
</span><span class="boring">    assert!(gcd(2 * 2 * 7 * 11, 2 * 2 * 3 * 5 * 7) == NonZero::new(2 * 2 * 7));
</span><span class="boring">}</span></code></pre></pre>
<p>As an aside, it is also possible to avoid the redundant check for zero at the end, and
without using unsafe Rust, by preserving the non-zeroness property throughout
the algorithm.</p>
<pre><pre class="playground"><code class="language-rust">use std::num::NonZero;

fn gcd(x: i32, mut b: i32) -&gt; Option&lt;NonZero&lt;i32&gt;&gt; {
    if b == 0 {
        return None;
    }

    // a is guaranteed to be non-zero, so we record the fact in the type of a.
    let mut a = NonZero::new(x)?;

    while let Some(temp) = NonZero::new(b) {
        b = a.get() % b;
        a = temp;
    }
    Some(a.abs())
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert!(gcd(5, 0) == None);
</span><span class="boring">    assert!(gcd(0, 5) == None);
</span><span class="boring">    assert!(gcd(5, 1) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(1, 5) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(2 * 2 * 3 * 5 * 7, 2 * 2 * 7 * 11) == NonZero::new(2 * 2 * 7));
</span><span class="boring">    assert!(gcd(2 * 2 * 7 * 11, 2 * 2 * 3 * 5 * 7) == NonZero::new(2 * 2 * 7));
</span><span class="boring">}</span></code></pre></pre>
<h2 id="stdoptional"><a class="header" href="#stdoptional"><code>std::optional</code></a></h2>
<p>In situations where <code>std::optional</code> would be used as a sentinel value in C++,
<code>Option</code> can be used for the same purpose in Rust. The main difference between
the two is that safe Rust requires either explicitly checking whether the value is
<code>None</code>, while in C++ one can attempt to access the value without checking (at
the risk of undefined behavior).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moved-members"><a class="header" href="#moved-members">Moved members</a></h1>
<p>One common use of null pointers in modern C++ is as values for the members of
moved objects so that the destructor can still safely be called. E.g.,</p>
<pre><code class="language-cpp hidelines=#"><span class="boring"> #include &lt;cstdlib&gt;
</span><span class="boring"> #include &lt;cstring&gt;
</span><span class="boring">
</span>// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t*);
void copy_widget(widget_t* dst, widget_t* src);

// widget.cc
class Widget {
    widget_t* widget;
public:
<span class="boring">    Widget() : widget(alloc_widget()) {}
</span><span class="boring">
</span><span class="boring">    Widget(const Widget &amp;other) : widget(alloc_widget()) {
</span><span class="boring">        copy_widget(widget, other.widget);
</span><span class="boring">    }
</span><span class="boring">
</span>    Widget(Widget &amp;&amp;other) : widget(other.widget) {
        other.widget = nullptr;
    }

    ~Widget() {
        free_widget(widget);
    }
};
</code></pre>
<p>Rust's notion of moving objects does not involve leaving behind an object on
which a destructor will be called, and so this use of null does not have a
corresponding idiom. See the chapter on <a href="idioms/null//idioms/constructors/copy_and_move_constructors.html">copy and move
constructors</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h1>
<p>In C++ the encapsulation boundary is the class. In Rust the encapsulation
boundary is the module, which may contain several types along with standalone
functions. In larger projects, the crate may also act as an encapsulation
boundary.</p>
<p>This difference means that in Rust one is more likely to have multiple tightly
coupled types that work together which are defined in one module and
encapsulated as a whole.</p>
<p>This section provides ways to translate between C++ and Rust's notions of
encapsulation in terms of both mechanism and concept.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-files"><a class="header" href="#header-files">Header files</a></h1>
<p>One use of header files in C++ is to expose declarations that are defined in one
translation units to other translation units without requiring the duplication
of the declarations in multiple files. By convention, declarations that are not
included in the header are considered to be private to the defining translation
unit (though, to enforce this convention other mechanisms, such as <a href="idioms/encapsulation//idioms/encapsulation/anonymous_namespaces.html">anonymous
namespaces</a>, are required).</p>
<p>In contrast, Rust uses neither textually-included header files nor forward
declarations. Instead, Rust modules control visibility and linkage
simultaneously and expose public definitions for use by other modules.</p>
<div class="comparison">
<pre><code class="language-cpp">// person.h
class Person {
  std::string name;

public:
  Person(std::string name) : name(name) {}
  const std::string &amp;getName();
};

// person.cc
#include &lt;string&gt;
#include "person.h"

const std::string &amp;Person::getName() {
  return this-&gt;name;
}

// client.cc
#include &lt;string&gt;
#include "person.h"

int main() {
  Person p("Alice");
  const std::string &amp;name = p.getName();

  // ...
}
</code></pre>
<pre><code class="language-rust ignore">// person.rs
pub struct Person {
    name: String,
}

impl Person {
    pub fn new(name: String) -&gt; Person {
        Person { name }
    }

    pub fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

// client.rs
mod person;

use person::*;

fn main() {
    let p = Person::new("Alice".to_string());
    // doesn't compile, private field
    // let name = p.name;
    let name = p.name();

    //...
}</code></pre>
</div>
<p>In <code>person.rs</code>, the <code>Person</code> type is public but the <code>name</code> field is not. This
prevents both direct construction of values of the type (similar to private
members preventing aggregate initialization in C++) and prevents field access.
The static method <code>Person::new(String)</code> and method <code>Person::name()</code> are exposed
to clients of the module by the <code>pub</code> visibility declarations.</p>
<p>In the <code>client</code> module, the <code>mod</code> declaration defines the content of <code>person.rs</code>
as a submodule named <code>person</code>. The <code>use</code> declaration brings the contents of the
<code>person</code> module into scope.</p>
<h2 id="the-essence-of-the-difference"><a class="header" href="#the-essence-of-the-difference">The essence of the difference</a></h2>
<p>A C++ program is a collection of translation units. Header files are required to
make providing forward declarations of definitions from other translation units
manageable.</p>
<p>A Rust program is a tree of modules. Definitions in one module may access items
from other modules based on visibility declarations given in the definitions of
the module themselves.</p>
<h2 id="submodules-and-additional-visibility-features"><a class="header" href="#submodules-and-additional-visibility-features">Submodules and additional visibility features</a></h2>
<p>Modules and visibility declarations are more powerful than shown in the above
example. More details on how to use modules, <code>pub</code>, and <code>use</code> to achieve
encapsulation goals are described in the chapter on <a href="idioms/encapsulation/./idioms/encapsulation/private_members.html">private members and
friends</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-namespaces-and-static"><a class="header" href="#anonymous-namespaces-and-static">Anonymous namespaces and <code>static</code></a></h1>
<p>Anonymous namespaces in C++ are used to avoid symbol collisions between
different translation units. Such collisions violate <a href="https://timsong-cpp.github.io/cppwp/n4950/basic.def.odr#14">the one definition
rule</a> and result in
undefined behavior (which at best manifests as linking errors).</p>
<p>For example, without the use of anonymous namespaces, the following would result
in undefined behavior (and no linking error, due to the use of inline producing
weak symbols in the object files).</p>
<pre><code class="language-cpp">/// a.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}

/// b.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}
</code></pre>
<p>C++ static declarations are also used to achieve the same goal by making it so that
a declaration has internal linkage (and so is not visible outside of the
translation unit).</p>
<p>Rust avoids the linkage problem by controlling linkage and visibility
simultaneously, with declarations always also being definitions. Instead of
translation units, programs are structured in terms of
<a href="idioms/encapsulation//idioms/encapsulation/headers.html">modules</a>, which provide both namespaces and
visibility controls over definitions, enabling the Rust compiler to guarantee
that symbol collision issues cannot happen.</p>
<p>The following Rust program achieves the same goal as the C++ program above, in
terms of avoiding the collision of the two functions while making them available
for use within the defining files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.rs
<span class="boring">mod a {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span>
// b.rs
<span class="boring">mod b {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Additionally,</p>
<ol>
<li>Unlike C++ namespaces, Rust modules (which provide namespacing as well as
visibility controls) can only be defined once, and this is checked by the
compiler.</li>
<li>Each file <a href="https://doc.rust-lang.org/stable/book/ch07-05-separating-modules-into-different-files.html">defines a module which has to be explicitly included in the module
hierarchy</a>.</li>
<li>Modules from Rust crates (libraries) are always qualified with some root
module name, so they cannot conflict. If they would conflict, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">the root
module name must be replaced with some user-chosen
name</a>.</li>
</ol>
<h2 id="caveats-about-c-interoperability"><a class="header" href="#caveats-about-c-interoperability">Caveats about C interoperability</a></h2>
<p>When using libraries not managed by Rust, such as C or C++ static or dynamic
libraries or when producing Rust static or dynamic libraries to be used by C or
C++ programs, the usual problems can occur if there are symbol collisions in the
object files.</p>
<p>Additionally, using
<a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a>
in Rust to bypass name mangling in order to produce functions that can be easily
referred to from C or C++ can cause undefined behavior due to name collision
during linking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-members-and-friends"><a class="header" href="#private-members-and-friends">Private members and friends</a></h1>
<h2 id="private-members"><a class="header" href="#private-members">Private members</a></h2>
<p>In C++ the unit of encapsulation is the class, and so visibility controls access
to members at the class boundary. For example,</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
  int age;

public:
  std::string name;

  Person(std::string name, int age) : name(name), age(age) {}
};

int main() {
  Person alice("Alice", 42);
  std::cout &lt;&lt; alice.name &lt;&lt; std::endl;
  // std::cout &lt;&lt; alice.age &lt;&lt; std::endl; // &lt;-- compilation error
}
</code></pre>
<p>In Rust the module is the unit of encapsulation, so visibility controls access
to members at the module boundary.</p>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        age: i32,
    }

    impl Person {
        pub fn new(name: String, age: i32) -&gt; Person {
            Person { name, age }
        }
    }

    fn example() {
        let alice = Person::new("Alice".to_string(), 42);
        println!("{}", alice.name);
        println!("{}", alice.age); // &lt;-- the private field is visible here
    }
}

use person::Person;

fn main() {
    let alice = Person::new("Alice".to_string(), 42);
    println!("{}", alice.name);
    // println!("{}", alice.age); // &lt;-- compilation error
}</code></pre></pre>
<p>Notably in this example, the <a href="idioms/encapsulation//idioms/encapsulation/private_constructors.html">constructor for <code>Person</code> is
private</a> because one of the
fields is private.</p>
<h2 id="friends"><a class="header" href="#friends">Friends</a></h2>
<p>Because encapsulation is at the module level in Rust, associated methods for
types can access internals of other types defined in the same module. This
subsumes most uses of the C++ <code>friend</code> declaration.</p>
<p>For example, defining a binary tree in C++ requires that the class representing
the nodes of the tree declare the main binary tree class as a friend in order
for it to access internal methods while keeping them private from other uses.
This would be required even if the <code>TreeNode</code> class were defined as an inner
class of <code>BinaryTree</code>.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

class BinaryTree;

class TreeNode {
  friend class BinaryTree;

  int value;
  std::unique_ptr&lt;TreeNode&gt; left;
  std::unique_ptr&lt;TreeNode&gt; right;

public:
  TreeNode(int value) : value(value), left(nullptr), right(nullptr) {}

private:
  static void insert(std::unique_ptr&lt;TreeNode&gt; &amp;node, int value) {
    if (node) {
      node-&gt;insert(value);
    } else {
      node = std::make_unique&lt;TreeNode&gt;(value);
    }
  }

  void insert(int value) {
    if (value &lt; this-&gt;value) {
      insert(this-&gt;left, value);
    } else {
      insert(this-&gt;right, value);
    }
  }
};

class BinaryTree {
private:
  std::unique_ptr&lt;TreeNode&gt; root;

public:
  BinaryTree() : root(nullptr) {}

  void insert(int value) { TreeNode::insert(root, value); }
};

int main() {
  BinaryTree b;
  b.insert(42);

  return 0;
}
</code></pre>
<p>In Rust, however, both types can be defined in the same module, and so have
access to each other's private fields and methods. The module as a whole
provides a collection of types, methods, and functions that together define a
encapsulated concept.</p>
<pre><pre class="playground"><code class="language-rust">mod binary_tree {
    pub struct BinaryTree {
        root: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl BinaryTree {
        pub fn new() -&gt; BinaryTree {
            BinaryTree { root: None }
        }

        pub fn insert(&amp;mut self, value: i32) {
            insert(&amp;mut self.root, value);
        }
    }

    struct TreeNode {
        value: i32,
        left: Option&lt;Box&lt;TreeNode&gt;&gt;,
        right: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl TreeNode {
        fn new(value: i32) -&gt; TreeNode {
            TreeNode {
                value,
                left: None,
                right: None,
            }
        }

        fn insert(&amp;mut self, value: i32) {
            if value &lt; self.value {
                insert(&amp;mut self.left, value);
            } else {
                insert(&amp;mut self.right, value);
            }
        }
    }

    fn insert(node: &amp;mut Option&lt;Box&lt;TreeNode&gt;&gt;, value: i32) {
        match node {
            None =&gt; {
                *node = Some(Box::new(TreeNode::new(value)));
            }
            Some(ref mut left) =&gt; {
                left.insert(value);
            }
        }
    }
}

use binary_tree::BinaryTree;

fn main() {
    let mut b = BinaryTree::new();
    b.insert(42);
}</code></pre></pre>
<h2 id="passkey-idiom"><a class="header" href="#passkey-idiom">Passkey idiom</a></h2>
<p>In the previous C++ example, the <code>TreeNode</code> constructor has to be public in
order to be used with <code>make_unique</code>. To make the constructor effectively
private, one might need to use a programming pattern like <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/patterns/passkey.md">the passkey
idiom</a>.</p>
<p>The passkey idiom is also sometimes used to provide finer-grained control over
access to members than is possible with friend declarations. In either case, the
effect is achieved by modeling a capability-like system.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

class Person {
  int age;

  class Passkey {};

public:
  std::string name;

  Person(Passkey, std::string name, int age) : name(name), age(age) {}

  static std::unique_ptr&lt;Person&gt; createPerson(std::string name, int age) {
    // Other uses of make_unique are not possible because the Passkey type
    // cannot be constructed.
    return std::make_unique&lt;Person&gt;(Passkey(), name, age);
  }
};
</code></pre>
<p>In Rust this idiom possible to express in order to achieve the same effect.
However is unlikely to be used because</p>
<ul>
<li>coupled types are usually defined in the same module (or a <code>pub (in path)</code>
declaration can be used), making it unnecessary, and</li>
<li>it requires cooperation from the interface by which the calling function will
use a type.</li>
</ul>
<p>The second point contrasts with the use above involving <code>std::make_unique</code> which
is able to forward to the underlying constructor without knowing about it at the
point of the definition of <code>std::make_unique</code>. While the example below is not
useful (because <code>alloc_thing</code> is not a useful helper), it does demonstrate what
would types have to be defined in order to achieve the same effect as when using
the idiom in C++.</p>
<pre><pre class="playground"><code class="language-rust">pub trait Maker&lt;K, B&gt; {
    fn make(passkey: K, args: B) -&gt; Self;
}

// Generic helper that we want to be able to call an otherwise private function
// or method.
fn alloc_thing&lt;K, B, T: Maker&lt;K, B&gt;&gt;(passkey: K, args: B) -&gt; Box&lt;T&gt; {
    Box::new(Maker::&lt;K, B&gt;::make(passkey, args))
}

mod person {
    use super::*;
    use std::marker::PhantomData;

    pub struct Person {
        pub name: String,
        age: u32,
    }

    // A zero-sized type to act as the passkey.
    pub struct Passkey {
        // This field is zero-sized. It is also private, which prevents
        // construction of Passkey outside of the person module.
        _phantom: PhantomData&lt;()&gt;,
    }

    impl Person {
        // Private method that will be exposed with a passkey wrapper.
        fn new(name: String, age: u32) -&gt; Person {
            Person { name, age }
        }

        // Method that uses external helper that requires access to another
        // otherwise-private method.
        fn alloc(name: String, age: u32) -&gt; Box&lt;Person&gt; {
            alloc_thing(
                Passkey {
                    _phantom: PhantomData {},
                },
                MakePersonArgs { name, age },
            )
        }
    }

    // Helper structure needed to make the trait providing the interface generic.
    pub struct MakePersonArgs {
        pub name: String,
        pub age: u32,
    }

    // Implementation of the trait that exposes the method requiring a passkey.
    impl Maker&lt;Passkey, MakePersonArgs&gt; for Person {
        fn make(_passkey: Passkey, args: MakePersonArgs) -&gt; Person {
            Person::new(args.name, args.age)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="friends-and-testing"><a class="header" href="#friends-and-testing">Friends and testing</a></h2>
<p>Another common use of friend declarations is to make the internals of a class
available for unit testing. Though this practice is often discouraged in C++, it
is sometimes necessary in order to test other-wise private helper inner classes
or helper methods.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

class Person {
public:
  std::string name;

private:
  int age;

  friend class PersonTest;

public:
  Person(std::string name, int age) : name(name), age(age) {}

  void have_birthday() { this-&gt;age = this-&gt;age + 1; }
};

#define BOOST_TEST_MODULE PersonTestModule
#include &lt;boost/test/included/unit_test.hpp&gt;

class PersonTest {
public:
  static void test_have_birthday() {
    Person alice("Alice", 42);
    BOOST_CHECK_EQUAL(alice.age, 42);

    alice.have_birthday();
    BOOST_CHECK_EQUAL(alice.age, 43);
  }
};

BOOST_AUTO_TEST_CASE(have_birthday_test) { PersonTest::test_have_birthday(); }
</code></pre>
<p>In Rust, tests are usually defined in the same module as the code being tested.
Because the content of modules is visible to submodules, this makes it so that
all of the content of the module is available for testing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
    pub name: String,
    age: u32,
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Person {
        Person { name, age }
    }

    pub fn have_birthday(&amp;mut self) {
        self.age = self.age + 1;
    }
}

#[cfg(test)]
mod test {
    use super::Person;

    #[test]
    fn check() {
        let mut alice = Person::new("alice".to_string(), 42);

        assert_eq!(alice.age, 42);
        alice.have_birthday();
        assert_eq!(alice.age, 43);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Testing in Rust is described in more detail in the <a href="idioms/encapsulation/TODO">chapter on unit testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-constructors"><a class="header" href="#private-constructors">Private constructors</a></h1>
<p>In C++ constructors for classes can be made private by declaring them private,
or by defining a class using <code>class</code> and using the default private visibility.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

struct Person {
  std::string name;
  int age;

private:
  Person() = default;
};

int main() {
  // Person nobody; // &lt;-- fails to compile, Person::Person() private
  // Person alice{"Alice", 42}; // &lt;-- fails to compile since C++20
  return 0;
}
</code></pre>
<p>In Rust, constructors for structs are visible from wherever the type and all
fields are visible.</p>
<p>To achieve similar visibility restrictions as the above example, an additional
private field needs to be added to the struct in Rust. Because Rust supports
zero-sized types, the additional field can have no performance cost. The <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit
type</a> has zero size and can
be used for this purpose.</p>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        pub age: i32,
        _private: (),
    }

    impl Person {
        pub fn new(name: String, age: i32) -&gt; Person {
            Person { name, age, _private: () }
        }
    }
}

use person::*;

fn main() {
    // field `_private` of struct `person::Person` is private
    // let alice = Person {
    //     name: "Alice".to_string(),
    //     age: 42,
    //     _private: (),
    // };

    // cannot construct `person::Person` with struct literal syntax due to private fields
    // let bob = Person {
    //     name: "Bob".to_string(),
    //     age: 55,
    // };

    let carol = Person::new("Carol".to_string(), 20);
    // Can match on the public fields, and then use .. to ignore the remaning ones.
    let Person { name, age, .. } = carol;
}</code></pre></pre>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>Unlike C++ unions, but like <code>std::variant</code>, Rust enums do not have direct
control over the visibility of their variants or the fields of their variants.
In the following example, the <code>circle</code> variant of the <code>Shape</code> union is not
public, so it can only be accessed from within the definition of <code>Shape</code>, as it
is by the <code>make_circle</code> static method.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;
};

struct Circle {
  double radius;
};

union Shape {
  Triangle triangle;

private:
  Circle circle;

public:
  static Shape make_circle(double radius) {
    Shape s;
    s.circle = Circle(radius);
    return s;
  };
};

int main() {
  Shape triangle;
  triangle.triangle = Triangle{1.0, 2.0};
  Shape circle = Shape::make_circle(1.0);
  // circle.circle = Circle{1.0}; // fails to compile

  // std::cout &lt;&lt; shape.circle.radius; // fails to compile
}
</code></pre>
<p>In Rust visibility modifiers cannot be applied to individual enum variants or
their fields.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum Shape {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }
}

use shape::*;

fn main() {
    let triangle = Shape::Triangle {
        base: 1.0,
        height: 2.0,
    };

    let circle = Shape::Circle { radius: 1.0 };

    match circle {
        Shape::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle { radius } =&gt; {
            println!("Circle {}", radius);
        }
    }
}</code></pre></pre>
<p>Instead, to control construction of and pattern matching on the enum
implementation, one of two approaches can be taken. The first controls
construction of and access to the fields, but not inspection of which variant is
active.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub struct Triangle {
        pub base: f64,
        pub height: f64,
        _private: (),
    }
    pub struct Circle {
        pub radius: f64,
        _private: (),
    }

    pub enum Shape {
        Triangle(Triangle),
        Circle(Circle),
    }

    impl Shape {
        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape::Triangle(Triangle {
                base,
                height,
                _private: (),
            })
        }

        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape::Circle(Circle {
                radius,
                _private: (),
            })
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    match circle {
        Shape::Triangle(Triangle { base, height, .. }) =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle(Circle { radius, .. }) =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The second places the enum in a struct with a private field, preventing both
construction and inspection from outside of the module.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape(ShapeKind::Circle { radius })
        }

        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape(ShapeKind::Triangle { base, height })
        }

        pub fn print(&amp;self) {
            match self.0 {
                ShapeKind::Triangle { base, height } =&gt; {
                    println!("Triangle: {}, {}", base, height);
                }
                ShapeKind::Circle { radius } =&gt; {
                    println!("Circle: {}", radius);
                }
            }
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(_) -&gt; {}
    // }

    circle.print();
}</code></pre></pre>
<p>If the purpose of making the variants private is to ensure that invariants are
met, then it can be useful to expose the implementing enum (<code>ShapeKind</code>) but not
the field of the wrapping struct (<code>Shape</code>), with the invariants only being
guaranteed when the wrapping struct is used. In this case, it is necessary to
make the field private and define a getter function, since otherwise the field
would be modifiable, possibly violating the invariant that the wrapping struct
represents.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new(kind: ShapeKind) -&gt; Option&lt;Shape&gt; {
            // ... check invariants ...
            Some(Shape(kind))
        }

        pub fn get_kind(&amp;self) -&gt; &amp;ShapeKind {
            &amp;self.0
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new(ShapeKind::Triangle {
        base: 1.0,
        height: 2.0,
    });
    let Some(circle) = Shape::new(ShapeKind::Circle { radius: 1.0 }) else {
        return;
    };

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(c) =&gt; {}
    // };

    match circle.get_kind() {
        ShapeKind::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        ShapeKind::Circle { radius } =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The situation in Rust resembles the situation in C++ when using <code>std::variant</code>,
for which it is not possible to make the variants themselves private. Instead
either the constructors for the types that form the variants can be made private
or the variant can be wrapped in a class with appropriate visibility controls.</p>
<h2 id="rusts-non_exhaustive-annotation"><a class="header" href="#rusts-non_exhaustive-annotation">Rust's <code>#[non_exhaustive]</code> annotation</a></h2>
<p>If a struct or enum is intended to be public within a
<a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crate</a>, but
should not be constructed outside of the crate, then the <code>#[non_exhaustive]</code>
attribute can be used to constrain construction. The attribute can be applied to
both structs and to individual enum variants with the same effect as adding a
private field.</p>
<p>However, the attribute applies the constraint at the level of the crate, not at
the level of a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Person {
    pub name: String,
    pub age: i32,
}

pub enum Shape {
    #[non_exhaustive]
    Triangle { base: f64, height: f64 },
    #[non_exhaustive]
    Circle { radius: f64 },
}
<span class="boring">}</span></code></pre></pre>
<p>The attribute is more typically used to force clients of a library to include
the wildcard when matching on the struct fields, making it so that adding
additional fields to a struct is not breaking change (i.e., that it does not
require the increase of the major version component when using semantic
versioning).</p>
<p>Applying the <code>#[non_exhasutive]</code> attribute to the enum itself makes it as if one
of the variants were private, requiring a wildcard when matching on the variant
itself. This has the same effect in terms of versioning as when used on a struct
but is less advantageous. In most cases, code failing to compile when a new enum
variant is added is desirable, since that indicates a new case that requires
logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setter-and-getter-methods"><a class="header" href="#setter-and-getter-methods">Setter and getter methods</a></h1>
<p>Setters and getters work similarly in C++ and Rust, but are used less frequently
in Rust.</p>
<p>It would not be unusual to see the following representation of a two-dimensional
vector in C++, which hides its implementation and provides setters and getters
to access the fields. This choice would typically be made in case a
representation change (such as using polar instead of rectangular coordinates)
needed to be made later without breaking clients.</p>
<pre><code class="language-cpp">class Vec2 {
  double x;
  double y;

public:
  Vec2(double x, double y) : x(x), y(y) {}
  double getX() { return x; }
  double getY() { return y; }

  // ... vector operations ...
};
</code></pre>
<p>On the other hand, in Rust such a type would almost always be defined with
public fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec2 {
    pub x: f64,
    pub y: f64,
}

impl Vec2 {
    // ... vector operations ...
}
<span class="boring">}</span></code></pre></pre>
<p>One major reason for the difference is a limitation of the borrow checker. With
a getter function the entire structure is borrowed, preventing mutable use of
other fields of the structure.</p>
<pre><code class="language-rust ignore">struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn get_name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

fn main() {
    let mut alice = Person { name: "Alice".to_string(), age: 42 };
    let name = alice.get_name();

    alice.age = 43;

    println!("{}", name);
}</code></pre>
<pre><code class="language-text">error[E0506]: cannot assign to `alice.age` because it is borrowed
  --&gt; example.rs:16:5
   |
14 |     let name = alice.get_name();
   |                ----- `alice.age` is borrowed here
15 |
16 |     alice.age = 43;
   |     ^^^^^^^^^^^^^^ `alice.age` is assigned to here but it was already borrowed
17 |
18 |     println!("{}", name);
   |                    ---- borrow later used here

error: aborting due to 1 previous error
</code></pre>
<p>Some additional reasons for the difference are:</p>
<ul>
<li>Ergonomics: Public members make it possible to use pattern matching.</li>
<li>Transparency of performance: A change in representation would dramatically
change the costs involved with the getters. Exposing the representation makes
the cost change visible.</li>
<li>Control over mutability: Static lifetime checking of mutable references
removes concerns of unintended mutation of the value through Rust's equivalent
of observation pointers.</li>
</ul>
<h2 id="types-with-invariants-and-newtypes"><a class="header" href="#types-with-invariants-and-newtypes">Types with invariants and newtypes</a></h2>
<p>When types need to preserve invariants but the benefits of exposing fields are
desired, a newtype pattern can be used. A wrapping "newtype" struct that
represents the data with an invariant is defined and access to the fields of the
underlying struct is provided by via a non-<code>mut</code> reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod vec2 {
    #[derive(Debug, Clone, Copy)]
    pub struct Vec2 {
        pub x: f64,
        pub y: f64,
    }

    /// Represents a 2-vector that has magnitude 1.
    #[derive(Debug, Clone, Copy)]
    pub struct Normalized(Vec2); // note the private field

    fn sqrt_approx_zero(x: f64) -&gt; bool {
        x &lt; 0.001
    }

    impl Normalized {
        pub fn from_vec2(v: Vec2) -&gt; Option&lt;Normalized&gt; {
            if sqrt_approx_zero(v.x * v.x + v.y * v.x - 1.0) {
                Some(Normalized(v))
            } else {
                None
            }
        }

        // The getter provides a reference to the underlying Vec2 value
        // permitting mutation.
        pub fn get(&amp;self) -&gt; &amp;Vec2 {
            &amp;self.0
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-promotions-and-conversions"><a class="header" href="#type-promotions-and-conversions">Type promotions and conversions</a></h1>
<h2 id="lvalue-to-rvalue"><a class="header" href="#lvalue-to-rvalue">lvalue to rvalue</a></h2>
<p>In C++ lvalues are automatically converted to rvalues when needed.</p>
<pre><code class="language-cpp">int main() {
    int x(0); // Local variables are an lvalues,
    x = 42; // and therefore may be assigned to.

    int y = x + 1; // x can be converted to an lvalue when needed.

    return 0;
}
</code></pre>
<p>In Rust the equivalent of lvalues are "place expressions" (expressions that
represent memory locations) and the equivalent of rvalues are "value
expressions". Place expressions are automatically converted to value expressions
when needed.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 0; // Local variables are an lvalues,
    x = 42; // and therefore may be assigned to.

    let y = x + 1; // and therefore may be assigned to.
}</code></pre></pre>
<h2 id="array-to-pointer"><a class="header" href="#array-to-pointer">Array to pointer</a></h2>
<p>In C++, arrays are automatically converted to pointers as required.</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;

int main() {
  char example[6] = "hello";
  char other[6];

  // strncpy takes arguments of type char*
  strncpy(other, example, 6);

  return 0;
}
</code></pre>
<p>The equivalent to this in Rust is the automatic conversion of vector and array
references to slice references.</p>
<pre><pre class="playground"><code class="language-rust">fn third(ts: &amp;[char]) -&gt; Option&lt;&amp;char&gt; {
    ts.get(2)
}

fn main() {
    let vec: Vec&lt;char&gt; = vec!['a', 'b', 'c'];
    let arr: [char; 3] = ['a', 'b', 'c'];

    third(&amp;vec);
    third(&amp;arr);
}</code></pre></pre>
<p>Because slice references can be easily used in a memory-safe way, it is
generally recommended in Rust to define functions in terms of slice references
instead of in terms of references to vectors or arrays, unless vector-specific
or array-specific functionality is needed.</p>
<p>Unlike in C++ where the conversion from arrays to pointers is built into the
language, this is actually a general mechanism provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a>, which provides one
kind of <a href="idioms//idioms/user-defined_conversions.html">user-defined conversion</a>.</p>
<h2 id="function-to-pointer"><a class="header" href="#function-to-pointer">Function to pointer</a></h2>
<p>In C++ functions and static member functions are automatically converted to
function pointers.</p>
<pre><code class="language-cpp">int twice(int n) { return n * n; }

int main() {
  int (*twicePtr)(int) = twice;
  int result = twicePtr(5);

  return 0;
}
</code></pre>
<p>Rust performs the same conversion. In addition to functions and members that do
not take <code>self</code> as an argument, constructors (proper constructors) also have
function type and can be converted to function pointers. Non-capturing closures
do not have function type, but can also be converted to function pointers. There
is no syntax in Rust for the function type itself.</p>
<pre><pre class="playground"><code class="language-rust">fn twice(x: i32) -&gt; i32 {
    x * x
}

struct MyPair(i32, i32);

impl MyPair {
    fn new() -&gt; MyPair {
        MyPair(0, 0)
    }
}

fn main() {
    let twicePtr: fn(i32) -&gt; i32 = twice;
    let res = twicePtr(5);

    let ctorPtr: fn(i32, i32) -&gt; MyPair = MyPair;
    let pair = ctorPtr(10, 20);

    let methodPtr: fn() -&gt; MyPair = MyPair::new;
    let pair2 = methodPtr();

    let closure: fn(i32) -&gt; i32 = |x: i32| x * 5;
    let closureRes = closure(2);
}</code></pre></pre>
<h2 id="numeric-promotion-and-numeric-conversion"><a class="header" href="#numeric-promotion-and-numeric-conversion">Numeric promotion and numeric conversion</a></h2>
<p>In C++ there are several kinds of implicit conversions that occur between
numeric types. The most commonly encountered are numeric promotions, which
convert numeric types to larger types.</p>
<pre><code class="language-cpp">int main() {
  int x(0);
  long y = x;

  float a(1.0);
  double b = a;

  return 0;
}
</code></pre>
<p>These lossless conversions are not implicit in Rust. Instead, they must be
performed explicitly using the <code>Into::into()</code> method. These conversions are
provided by implementations of the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits. The list
of conversions provided by the Rust standard library is <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors">listed on the
documentation
page</a> for
the trait.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let y: i64 = x.into();

    let a: f32 = 1.0;
    let b: f64 = a.into();
}</code></pre></pre>
<p>There are several implicit conversions that occur in C++ that are not lossless.
For example, integers can be implicitly converted to unsigned integers in C++.</p>
<pre><code class="language-cpp">int main() {
  int x(42);
  unsigned int y = x;

  return 0;
}
</code></pre>
<p>In Rust, these conversions are also required to be explicit and are provided by
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> traits
which require handling the cases where the value does not map to the other type.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;

fn main() {
    let x: i32 = 42;
    let y: u32 = match x.try_into() {
        Ok(x) =&gt; x,
        Err(err) =&gt; {
            panic!("Can't convert! {:?}", err);
        }
    };
}</code></pre></pre>
<p>Some conversions that occur in C++ are supported by neither <code>From</code> nor <code>TryFrom</code>
because the conversion is either insufficiently obvious or because they are not
value-preserving. For example, in C++ <code>int32_t</code> can implicitly be converted to
<code>float</code> despite <code>float</code> not being able to represent all 32 bit the integers
precisely.</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  int32_t x(42);
  float a = x;

  return 0;
}
</code></pre>
<p>In Rust the only way to convert from an <code>i32</code> to an <code>f32</code> is with the <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#r-expr.as.coercions"><code>as</code>
operator</a>.
The operator can actually be used to convert between other primitive types as
well and does not panic or produce undefined behavior, but may not convert in
the desired way (e.g., it may use a different rounding mode than desired or it
may truncate rather than saturate as desired).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let a: f32 = x as f32;
}</code></pre></pre>
<h3 id="isize-and-usize"><a class="header" href="#isize-and-usize"><code>isize</code> and <code>usize</code></a></h3>
<p>In the Rust standard library the <code>isize</code> and <code>usize</code> types are used for values
intended to used be indices (much like <code>size_t</code> in C++). However, their use for
other purposes is usually discouraged in favor of using explicitly sized types
such as <code>u32</code>. This results a situation where values of type <code>u32</code> have to be
converted to <code>usize</code> for use in indexing, but <code>Into&lt;usize&gt;</code> is not implemented
for <code>u32</code>.</p>
<p>In these cases, best practice is to use <code>TryInto</code>, and if further error handling
of the failure cause is not desired, to call <code>unwrap</code>, creating a panic at the
point of conversion.</p>
<p>This is preferred because it prevents the possibility of moving forward with an
incorrect value. E.g., consider converting a <code>u64</code> to a <code>usize</code> that has a
32-bit representation with <code>as</code>, which truncates the result. A value that is one
greater than the <code>u32::MAX</code> will truncate to <code>0</code>, which would probably result in
successfully retrieving a value from a data structure, thus masking a bug and
producing unexpected behavior.</p>
<h3 id="enums-2"><a class="header" href="#enums-2">Enums</a></h3>
<p>In C++ enums can be implicitly converted to integer types.</p>
<pre><code class="language-cpp">enum Shape {
  Triangle = 0,
  Circle,
};

int main() {
  int shape = Triangle;

  return 0;
}
</code></pre>
<p>In Rust the conversion requires the use of the <code>as</code> operator, and providing
<code>From</code> and <code>TryFrom</code> implementations to move back and forth between the enum and
its representation type is recommended. Examples and additional details are
given in the <a href="idioms//idioms/data_modeling/enums.html">chapter on enums</a>.</p>
<h2 id="qualification-conversion"><a class="header" href="#qualification-conversion">Qualification conversion</a></h2>
<p>In C++ qualification conversions enable the use of const (or volatile) values
where the const (or volatile) qualifier is not expected.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

void display(const std::string &amp;str) {
  std::cout &lt;&lt; "Displaying: " &lt;&lt; str &lt;&lt; std::endl;
}

int main() {
  // no const qualifier
  std::string message("hello world");

  // used where const expected
  display(message);

  return 0;
}
</code></pre>
<p>In Rust the equivalent enables the use of <code>mut</code> variables and <code>mut</code> references
to be used where non-<code>mut</code> variables or references are expected.</p>
<pre><pre class="playground"><code class="language-rust">fn display(msg: &amp;str) {
    println!("{}", msg);
}

fn main() {
    let mut s: String = "hello world".to_string();
    let msg: &amp;mut str = s.as_mut();
    display(msg);
}</code></pre></pre>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer literals</a></h2>
<p>In C++ integer literals with no suffix indicating type have the smallest type in
which they can fit from <code>int</code>, <code>long int</code>, or <code>long long int</code>. When the literal
is then assigned to a variable of a different type, an implicit conversion is
performed.</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  // Compiles without error (but with a warning).
  uint32_t y = 4294967296;

  return 0;
}
</code></pre>
<p>In Rust, integer literals have their type inferred depending on context. When
there is insufficient information to infer a type either <code>i32</code> is assumed or may
require some type annotation to be given.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // error: literal out of range for `u32`
    // let x: u32 = 4294967296;

    let x = 1; // assumes i32

    // fails to compile because it is inferred as i32
    // print!("{}", 4294967296);

    // These work, though.
    println!("{}", 4294967296u64);

    let y: u64 = 4294967296;
    println!("{}", y);
}</code></pre></pre>
<h2 id="safe-bools"><a class="header" href="#safe-bools">Safe bools</a></h2>
<p>The safe bool idiom exists to make it possible to use types as conditions. Since
C++11 this idiom is straightforward to implement.</p>
<pre><code class="language-cpp">struct Wire {
  bool ready;
  unsigned int value;

  explicit operator bool() const { return ready; }
};

int main() {
  Wire w{false, 0};
  // ...

  if (w) {
    // use w.value
  } else {
    // do something else
  }

  return 0;
}
</code></pre>
<p>In Rust instead of converting the value to a boolean, the normal idiom matches
on the value instead. Depending on the situation, the mechanism used for
matching might be <code>match</code>, <code>if let</code>, or <code>let else</code>.</p>
<pre><pre class="playground"><code class="language-rust">enum Wire {
    Ready(u32),
    NotReady,
}

fn main() {
    let wire = Wire::NotReady;
    // ...

    // match
    match wire {
        Wire::Ready(v) =&gt; {
            // use value v
        }
        Wire::NotReady =&gt; {
            // do something else
        }
    }

    // if let
    if let Wire::Ready(v) = wire {
        // use value v
    }

    // let else
    let Wire::Ready(v) = wire else {
        // do something that doesn't continue, like early return
        return;
    };
}</code></pre></pre>
<h2 id="user-defined-conversions"><a class="header" href="#user-defined-conversions">User-defined conversions</a></h2>
<p>User-defined conversions are covered in a <a href="idioms//idioms/user-defined_conversions.html">separate
chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-conversions-1"><a class="header" href="#user-defined-conversions-1">User-defined conversions</a></h1>
<p>In C++ user-defined conversions are created using <a href="https://en.cppreference.com/w/cpp/language/converting_constructor">converting
constructors</a>
or <a href="https://en.cppreference.com/w/cpp/language/cast_operator">conversion
functions</a>. Because
converting constructors are opt-out (via the <code>explicit</code> specifier), implicit
conversions occur with regularity in C++ code. In the following example both the
assignments and the function calls make use of implicit conversions as provided
by a converting constructor.</p>
<pre><code class="language-cpp">struct Widget {
  Widget(int) {}
  Widget(int, int) {}
};

void process(Widget w) {}

int main() {
  Widget w1 = 1;
  Widget w2 = {4, 5};
  process(1);
  process({4, 5});

  return 0;
}
</code></pre>
<p>Rust makes significantly less use of implicit conversions. Instead most
conversions are explicit. The
<a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code></a> module
provides several traits for working with user-defined conversions.</p>
<p>In Rust, the above example would make use of explicit conversions by
implementing the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code>
trait</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(_x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;(i32, i32)&gt; for Widget {
    fn from(_x: (i32, i32)) -&gt; Widget {
        Widget
    }
}

fn process(w: Widget) {}

fn main() {
    let w1: Widget = 1.into();
    // For construction this is more idiomatic:
    let w1b = Widget::from(1);

    let w2: Widget = (4, 5).into();
    // For construction this is more idiomatic:
    let w2b = Widget::from((4, 5));

    process(1.into());
    process((4, 5).into());
}</code></pre></pre>
<p>The <code>into</code> method used above is provided via a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">blanket
implementations</a>
for the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into trait</code></a>
for types that implement the <code>From</code> trait.</p>
<h2 id="conversion-functions"><a class="header" href="#conversion-functions">Conversion functions</a></h2>
<p>C++ conversion functions enable conversions in the other direction, from the
defined class to another type.</p>
<pre><code class="language-cpp">#include &lt;utility&gt;

struct Point {
  int x;
  int y;

  operator std::pair&lt;int, int&gt;() const { return std::pair(x, y); }
};

void process(std::pair&lt;int, int&gt;) {}

int main() {
  Point p1{1, 2};
  Point p2{3, 4};

  std::pair&lt;int, int&gt; xy = p1;
  process(p2);

  return 0;
}
</code></pre>
<p>To achieve the same in Rust, the <code>From</code> trait can be implemented in the other
direction, so long as the one of the source or target type is defined in the
same module as the trait implementation.</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(p: Point) -&gt; (i32, i32) {
        (p.x, p.y)
    }
}

fn process(x: (i32, i32)) {}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };

    let xy: (i32, i32) = p1.into();
    process(p2.into());
}</code></pre></pre>
<p>Conversion functions are is often used to implement the safe bool pattern,
<a href="idioms//idioms/promotions_and_conversions.html#safe-bools">which is addressed in a different way in
Rust</a>.</p>
<h2 id="borrowing-conversions"><a class="header" href="#borrowing-conversions">Borrowing conversions</a></h2>
<p>An important part of <code>From</code> is that the conversion takes ownership of the
converted value. When this is not desired in C++, the conversion function can
just take and return references.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

struct Person {
  std::string name;

  operator std::string &amp;() { return this-&gt;name; }
};

void process(std::string &amp;name) { std::cout &lt;&lt; name &lt;&lt; std::endl; }

// Prints:
// Alice
// Alice
int main() {
  Person alice{"Alice"};

  process(alice);

  std::cout &lt;&lt; alice.name &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p>To achieve this in Rust the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code>
trait</a> or <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code>
trait</a> can be used.</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
    name: String,
}

impl AsRef&lt;str&gt; for Person {
    fn as_ref(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}

impl AsMut&lt;str&gt; for Person {
    fn as_mut(&amp;mut self) -&gt; &amp;mut str {
        &amp;mut self.name
    }
}

fn process&lt;T: AsRef&lt;str&gt;&gt;(name: T) {}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice);
}</code></pre></pre>
<p>It is common to use <code>AsRef</code> as a trait bound in function definitions. Providing
such a bound allows clients to call the functions with anything that can be
cheaply viewed as the type that the function wants to work with. With this in
mind, the above definition of <code>process</code> would be defined as in the following
example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsRef&lt;str&gt; for Person {
</span><span class="boring">    fn as_ref(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsMut&lt;str&gt; for Person {
</span><span class="boring">    fn as_mut(&amp;mut self) -&gt; &amp;mut str {
</span><span class="boring">        &amp;mut self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn process&lt;T: AsRef&lt;str&gt;&gt;(name: T) {}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice);
}</code></pre></pre>
<p>This technique is often used with functions that take file system paths, so that
literal strings can more easily be used as paths.</p>
<h2 id="fallible-conversions"><a class="header" href="#fallible-conversions">Fallible conversions</a></h2>
<p>In C++ when conversions might fail it is possible (though bad practice) to throw
an exception from the converting constructor or converting function.</p>
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;string&gt;

class NonEmpty {
  std::string s;

public:
  NonEmpty(std::string s) : s(s) {
    if (this-&gt;s.empty()) {
      throw std::domain_error("empty string");
    }
  }
};

int main() {
  std::string s("");
  NonEmpty x = s; // throws

  return 0;
}
</code></pre>
<p>Because error handling in Rust <a href="idioms/TODO">does not use exceptions</a>, the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code>
trait</a> and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code>
trait</a> can be
implemented instead. These traits differ from <code>From</code> and <code>Into</code> in that they
return a <code>Result</code>, which may indicate a failing case. When a conversion may fail
one should implement <code>TryFrom</code> and rely on the client to call <code>unwrap</code> on the
result, rather than panic in a <code>From</code> implementation.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::convert::TryInto;

struct NonEmpty {
    s: String,
}

#[derive(Clone, Copy, Debug)]
struct NonEmptyStringError;

impl TryFrom&lt;String&gt; for NonEmpty {
    type Error = NonEmptyStringError;

    fn try_from(s: String) -&gt; Result&lt;NonEmpty, NonEmptyStringError&gt; {
        if s.is_empty() {
            Err(NonEmptyStringError)
        } else {
            Ok(NonEmpty { s })
        }
    }
}

fn main() {
    let res: Result&lt;NonEmpty, NonEmptyStringError&gt; = "".to_string().try_into();
    match res {
        Ok(ne) =&gt; {
            println!("Converted!");
        }
        Err(err) =&gt; {
            println!("Couldn't convert");
        }
    }
}</code></pre></pre>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Rust does have one kind of user-defined implicit conversion, called <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion">deref
coercions</a>,
provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a> and
<a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code>trait</a>. These
coercions exist for making pointer-like types more ergonomic to use.</p>
<p>An <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">example</a> of implementing
the traits for a custom pointer-like type is given in the Rust book.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>A summary of when to use which kind of conversion interface is given in the
documentation for the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code>
module</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>C++ supports overloading of functions, so long as the invocations of the
functions can be distinguished by the number or types of their arguments.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

double twice(double x) {
	return x + x;
}

int twice(int x) {
	return x + x;
}
</code></pre>
<p>Rust does not support this kind of function overloading. Instead, Rust has a few
different mechanisms (some of which C++ also has) for achieving the effects of
overloading in a way that interacts better with type inference. The mechanisms
usually involve making the commonalities between the overloaded functions
apparent in the code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice(x: f64) -&gt; f64 {
    x + x
}

// error[E0428]: the name `twice` is defined multiple times
// fn twice(x: i32) -&gt; i32 {
//     x + x
// }
<span class="boring">}</span></code></pre></pre>
<p>In practice, an example like the above would also likely be implemented in a
more structured way even in C++, using templates.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T twice(T x) {
	return x + x;
}
</code></pre>
<p>When phrased this way, the example can be translated to Rust, with the notable
addition of <a href="idioms//idioms/data_modeling/concepts.html">requiring a trait bound on the
type</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice&lt;T&gt;(x: T) -&gt; T::Output
where
    T: std::ops::Add&lt;T&gt;,
    T: Copy,
{
    x + x
}
<span class="boring">}</span></code></pre></pre>
<h2 id="overloaded-methods"><a class="header" href="#overloaded-methods">Overloaded methods</a></h2>
<p>In C++ it is possible to have methods with the same name but different
signatures on the same type. In Rust there can be at most one method with the
same name for each trait implementation and at most one inherent method with the
same name for a type.</p>
<p>In cases where there are multiple methods with the same names because the method
is defined for multiple traits, the desired method must be distinguished at the
call site by specifying the trait.</p>
<pre><pre class="playground"><code class="language-rust">trait TraitA {
    fn go(&amp;self) -&gt; String;
}

trait TraitB {
    fn go(&amp;self) -&gt; String;
}

struct MyStruct;

impl MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called inherent method".to_string()
    }
}

impl TraitA for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait A method".to_string()
    }
}

impl TraitB for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait B method".to_string()
    }
}

fn main() {
    let my_struct = MyStruct;

    // Calling the inherent method
    println!("{}", my_struct.go());

    // Calling the method from TraitA
    println!("{}", TraitA::go(&amp;my_struct));

    // Calling the method from TraitB
    println!("{}", TraitB::go(&amp;my_struct));
}</code></pre></pre>
<p>One exception to this is when the methods are all from the same generic trait
with with different type parameters for the implementations. In that case, if
the signature is sufficient to determine which implementation to use, the trait
does not need to be specified to resolve the method. This is common when using
the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code> trait</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;f32&gt; for Widget {
    fn from(x: f32) -&gt; Widget {
        Widget
    }
}

fn main() {
    // Calls &lt;Widget as From&lt;i32&gt;&gt;::from
    Widget::from(5);
    // Calls &lt;Widget as From&lt;f32&gt;&gt;::from
    Widget::from(1.0);
}</code></pre></pre>
<h2 id="overloaded-operators"><a class="header" href="#overloaded-operators">Overloaded operators</a></h2>
<p>In C++ most operators can either be overloaded either with a free-standing
function or by providing a method defining the operator on a class.</p>
<pre><code class="language-cpp">struct Vec2 {
  double x;
  double y;

  Vec2 operator+(const Vec2 &amp;other) const {
    return Vec2{x + other.x, y + other.y};
  }
};

int main() {
  Vec2 a{1.0, 2.0};
  Vec2 b{3.0, 4.0};
  Vec2 c = a + b;

  return 0;
}
</code></pre>
<p>Rust provides operator via implementation of specific traits. Implementing a
method of the same name as required by the trait will not make a type usable
with the operator if the trait is not implemented.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add for &amp;Vec2 {
    type Output = Vec2;

    // Note that the type of self here is &amp;Vec2.
    fn add(self, other: Self) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = &amp;a + &amp;b;
}</code></pre></pre>
<p>Additionally, sometimes it is best to provide trait implementations for various
combinations of reference types, especially for types that implement the <a href="idioms//idioms/constructors/copy_and_move_constructors.html"><code>Copy trait</code></a>, since they are
likely to want to be used either with or without taking a reference. For the
example above, that involve defining four implementations.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add&lt;&amp;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// If Vec2 weren't so small, it might be desireable to re-use space in the below
// implementations, since they take ownership.

impl std::ops::Add&lt;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;&amp;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<p>The repetition can be addressed by defining a macro.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

macro_rules! impl_add_vec2 {
    ($lhs:ty, $rhs:ty) =&gt; {
        impl std::ops::Add&lt;$rhs&gt; for $lhs {
            type Output = Vec2;

            fn add(self, other: $rhs) -&gt; Vec2 {
                Vec2 {
                    x: self.x + other.x,
                    y: self.y + other.y,
                }
            }
        }
    };
}

impl_add_vec2!(&amp;Vec2, &amp;Vec2);
impl_add_vec2!(&amp;Vec2, Vec2);
impl_add_vec2!(Vec2, &amp;Vec2);
impl_add_vec2!(Vec2, Vec2);

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h2>
<p>Default arguments in C++ are sometimes implemented in terms of function
overloading.</p>
<pre><code class="language-cpp">unsigned int shift(unsigned int x, unsigned int shiftAmount) {
    return x &lt;&lt; shiftAmount;
}

unsigned int shift(unsigned int x) {
    return shift(x, 2);
}

int main() {
    unsigned int a = shift(x); // shifts by 2

    return 0;
}
</code></pre>
<p>Rust does not have default arguments. Instead, arguments with <code>Option</code> type can
be used to provide a similar effect.</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Shl;

fn shift(x: u32, shift_amount: Option&lt;u32&gt;) -&gt; u32 {
    let a = shift_amount.unwrap_or(2);
    x.shl(a)
}

fn main() {
    let a = shift(2, None); // shifts by 2
}</code></pre></pre>
<h2 id="unrelated-overloads"><a class="header" href="#unrelated-overloads">Unrelated overloads</a></h2>
<p>The lack of completely ad hoc overloading in Rust encourages the definition of
traits that capture essential commonalities between types, so that functions can
be implemented in terms of those interfaces and used generally. However, it also
sometime encourages the anti-pattern of defining of traits that only capture
incidental commonalities (such as having methods of the same name).</p>
<p>It is better programming practice in those cases to simply define separate
functions, rather than to shoehorn in a trait where no real commonality exists.</p>
<p>This is commonly seen in Rust in the naming conventions for constructor static
methods. Instead of them all being named <code>new</code> with different arguments, they
are usually given names of the form <code>from_something</code>, where the <code>something</code>
varies based on from what the value is being constructed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

struct Vec2 {
    x: f64,
    y: f64,
}

impl Vec3 {
    fn from_scalar(x: f64) -&gt; Vec3 {
        Vec3 { x, y: 0.0, z: 0.0 }
    }

    fn from_vec2(v: &amp;Vec2) -&gt; Vec3 {
        Vec3 { x: v.x, y: v.y, z: 0.0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>In C++, constructors initialize objects.</p>
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person(int a) : age(a) {}
};

int main() {
  Person person(42);
  // ...
}
</code></pre>
<p>At the point when a constructor is executed, storage for the object has been
allocated and the constructor is only performing initialization.</p>
<pre><code class="language-cpp">class Person {
  int age;
  // non-owning pointer
  Person *best_friend;

public:
  Person(int a) : age(a), best_friend(this) {}
};

int main() {
  Person person(42);
  // ...
}
</code></pre>
<p>Rust does not have constructors in the same way as C++. In Rust, there is a
single fundamental way to create an object, which is to initialize all of its
members at once. The term "constructor" or "constructor method" in Rust refers
to something more like a factory: a static method associated with a type (i.e.,
a method that does not have a <code>self</code> parameter), which returns a value of the
type.</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
    age: i32
}

impl Person {
    const fn with_age(a: i32) -&gt; Self {
        Self { age: a }
    }
}

fn main() {
    let person = Person::with_age(42);
    // ...
}</code></pre></pre>
<p>Typically the primary constructor for a type is named <code>new</code>, especially if it
takes no arguments. See the chapter on <a href="idioms/constructors/default_constructors.html">default
constructors</a>. Additional constructors
are usually named <code>with_details</code> (e.g., <code>Person::with_name</code>). See the <a href="https://rust-lang.github.io/api-guidelines/naming.html">naming
guidelines</a> for the
conventions on how to name constructor methods in Rust.</p>
<p>If the fields to be initialized are visible, there is a reasonable default
value, and the value does not manage a resource, then it is also common to use
record update syntax to initialize a value based on some default value:</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

impl Point {
    const fn zero() -&gt; Self {
        Self { x: 0, y: 0, z: 0 }
    }
}

fn main() {
    let x_unit = Point {
        x: 1,
        ..Point::zero()
    };
    // ...
}</code></pre></pre>
<h2 id="storage-allocation-vs-initialization"><a class="header" href="#storage-allocation-vs-initialization">Storage allocation vs initialization</a></h2>
<p>The actual construction of a structure or enum value in Rust occurs where the
structure construction syntax <code>A { ... }</code> is, after the evaluation of the
expressions for the fields.</p>
<p>A significant implication of this difference is that storage is not allocated
for a struct in Rust at the point where the "constructor" is called, and in fact
is not allocated until after the values of the fields of a struct have been
computed (in terms of the semantics of the language--the optimizer may still
avoid the copy). Therefore there is no way in Rust to write the C++ example
above where the class stores a pointer to itself upon construction.</p>
<h2 id="fallible-constructors"><a class="header" href="#fallible-constructors">Fallible constructors</a></h2>
<p>In C++ the only way constructors can indicate failure is by throwing exceptions.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

class Person {
  int age;

public:
  Person(int a) : age(a) {
    if (age &lt; 0) {
      throw std::domain_error("Bad argument");
    }
  }
};

int main() {
  try {
    Person person(-4);
  } catch (const std::domain_error &amp;e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}
</code></pre>
<p>In Rust, because constructors are normal static methods, fallible constructors
can instead return <code>Result</code> (akin to <code>std::expected</code>) or <code>Option</code> (akin to
<code>std::optional</code>).</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
    age: i32,
}

#[derive(Debug)]
struct NegativeAgeError(i32);

impl Person {
    fn with_age(a: i32) -&gt; Result&lt;Self, NegativeAgeError&gt; {
        if a &lt; 0 {
            Err(NegativeAgeError(a))
        } else {
            Ok(Self { age: a })
        }
    }
}

fn main() {
    match Person::with_age(-4) {
        Err(err) =&gt; {
            println!("{:?}", err);
        }
        Ok(person) =&gt; {
            // ...
        }
    }
}</code></pre></pre>
<p>See <a href="idioms//exceptions.html">the chapter on exceptions</a> for more information on how C++
exceptions and exception handling translate to Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-constructors"><a class="header" href="#default-constructors">Default constructors</a></h1>
<p>C++ has a special concept of default constructors to support several scenarios
in which they are implicitly called.</p>
<pre><code class="language-cpp">class Person {
    int age;

public:
    // Default constructor
    Person() : age(0) {}
}
</code></pre>
<p>Rust does not have a notion of a default constructor in the same way as in C++.
Some of the uses cases are achieved via a different mechanism or with different
conventions, and others do not apply to Rust.</p>
<p>If a structure has a useful default value (such as would be constructed by a
default constructor in C++), then the type should provide
<a href="https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits">both</a>
a <code>new</code> method that takes no arguments and an implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code>
trait</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
   age: i32,
}

impl Person {
    pub const fn new() -&gt; Self {
        Self { age: 0 }
    }
}

impl Default for Person {
    fn default() -&gt; Self {
        Self::new()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implicit-initialization-of-class-members"><a class="header" href="#implicit-initialization-of-class-members">Implicit initialization of class members</a></h2>
<p>In C++ if a member is not explicitly initialized by a constructor, then it is
default-initialized. When the type of the member is a class, the
default-initialization invokes the default constructor.</p>
<p>In Rust, if all of the fields of a struct implement the <code>Default</code> trait, then an
implementation for the structure can be provided by the compiler.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
}

class Student {
  Person person;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The use of the derive macros in Rust is equivalent to writing the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
}

impl Default for Person {
    fn default() -&gt; Self {
        Self {
            age: Default::default()
        }
    }
}

struct Student {
    person: Person,
}

impl Default for Student {
    fn default() -&gt; Self {
        Self {
            person: Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike C++ where the default initialization value for integers is indeterminate,
in Rust the default value for the primitive integer and floating point types is
zero.</p>
<p>Deriving the <code>Default</code> trait has a similar effect on code concision as eliding
initialization in C++. In situations where all of the types implement the
<code>Default</code> trait, but only some of the fields should have their default values,
one can use <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update
syntax</a>
to define a constructor method without enumerating the values for all of the
fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
    favorite_color: Option&lt;String&gt;,
}

impl Student {
    pub fn with_favorite_color(color: String) -&gt; Self {
        Student {
            favorite_color: Some(color),
            ..Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implicit-initialization-of-array-values"><a class="header" href="#implicit-initialization-of-array-values">Implicit initialization of array values</a></h2>
<p>In C++, arrays without explicit initialization are default-initialized using the
default constructors.</p>
<p>In Rust, the value with which to initialize the array must be provided.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
};

int main() {
  Person people[3];
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    // std::array::from_fn provides the index to the callback
    let people: [Person; 3] = std::array::from_fn(|_| Default::default());
    // ...
}</code></pre></pre>
</div>
<p>If the type happens to be <a href="idioms/constructors//idioms/constructors/copy_and_move_constructors.html#trivially-copyable-types">trivially
copyable</a>,
then a shorthand can be used.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: [Person; 3] = [Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="container-element-initialization"><a class="header" href="#container-element-initialization">Container element initialization</a></h2>
<p>In C++, the default constructor could be used to implicitly define collection
types, such as <code>std::vector</code>. Before C++11 one value would be default
constructed, and the elements would be copy constructed from that initial
element. Since C++11, all elements are default constructed.</p>
<p>As with array initialization, the values must be explicitly specified in Rust.
The vector can be constructed from an array, enabling the same syntax as with
arrays.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;vector&gt;

class Person {
  int age;

public:
  Person() : age(0) {}
}

int main() {
  std::vector&lt;Person&gt; v(3);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    let people_arr: [Person; 3] = std::array::from_fn(|_| Default::default());
    let people: Vec&lt;Person&gt; = Vec::from(people_arr);
    // ...
}</code></pre></pre>
</div>
<p>If the type implements the <code>Clone</code> trait, then the array can be constructed
using the <code>vec!</code> macro. See the chapter on <a href="idioms/constructors/copy_constructors.html">copy
constructors</a> for more details on <code>Clone</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: Vec&lt;Person&gt; = vec![Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="implicit-initialization-of-local-variables"><a class="header" href="#implicit-initialization-of-local-variables">Implicit initialization of local variables</a></h2>
<p>In C++, the default constructor is used to perform default-initialization of
local variables that are not explicitly initialized.</p>
<p>In Rust, initialization of local variables is always explicit.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
};

int main() {
  Person person;
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let person = Person::default();
    // ...
}</code></pre></pre>
</div>
<h2 id="implicit-initialization-of-the-base-class-object"><a class="header" href="#implicit-initialization-of-the-base-class-object">Implicit initialization of the base class object</a></h2>
<p>In C++, the default constructor is used to initialize the base class object if
it no other constructor is specified.</p>
<pre><code class="language-cpp">class Base {
  int x;

public:
  Base() : x(0) {}
};

class Derived : Base {
public:
  // Calls the default constructor for Base
  Derived() {}
};
</code></pre>
<p>Since Rust does not have inheritance, there is no equivalent to this case.
See the chapter on <a href="idioms/constructors//idioms/data_modeling/inheritance_and_reuse.html">implementation
reuse</a> or the section on <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits
in the Rust book</a> for
alternatives.</p>
<h2 id="stdunique_ptr"><a class="header" href="#stdunique_ptr"><code>std::unique_ptr</code></a></h2>
<p>There are some additional cases where the <code>Default</code> trait is used in Rust, but
default constructors are not used for initialization in C++.</p>
<p>Rust's equivalent of smart pointers implement <code>Default</code> by delegating to the
<code>Default</code> implementation of the contained type.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
  age: i32,
}

fn main() {
    let b: Box&lt;Person&gt; = Default::default();
    // ...
}</code></pre></pre>
<p>This differs from the treatment of <code>std::unique_ptr</code> C++ because unlike <code>Box</code>,
<code>std::unique_ptr</code> is nullable, and so the default constructor for
<code>std:unique_ptr</code> produces a pointer that owns nothing. The equivalent type in
Rust is <code>Option&lt;Box&lt;Person&gt;&gt;</code>, for which the <code>Default</code> implementation produces
<code>None</code>.</p>
<h2 id="other-uses-of-default"><a class="header" href="#other-uses-of-default">Other uses of <code>Default</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>
makes use of <code>Default</code>, which makes getting a default value when the <code>Option</code>
does not contain a value more convenient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: Option&lt;i32&gt;) {
    let a: i32 = x.unwrap_or_default();
    // if x was None, then a is 0

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>In C++, <code>std::optional</code> does not have an equivalent method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-move-constructors"><a class="header" href="#copy-and-move-constructors">Copy and move constructors</a></h1>
<p>In both C++ and Rust, one rarely has to write copy or move constructors (or
their Rust equivalents) by hand. In C++ this is because the implicit definitions
are good enough for most purposes, especially when using smart pointers (i.e.,
following <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of
zero</a>). In Rust this
is because move semantics are the default, and the automatically derived
implementations of the <code>Clone</code> and <code>Copy</code> traits are good enough for most
purposes.</p>
<p>For the following C++ classes, the implicitly defined copy and move constructors
are sufficient. The equivalent in Rust uses a derive macro provided by the
standard library to implement the corresponding traits.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">#include &lt;string&gt;
</span><span class="boring">
</span>struct Age {
  unsigned int years;

  Age(unsigned int years) : years(years) {}

  // copy and move constructors and destructor
  // implicilty declared and defined
};

struct Person {
  Age age;
  std::string name;
  std::shared_ptr&lt;Person&gt; best_friend;

  Person(Age age,
         std::string name,
         std::shared_ptr&lt;Person&gt; best_friend)
      : age(age), name(name),
        best_friend(best_friend) {}

  // copy and move constructors and destructor
  // implicilty declared and defined
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Clone, Copy)]
struct Age {
    years: u32,
}

#[derive(Clone)]
struct Person {
    age: Age,
    name: String,
    best_friend: Rc&lt;Person&gt;,
}
<span class="boring">}</span></code></pre></pre>
</div>
<h2 id="user-defined-constructors"><a class="header" href="#user-defined-constructors">User-defined constructors</a></h2>
<p>On the other hand, the following example require a user-defined copy and move
constructor because it manages a resource (a pointer acquired from a C library).
The equivalent in Rust requires a custom implementation of the <code>Clone</code> trait.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t *);
void copy_widget(widget_t *dst, widget_t *src);

// widget.cc
class Widget {
  widget_t *widget;

public:
  Widget() : widget(alloc_widget()) {}

  Widget(const Widget &amp;other) : widget(alloc_widget()) {
    copy_widget(widget, other.widget);
  }

  Widget(Widget &amp;&amp;other) : widget(other.widget) {
    other.widget = nullptr;
  }

  ~Widget() {
    free_widget(widget);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod example {
</span>mod widget_ffi {
    // Models an opaque type.
    // See https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs
    #[repr(C)]
    pub struct CWidget {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(
            *mut u8,
            core::marker::PhantomPinned,
        )&gt;,
    }

    extern "C" {
        pub fn make_widget() -&gt; *mut CWidget;
        pub fn copy_widget(
            dst: *mut CWidget,
            src: *mut CWidget,
        );
        pub fn free_widget(ptr: *mut CWidget);
    }
}

use self::widget_ffi::*;

struct Widget {
    widget: *mut CWidget,
}

impl Widget {
    fn new() -&gt; Self {
        Widget {
            widget: unsafe { make_widget() },
        }
    }
}

impl Clone for Widget {
    fn clone(&amp;self) -&gt; Self {
        let widget = unsafe { make_widget() };
        unsafe {
            copy_widget(widget, self.widget);
        }
        Widget { widget }
    }
}

impl Drop for Widget {
    fn drop(&amp;mut self) {
        unsafe { free_widget(self.widget) };
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</div>
<p>Just as with how in C++ it is uncommon to need user-defined implementations for
copy and move constructors or user-defined implementations for destructors, in
Rust it is rare to need to implement the <code>Clone</code> and <code>Drop</code> traits by hand for
types that do not represent resources.</p>
<p>There is one exception to this. If the type has type parameters, it might be
desirable to implement <code>Clone</code> (and <code>Copy</code>) manually even if the clone should be
done field-by-field. See the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#how-can-i-implement-clone">standard library documentation of
<code>Clone</code></a>
and <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#how-can-i-implement-copy">of
<code>Copy</code></a>
for details.</p>
<h2 id="trivially-copyable-types"><a class="header" href="#trivially-copyable-types">Trivially copyable types</a></h2>
<p>In C++, a class type is trivially copyable when it has no non-trivial copy
constructors, move constructors, copy assignment operators, move assignment
operators and it has a trivial destructor. Values of a trivially copyable type
are able to be copied by copying their bytes.</p>
<p>In the first C++ example above, <code>Age</code> is trivially copyable, but <code>Person</code> is
not. This is because despite using a default copy constructor, the constructor
is not trivial because <code>std::string</code> and <code>std::shared_ptr</code> are not trivially
copyable.</p>
<p>Rust indicates whether types are trivially copyable with the <code>Copy</code> trait. Just
as with trivially copyable types in C++, values of types that implement <code>Copy</code>
in Rust can be copied by copying their bytes. Rust requires explicit calls to
the <code>clone</code> method to make copies of values of types that do not implement
<code>Copy</code>.</p>
<p>In the first Rust example above, <code>Age</code> implements the <code>Copy</code> trait but <code>Person</code>
does not. This is because neither <code>std::String</code> nor <code>Rc&lt;Person&gt;</code> implement
<code>Copy</code>. They do not implement <code>Copy</code> because they own data that lives on the
heap, and so are not trivially copyable.</p>
<p>Rust prevents implementing <code>Copy</code> for a type if any of its fields are not
<code>Copy</code>, but does not prevent implementing <code>Copy</code> for types that should not be
copied bit-for-bit due to their intended meaning, which is usually indicated by
a user-defined <code>Clone</code> implementation.</p>
<p>Rust does not permit the implementation of both <code>Copy</code> and <code>Drop</code> for the same
type. This aligns with the C++ standard's requirement that trivially copyable
types not implement a user-defined destructor.</p>
<h2 id="move-constructors"><a class="header" href="#move-constructors">Move constructors</a></h2>
<p>In Rust, all types support move semantics by default, and custom move semantics
cannot be (and do not need to be) defined. This is because what "move" means in
Rust is not the same as it is in C++. In Rust, moving a value means changing
what owns the value. In particular, there is no "old" object to be destructed
after a move, because the compiler will prevent the use of a variable whose
value has been moved.</p>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment operators</a></h2>
<p>Rust does not have a copy or move assignment operator. Instead, assignment
either moves (by transferring ownership), explicitly clones and then moves, or
implicitly copies and then moves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Box::&lt;u32&gt;::new(5);
    let y = x; // moves
    let z = y.clone(); // explicitly clones and then moves the clone
    let w = *y; // implicitly copies the content of the Box and then moves the copy
}</code></pre></pre>
<p>For situations where something like a user-defined copy assignment could avoid
allocations, the <code>Clone</code> trait has an additional method called <code>clone_from</code>. The
method is automatically defined, but can be overridden when implementing the
<code>Clone</code> trait to provide an efficient implementation.</p>
<p>The method is not used for normal assignments, but can be explicitly used in
situations where the performance of the assignment is significant and would be
improved by using the more efficient implementation, if one is defined.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: &amp;Vec&lt;u32&gt;) {
    let mut y = vec![0; x.len()];
    // ...
    y.clone_from(&amp;x);
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-concerns-and-copy"><a class="header" href="#performance-concerns-and-copy">Performance concerns and <code>Copy</code></a></h2>
<p>The decision to implement <code>Copy</code> should be based on the semantics of the type,
not on performance. If the size of objects being copied is a concern, then one
should instead use a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) or put the value on the heap
(<a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> or
<a href="https://doc.rust-lang.org/std/rc/index.html"><code>Rc&lt;T&gt;</code></a>). These approaches
correspond to passing by reference, or using a <code>std::unique_ptr</code>
<code>std::shared_ptr</code> in C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rule-of-threefivezero"><a class="header" href="#rule-of-threefivezero">Rule of three/five/zero</a></h1>
<h2 id="rule-of-three"><a class="header" href="#rule-of-three">Rule of three</a></h2>
<p>In C++ the rule of three is a rule of thumb that if a class has a user-defined
destructor, copy constructor or copy assignment operator, it probably should
have all three.</p>
<p>The corresponding rule for Rust is that if a type has a user-defined <code>Clone</code> or
<code>Drop</code> implementation, it probably needs both or to have no <code>Clone</code>
implementation at all.</p>
<p>This is for the same reason as the rule of three in C++: if a type has a
user-defined implementation for <code>Clone</code> or <code>Drop</code>, it is probably because the
type manages a resource, and both <code>Clone</code> and <code>Drop</code> will need to take special
actions for the resource.</p>
<h2 id="rule-of-five"><a class="header" href="#rule-of-five">Rule of five</a></h2>
<p>The rule of five in C++ states that if move semantics are needed for a type with
a user-defined copy constructor or copy assignment operator, then a user-defined
move constructor and move assignment should also be provided, because no
implicit move constructor or move assignment operator will be generated.</p>
<p>In Rust, this rule does not apply because of the <a href="idioms/constructors/copy_and_move_constructors.html#move-constructors">difference in move semantics
between C++ and Rust.</a></p>
<h2 id="rule-of-zero"><a class="header" href="#rule-of-zero">Rule of zero</a></h2>
<p>The rule of zero states that classes with user-defined copy/move constructors,
assignment operators, and destructors should deal only with ownership, and other
classes should not have those constructors or destructors. In practice, most
classes should make use of types from the STL (<code>shared_ptr</code>, <code>vector</code>, etc.) for
dealing with ownership concerns so that the implicitly defined copy and move
constructors are sufficient.</p>
<p>In Rust, the same is true...</p>
<p>TODO Move the following to a separate chapter on type equivalents and link to it
here.</p>
<p>The following table maps the ownership-managing classes from C++ to equivalents
types in Rust:</p>
<div class="table-wrapper"><table><thead><tr><th>C++ name</th><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>Owned in-place</td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td>Single ownership on heap</td><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>std::box::Box&lt;T&gt;</code></td></tr>
<tr><td>Shared ownership on heap</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;T&gt; or std::sync::Arc&lt;T&gt;</code></td></tr>
<tr><td>Shared ownership on heap of mutable value</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;RefCell&lt;T&gt;&gt; or std::sync::Arc&lt;RefCell&lt;T&gt;&gt;</code></td></tr>
<tr><td>Const observation pointer</td><td><code>const *T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable observation pointer</td><td><code>*T</code></td><td><code>&amp;mut T</code></td></tr>
<tr><td>Const reference</td><td><code>const &amp;T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable reference</td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr>
</tbody></table>
</div>
<p>There are also types that manage ownership while also providing other
functionality...</p>
<p>In some cases, multiple types might be needed to achieve the same effect. A C++
<code>shared_ptr</code> allows all of the sharing owners to mutate the object, even if
there is more than one owner. In Rust, this is not allowed. Instead, the <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">type
<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> must be
used</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separate-construction-and-initialization"><a class="header" href="#separate-construction-and-initialization">Separate construction and initialization</a></h1>
<p>A second common use is for partially constructed objects, e.g., in codebases
that make initialization a separate step from construction.</p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;memory&gt;

struct Movie {
    std::string title;
};

class Person {
	std::shared_ptr&lt;Movie&gt; favorite_movie;
public:
    Person() : favorite_movie(nullptr) {}

    Person&amp; init(std::shared_ptr&lt;Movie&gt; favorite_movie) {
        this-&gt;favorite_movie = favorite_movie;

        return *this;
    }
};
</code></pre>
<p>This pattern may be used for one of two reasons:</p>
<ul>
<li>A desire to incrementally initialize the object using some kind of builder
pattern. This usually involves returning a reference to the object so that the
initialization methods can be chained together, as <code>init</code> does in the above
example.</li>
<li>A desire to re-use allocated objects, in which case the class usually also has
some kind of <code>clear()</code> method to prepare the object to be reused. This is most
common in embedded programming as an alternative to dynamic allocation.</li>
</ul>
<p>In Rust, the normal approach to the first reason is to use a builder pattern.
This involves defining a second type to represent the partially constructed
object, where each field in the original object of type <code>T</code> has type <code>Option&lt;T&gt;</code>
in the builder. For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
    name: String,
}

struct PersonBuilder {
    age: Option&lt;i32&gt;,
    name: Option&lt;String&gt;,
}

impl PersonBuilder {
    fn new() -&gt; PersonBuilder {
        PersonBuilder { age: None, name: None }
    }

    fn age(&amp;mut self, age: i32) -&gt; &amp;mut Self {
        self.age = Some(age);
        self
    }

    fn name(&amp;mut self, name: String) -&gt; &amp;mut Self {
        self.name = Some(name);
        self
    }

    fn build(&amp;self) -&gt; Option&lt;Person&gt; {
        Some(Person {
            age: self.age?,
            name: match self.name {
                Some(ref name) =&gt; name.clone(),
                None =&gt; return None,
            },
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern is sufficiently common that there are libraries to support it, such
as the <a href="https://crates.io/crates/derive_builder"><code>derive_builder</code> crate</a>. Using
that crate, the above example would just be</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Person {
    age: i32,
    name: String,
}</code></pre>
<p>and the resulting API would include additional features, such as the <code>build</code>
method returning a <code>Result</code> with an informative error, rather than just <code>None</code>,
when not all of required fields are set.</p>
<p>If there is a reasonable default value for the object, then instead of the
builder pattern, the <code>Default</code> trait can be implemented, and <a href="idioms/constructors//idioms/constructors/default_constructors.html#equivalents-in-rust">values can be
constructed based on a default
value</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructors-and-resource-cleanup"><a class="header" href="#destructors-and-resource-cleanup">Destructors and resource cleanup</a></h1>
<p>In C++, destructors are defined by providing a special member function. To
achieve the equivalent in Rust, implement the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code>
trait</a>.</p>
<p>For an example, see <a href="idioms//idioms/constructors/copy_and_move_constructors.html#user-defined-constructors">the chapter on copy and move
constructors</a>.</p>
<p><code>Drop</code> implementations play the same role as destructors in C++ for types that
manage resources. That is, they enable cleanup of resources owned by the value
at the end of the value's lifetime (i.e., <a href="idioms//idioms/raii.html">RAII</a>).</p>
<p>In Rust the <code>Drop::drop</code> method is called the "destructor", but we will refer to
it as "the drop method" here, to clearly distinguish between it and C++
destructors.</p>
<h2 id="lifetimes-and-destructors"><a class="header" href="#lifetimes-and-destructors">Lifetimes and destructors</a></h2>
<p>C++ destructors are called in reverse order of construction when variables go out
of scope, of for dynamically allocated objects, when they are deleted. Because
of how move constructors work, this includes destructors of moved objects.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A {
    int id;

    A(int id) : id(id) {}

    // copy constructor
    A(A&amp; other) : id(other.id) {}

    // move constructor
    A(A&amp;&amp; other) : id(other.id) {
        other.id = 0;
    }

    // deconstructor
    ~A() {
        std::cout &lt;&lt; id &lt;&lt; std::endl;
    }
};

int accept(A x) {
    return x.id;
} // the destructor of x is called after the return expression is evaluated

// Prints:
// 2
// 3
// 0
// 1
int main() {
    A x(1);
    A y(2);

    accept(std::move(y));

	A z(3);

    return 0;
}
</code></pre>
<p>In Rust, the drop order is similar to that of C++ (reverse order of
declaration). If additional specific details about the drop order are needed
(e.g., for writing unsafe code), the full rules for the drop order are described
in <a href="https://doc.rust-lang.org/reference/destructors.html">the language
reference</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct A {
    id: i32,
}

impl Drop for A {
    fn drop(&amp;mut self) {
        println!("{}", self.id)
    }
}

fn accept(x: A) -&gt; i32 {
    return x.id;
}

// Prints:
// 2
// 3
// 1
fn main() {
    let x = A { id: 1 };
    let y = A { id: 2 };

    accept(y);

    let z = A { id: 3 };
}</code></pre></pre>
<p>One particular difference between C++ and Rust is that after ownership of <code>y</code> is
moved into the function <code>acccept</code>, there is no additional object remaining, and
so there is no additional <code>Drop::drop</code> call (which in the C++ example prints <code>0</code>).</p>
<p>Rust's drop methods do run when leaving scope due to a panic, though not if the
panic occurs in a destructor that was called in response to an initial panic.</p>
<h2 id="early-cleanup-and-explicitly-destroying-values"><a class="header" href="#early-cleanup-and-explicitly-destroying-values">Early cleanup and explicitly destroying values</a></h2>
<p>In C++ you can explicitly destroy an object. This is mainly useful for
situations where placement new has been used to allocate the object at a
specific memory location, and so the destructor will not be implicitly called.</p>
<p>However, once the destructor has been explicitly called, <a href="https://eel.is/c++draft/class.dtor#note-8">it may not be called
again, even implicitly</a>. Thus the
destructor can't be used for early cleanup. Instead, either the class must be
designed with a separate cleanup method that releases the resources but leaves
the object in a state where the destructor can be called or the function using
the object must be structured so that the variable goes out of scope at the
desired time.</p>
<p>In Rust, values can be dropped early for early cleanup by using
<a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>. This works
because (<a href="idioms//idioms/constructors/copy_and_move_constructors.html#trivially-copyable-types">for non-<code>Copy</code>
types</a>)
ownership of the object is actually transferred to <code>std::mem::drop</code> function,
and so <code>Drop::drop</code> is called at the end of <code>std::mem::drop</code>.</p>
<p>Thus, <code>std::mem::drop</code> can be used for early cleanup of resources without having
to restructure a function to force variables out of scope early.</p>
<p>For example, the following allocates a large vector on the heap, but explicitly
drops it before allocating a second large vector on the heap, reducing the
overall memory usage.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![0u32; 100000];
    // ... use v

    std::mem::drop(v);
    // can no longer use v here

    let v2 = vec![0u32; 100000];
    // ... use v2
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="out-parameters"><a class="header" href="#out-parameters">Out parameters</a></h1>
<p>There are several idioms in C++ that involve the use of out parameters: passing
pointers or references to functions for the function to mutate to provide its
results.</p>
<p>The chapters in this section address idiomatic ways to achieve the same goals
that out parameters are used for in C++. Many of the Rust idioms resemble the
recommended alternatives to out parameters when programming against newer C++
standards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h1>
<p>One idiom for returning multiple values from a function or method in C++ is to
pass in references to which the values can be assigned.</p>
<p>There are several reasons why this idiom might be used:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, or</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic translation of this program into Rust makes use of either
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> or a named
structure for the return type.</p>
<div class="comparison">
<pre><code class="language-cpp">void get_point(int &amp;x, int &amp;y) {
  x = 5;
  y = 6;
}

int main() {
  int x, y;
  get_point(x, y);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn get_point() -&gt; (i32, i32) {
    (5, 6)
}

fn main() {
    let (x, y) = get_point();
    // ...
}</code></pre></pre>
</div>
<p>Rust has a dedicated tuple syntax and supports pattern matching with <code>let</code>
bindings in part to support use cases like this one.</p>
<h2 id="problems-with-the-direct-transliteration"><a class="header" href="#problems-with-the-direct-transliteration">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but Rust requires the initialization of the variables before they can be
passed to a function. The resulting program is not idiomatic Rust.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOIMATIC RUST
fn get_point(x: &amp;mut i32, y: &amp;mut i32) {
    *x = 5;
    *y = 6;
}

fn main() {
    let mut x = 0; // initliazed to arbitrary values
    let mut y = 0;
    get_point(&amp;mut x, &amp;mut y);
    // ...
}</code></pre></pre>
<p>This approach requires assigning arbitrary initial values to the variables and
making the variables mutable, both of which make it harder for the compiler to
help with avoiding programming errors.</p>
<p>Additionally, the Rust compiler is tuned for optimizing the idiomatic version of
the program, and produces a significantly faster binary for that version.</p>
<p>In situations where the performance of memory allocation is a concern (such as
when it is necessary to reuse entire buffers in memory), the trade-offs may be
different. That situation is discussed in the chapter on <a href="idioms/out_params//idioms/out_params/pre-allocated_buffers.html">pre-allocated
buffers</a>.</p>
<h2 id="similarities-with-idiomatic-c-since-c11"><a class="header" href="#similarities-with-idiomatic-c-since-c11">Similarities with idiomatic C++ since C++11</a></h2>
<p>In C++11 and later, <code>std::pair</code> and <code>std::tuple</code> are available for returning
multiple values instead of assigning to reference parameters.</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;utility&gt;

std::pair&lt;int, int&gt; get_point() {
  return std::pair&lt;int, int&gt;(5, 6);
}

int main() {
  int x, y;
  std::tie(x, y) = get_point();
  // ...
}
</code></pre>
<p>This more closely aligns with the normal Rust idiom for returning multiple
values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-return-values"><a class="header" href="#optional-return-values">Optional return values</a></h1>
<p>One idiom in C++ for optionally producing a result from a method or function is
to use a reference parameter along with a boolean or integer return value to
indicate whether the result was produced. This might be done for the same
reasons as for using <a href="idioms/out_params//idioms/out_params/multiple_return.html">out parameters for multiple return
values</a>:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, and</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic Rust approach for optionally returning a value is to return a
value of type <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

bool safe_divide(unsigned int dividend,
                 unsigned int divisor,
                 unsigned int &amp;quotient) {
  if (divisor != 0) {
    quotient = dividend / divisor;
    return true;
  } else {
    return false;
  }
}

void go(unsigned int dividend,
        unsigned int divisor) {
  unsigned int quotient;
  if (safe_divide(dividend, divisor, quotient)) {
    std::cout &lt;&lt; quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn safe_divide(
    dividend: u32,
    divisor: u32,
) -&gt; Option&lt;u32&gt; {
    if divisor != 0 {
        Some(dividend / divisor)
    } else {
        None
    }
}

fn go(dividend: u32, divisor: u32) {
    match safe_divide(dividend, divisor) {
        Some(quotient) =&gt; {
            println!("{}", quotient);
        }
        None =&gt; {
            println!("Division failed!");
        }
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
</div>
<p>When there is useful information to provide in the failing case, the <a href="https://doc.rust-lang.org/std/result/"><code>Result</code>
type</a> can be used instead. The <a href="idioms/out_params//idioms/exceptions.html">chapter
on error handling</a> describes the use of <code>Result</code>.</p>
<h2 id="returning-a-pointer"><a class="header" href="#returning-a-pointer">Returning a pointer</a></h2>
<p>When the value being returned is a pointer, another common idiom in C++ is to
use <code>nullptr</code> to represent the optional case. In the Rust translation of that
idiom, <code>Option</code> is also used, along with a reference type, such as <code>&amp;</code> or <code>Box</code>.
See <a href="idioms/out_params//idioms/null/sentinel_values.html#nullptr">the chapter on using <code>nullptr</code> as a sentinel
value</a> for more details.</p>
<h2 id="problems-with-the-direct-transliteration-1"><a class="header" href="#problems-with-the-direct-transliteration-1">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but the resulting code is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOIMATIC RUST
fn safe_divide(dividend: u32, divisor: u32, quotient: &amp;mut u32) -&gt; bool {
    if divisor != 0 {
        *quotient = dividend / divisor;
        true
    } else {
        false
    }
}

fn go(dividend: u32, divisor: u32) {
    let mut quotient: u32 = 0; // initliazed to arbitrary value
    if safe_divide(dividend, divisor, &amp;mut quotient) {
        println!("{}", quotient);
    } else {
        println!("Division failed!");
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<p>This shares the same problems as with using out-parameters for <a href="idioms/out_params//idioms/out_params/multiple_return.html#problems-with-the-direct-transliteration">multiple return
values</a>.</p>
<h2 id="similarities-with-c-since-c17"><a class="header" href="#similarities-with-c-since-c17">Similarities with C++ since C++17</a></h2>
<p>C++17 and later offer <code>std::optional</code>, which can be used to express optional
return values in a way similar to the idiomatic Rust example.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;optional&gt;

std::optional&lt;unsigned int&gt; safe_divide(unsigned int dividend,
                                        unsigned int divisor) {
  if (divisor != 0) {
    return std::optional&lt;unsigned int&gt;(dividend / divisor);
  } else {
    return std::nullopt;
  }
}

void go(unsigned int dividend, unsigned int divisor) {
  if (auto quotient = safe_divide(dividend, divisor)) {
    std::cout &lt;&lt; *quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<h2 id="helpful-option-utilities"><a class="header" href="#helpful-option-utilities">Helpful <code>Option</code> utilities</a></h2>
<p>When the <code>None</code> case really is an edge case, the <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let-else</code>
syntax</a>
can be used to make that clearer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: u32, divisor: u32) {
    let Some(quotient) = safe_divide(dividend, divisor) else {
        println!("Division failed!");
        return;
    };
    println!("{}", quotient);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>If there is a default value that should be used in the <code>None</code> case, the
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>Option::unwrap_or</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option::unwrap_or_else</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>,
or
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
methods can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn expensive_computation() -&gt; u32 {
    // ...
<span class="boring">   0
</span>}

fn go(dividend: u32, divisor: u32) {
    // If None, returns the given value.
    let result = safe_divide(dividend, divisor).unwrap_or(0);

    // If None, returns the result of calling the given function.
    let result2 = safe_divide(dividend, divisor).unwrap_or_else(expensive_computation);

    // If None, returns Default::default(), which is 0 for u32.
    let result3 = safe_divide(dividend, divisor).unwrap_or_default();

    // If None, panics. Prefer the other methods!
    // let result3 = safe_divide(dividend, divisor).unwrap();
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>In performance-sensitive code where you have manually checked that the result is
guaranteed to be <code>Some</code>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_unchecked"><code>Option::unwrap_unchecked</code></a>
can be used, but is an unsafe method.</p>
<p>There are <a href="https://doc.rust-lang.org/std/option/#boolean-operators">additional utility
methods</a> that enable
concise handling of <code>Option</code> values, which this book covers in the chapter on
<a href="idioms/out_params//idioms/exceptions.html">exceptions and error handling</a>.</p>
<h2 id="an-alternative-approach"><a class="header" href="#an-alternative-approach">An alternative approach</a></h2>
<p>An alternative approach in Rust to returning optional values is to require that
the caller of a function prove that the value with which they call a function
will not result in the failing case.</p>
<p>For the above safe division example, this involves the caller guaranteeing that
the provided divisor is non-zero. In the following example this is done with a
dynamic check. In other contexts the evidence needed may be available
statically, provided from callers further upstream, or used more than once. In
those cases, this approach reduces both runtime cost and code complexity.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::num::NonZero;

fn safe_divide(dividend: u32, divisor: NonZero&lt;u32&gt;) -&gt; u32 {
    // This is more efficient because the overflow check is skipped.
    dividend / divisor
}

fn go(dividend: u32, divisor: u32) {
    let Ok(safe_divisor) = NonZero::try_from(divisor) else {
        println!("Can't divide!");
        return;
    };

    let quotient = safe_divide(dividend, safe_divisor);
    println!("{}", quotient);
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-allocated-buffers"><a class="header" href="#pre-allocated-buffers">Pre-allocated buffers</a></h1>
<p>There are situations where large quantities of data need to be returned from a
function that will be called repeatedly, so that incurring the copies involved
in returning by value or repeated heap allocations would be cost prohibitive.
Some of these situations include:</p>
<ul>
<li>performing file or network IO,</li>
<li>communicating with graphics hardware,</li>
<li>communicating with hardware on embedded systems, or</li>
<li>implementing cryptography algorithms.</li>
</ul>
<p>In these situations, C++ programs tend to pre-allocate buffers that are reused
for all calls. This also usually enables allocating the buffer on the stack,
rather than having to perform dynamic allocation. For example,</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;

int main() {
    std::ifstream file("/path/to/file");
    if (!file.is_open()) {
        return -1;
    }

    char buf[1024];
    while (file.good()) {
        file.read(buf, sizeof buf);
        std::streamsize count = file.gcount();

        // use data in buf
    }

    return 0;
}
</code></pre>
<p>An equivalent Rust program is:</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{Read, BufReader};

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut f = BufReader::new(File::open("/path/to/file")?);

    let mut buf = [0u8; 1024];

    while let count = f.read(&amp;mut buf)? {
        if count == 0 {
            break;
        }
        // use data in buf
    }

    Ok(())
}</code></pre></pre>
<p>The major difference between the C++ program and the Rust program is that in the
Rust program the buffer must be initialized before it can be used. In most
cases, this one-time initialization cost is not significant. When it is, unsafe
Rust is required to avoid the initialization.</p>
<p>The technique makes use of
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>std::mem::MaybeUninit</code></a>.
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#examples">Examples of safe usage of
<code>MaybeUninit</code></a>
are given in the API documentation for the type.</p>
<p>The IO API in stable Rust does not include support for <code>MaybeUninit</code>. Instead,
there is a <a href="idioms/out_params/pre-allocated_buffers.html#upcoming-changes-and-borrowedbuf">new safe API being developed</a>
that will enable avoiding initialization without requiring unsafe Rust in code
that uses the API.</p>
<p>If the callee might need to grow the provided buffer and dynamic allocation is
allowed, then a <code>&amp;mut Vec&lt;T&gt;</code> can be used instead of <code>&amp;mut [T]</code>. This is similar
to providing a <code>std::vector&lt;T&gt;&amp;</code> in C++. To avoid unnecessary allocations, the
vector can be created using <code>Vec::&lt;T&gt;::with_capacity(n)</code>.</p>
<h2 id="a-note-on-reading-files"><a class="header" href="#a-note-on-reading-files">A note on reading files</a></h2>
<p>While the examples here use IO to demonstrate re-using pre-allocated buffers,
there are higher-level interfaces available for reading from <code>File</code>s, both from
the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> traits, and
from convenience functions in
<a href="https://doc.rust-lang.org/std/io/index.html#functions-1"><code>std::io</code></a> and in
<a href="https://doc.rust-lang.org/std/fs/index.html#functions-1"><code>std::fs</code></a>.</p>
<p>The techniques described here are useful, however, in other situations where a
reusable buffer is required, such as when interacting with hardware APIs, when
using existing C or C++ libraries, or when implementing algorithms that produce
larges amount of data in chunks, such as cryptography algorithms.</p>
<h2 id="upcoming-changes-and-borrowedbuf"><a class="header" href="#upcoming-changes-and-borrowedbuf">Upcoming changes and <code>BorrowedBuf</code></a></h2>
<p>The Rust community is refining approaches to working with uninitialized buffers.
If you can use the nightly branch of Rust, you can use
<a href="https://doc.rust-lang.org/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a> to
achieve the same results as when using slices of <code>MaybeUninit</code>, but without
having to write any unsafe code yourself. The IO APIs for avoiding unnecessary
initialization use <code>BorrowedBuf</code> instead of slices of <code>MaybeUninit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-identity"><a class="header" href="#object-identity">Object identity</a></h1>
<p>In C++ the pointer to an object is sometimes used to represent its identity in
terms of the logic of a program.</p>
<p>In some cases, this is a standard optimization, such as when implementing the
copy assignment operator.</p>
<p>In other cases the pointer value is used as a logical identity to distinguish
between specific instances of an object that otherwise have the same properties.
For example, representing a labeled graph where there may be distinct nodes that
have the same label.</p>
<p>In Rust, some of these cases are not applicable, and others cases are typically
handled by instead by implementing a synthetic notion of identity for the
values.</p>
<h2 id="overloading-copy-assignment-and-equality-comparison-operators"><a class="header" href="#overloading-copy-assignment-and-equality-comparison-operators">Overloading copy assignment and equality comparison operators</a></h2>
<p>For example, when implementing the copy-assignment operator, one might
short-circuit when the copied object and the assignee are the same.
Not that in this use the pointer values are not stored.</p>
<pre><code class="language-cpp">struct Person
{
    std::string name;
    // many other expensive-to-copy fields

    Person&amp; operator=(const Person&amp; other) {
        // compare object identity first
        if (this != &amp;other) {
            this.name = other.name;
            // copy the other expensive-to-copy fields
        }

        return *this;
    }
};
</code></pre>
<p>This kind of optimization is unnecessary when implementing <a href="idioms//idioms/constructors/copy_and_move_constructors.html#assignment-operators">Rust's equivalent to
the copy assignment
operator</a>
<code>Clone::clone_from</code>. The type of <code>Clone::clone_from</code> prevents the same object
from being passed as both arguments, because one of the arguments is a mutable
reference, which is exclusive, and so prevents the other reference argument from
referring to the same object.</p>
<p>In cases in C++ where most comparisons are between an object and itself (e.g.,
the object's primary use is to be stored in a hash set), and comparison of
unequal objects is expensive, comparing object identity might be used as
optimization for the equality comparison operator overload.</p>
<pre><code class="language-cpp">struct Person
{
    std::string name;
    // many other expensive-to-compare fields
};


bool operator==(const Person&amp; lhs, const Person&amp; rhs) {
    // compare object identity first
    if (&amp;lhs == &amp;rhs) {
        return true;
    }

    // compare the other expensive-to-compare fields

    return true;
}
</code></pre>
<p>For supporting similar operations in Rust,
<a href="https://doc.rust-lang.org/std/ptr/fn.eq.html"><code>std::ptr::eq</code></a> can be used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    // many other expensive-to-compare fields
}

impl PartialEq for Person {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if std::ptr::eq(self, other) {
            return true;
        }
        // compare other expensive-to-compare fields

        true
    }
}

impl Eq for Person {}
<span class="boring">}</span></code></pre></pre>
<h2 id="distinguishing-between-values-in-a-relational-structure"><a class="header" href="#distinguishing-between-values-in-a-relational-structure">Distinguishing between values in a relational structure</a></h2>
<p>The other use is when relationships between values are represented using a data
structure external to the values, such as when representing a labeled graph in
which multiple nodes might share the same label, but have edges between
different sets of other nodes. This differs from the earlier case because the
pointer value is preserved.</p>
<p>One real-world example of this is in the LLVM codebase, where occurrences of
declarations, statements, and expressions in the AST are distinguished by object
identity. For example, variable expressions (<code>class DeclRefExpr</code>) contain the
<a href="https://github.com/llvm/llvm-project/blob/ddc48fefe389789f64713b5924a03fb2b7961ef3/clang/include/clang/AST/Expr.h#L1265C1-L1275C16">pointer to the occurrence of the declaration to which the variable
refers</a>.</p>
<p>Similarly, when comparing whether two variable declarations represent
declarations of the same variable, <a href="https://github.com/llvm/llvm-project/blob/aa33c095617400a23a2b814c4defeb12e7761639/clang/lib/AST/Stmt.cpp#L1476-L1485">a pointer to some canonical <code>VarDecl</code> is
used</a>:</p>
<pre><code class="language-cpp">VarDecl *VarDecl::getCanonicalDecl();

bool CapturedStmt::capturesVariable(const VarDecl *Var) const {
  for (const auto &amp;I : captures()) {
    if (!I.capturesVariable() &amp;&amp; !I.capturesVariableByCopy())
      continue;
    if (I.getCapturedVar()-&gt;getCanonicalDecl() == Var-&gt;getCanonicalDecl())
      return true;
  }

  return false;
}
</code></pre>
<p>This kind of use is often discouraged in C++ because of the risk of
use-after-free bugs, but might be used in performance sensitive applications
where either storing the memory to represent the mapping or the additional
indirection to resolve an entity's value from its identity is cost prohibitive.</p>
<p>In Rust it is generally preferred to represent the identity of the objects with
synthetic identifiers. This is in part as a technique for modeling
self-referential data structures.</p>
<p>As an example, one popular Rust graph library
<a href="https://docs.rs/petgraph/latest/petgraph/">petgraph</a> uses <code>u32</code> as its default
node identity type. This incurs the cost of an extra call to dereference the
synthetic identifier to the label of the represented node as well as the extra
memory required to store the mapping from nodes to labels.</p>
<p>A simplified graph representation using the same synthetic identifier technique
would look like the following, which represents the node identities by their
index in the vectors that represent the labels and the edges.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Blue
}

struct Graph {
    /// Maps from node id to node labels, which here are colors.
    nodes_labels: Vec&lt;Color&gt;,

    /// Maps from node id to adjacent nodes ids.
    edges: Vec&lt;Vec&lt;usize&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If performance requirements make the use of synthetic identifiers unacceptable,
then it may be necessary to use prevent the value from being moved by using
<a href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code></a>, which is similar to
deleting the move constructor in C++.</p>


                        <a class="feedback-link" href="https://forms.gle/YqpaAvir8QbUY21H6">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
