<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type equivalents - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-equivalents"><a class="header" href="#type-equivalents">Type equivalents</a></h1>
<p>The type equivalents listed in this document are equivalent for the purposes of
programming in Rust as one would program in C++. They are not necessarily
equivalent in terms of being useful for interacting with C or C++ programs via
an FFI. For types that are useful for interoperability with C or C++, see the
<a href="https://doc.rust-lang.org/std/ffi/index.html">Rust <code>std::ffi</code> module
documentation</a> and the <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI
documentation in the Rustonomicon</a>.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer types</a></h3>
<p>In C++, many of the integer types (like <code>int</code> and <code>long</code>) have implementation
defined widths. In Rust, integer types are always specified with their widths,
much like the types in <code>&lt;cstdint&gt;</code> in C++. When it isn't clear what integer type
to use, <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">it is common to default to <code>i32</code>, which is the type that Rust defaults
to for integer
literals</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>uint8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>uint16_t</code></td><td><code>u16</code></td></tr>
<tr><td><code>uint32_t</code></td><td><code>u32</code></td></tr>
<tr><td><code>uint64_t</code></td><td><code>u64</code></td></tr>
<tr><td><code>int8_t</code></td><td><code>i8</code></td></tr>
<tr><td><code>int16_t</code></td><td><code>i16</code></td></tr>
<tr><td><code>int32_t</code></td><td><code>i32</code></td></tr>
<tr><td><code>int64_t</code></td><td><code>i64</code></td></tr>
<tr><td><code>size_t</code></td><td><code>usize</code></td></tr>
<tr><td></td><td><code>isize</code></td></tr>
</tbody></table>
</div>
<p>In C++ <code>size_t</code> is conventionally used only for sizes and offsets. The same is
true in Rust for <code>usize</code>, which is the pointer-sized integer type. The <code>isize</code>
type is the signed equivalent of <code>usize</code> and has no direct equivalent in C++.
The <code>isize</code> type is typically only used to represent pointer offsets.</p>
<h3 id="floating-point-types"><a class="header" href="#floating-point-types">Floating point types</a></h3>
<p>As with integer types in C++, the floating point types <code>float</code>, <code>double</code>, and
<code>long double</code> have implementation defined widths. C++23 introduced types
guaranteed to be IEEE 754 floats of specific widths. Of those, <code>float32_t</code> and
<code>float64_t</code> correspond to what is usually expected from <code>float</code> and <code>double</code>.
Rust's floating point types are analogous to these.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>float16_t</code></td><td></td></tr>
<tr><td><code>float32_t</code></td><td><code>f32</code></td></tr>
<tr><td><code>float64_t</code></td><td><code>f64</code></td></tr>
<tr><td><code>float128_t</code></td><td></td></tr>
</tbody></table>
</div>
<p>The Rust types analogous to <code>float16_t</code> and <code>float128_t</code> (<code>f16</code> and <code>f128</code>) are
<a href="https://github.com/rust-lang/rust/issues/116909">not yet available in stable
Rust</a>.</p>
<h3 id="raw-memory-types"><a class="header" href="#raw-memory-types">Raw memory types</a></h3>
<p>In C++ pointers to or arrays of <code>char</code>, <code>unsigned char</code>, or <code>byte</code> are used to
represent raw memory. In Rust, arrays (<code>[u8; N]</code>), vectors (<code>Vec&lt;u8&gt;</code>), or
slices (<code>&amp;[u8]</code>) of <code>u8</code> are used to accomplish the same goal. However,
accessing the underlying memory of another Rust value in that way requires
unsafe Rust. There are <a href="TODO">libraries</a> for creating safe wrappers around that
kind of access for purposes such as serialization or interacting with hardware.</p>
<h3 id="character-and-string-types"><a class="header" href="#character-and-string-types">Character and string types</a></h3>
<p>The C++ <code>char</code> or <code>wchar_t</code> types have implementation defined widths. Rust does
not have an equivalent to these types. When working with string encodings in
Rust one would use unsigned integer types where one would use the fixed width
character types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>char8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u16</code></td></tr>
</tbody></table>
</div>
<p>The Rust <code>char</code> type represents a Unicode scalar value. Thus, a Rust <code>char</code> is
the same size as a <code>u32</code>. For working with characters in Rust strings (which are
guaranteed to be valid UTF-8), the <code>char</code> type is appropriate. For representing
a byte, one should instead use <code>u8</code>.</p>
<p>The Rust standard library includes a type for UTF-8 strings and string slices:
<code>String</code> and <code>&amp;str</code>, respectively. Both types guarantee that represented strings
are valid UTF-8. The Rust <code>char</code> type is appropriate for representing elements
of a <code>String</code>.</p>
<p>Because <code>str</code> (without the reference) is a slice, it is unsized and therefore
must be used behind a pointer-like construct, such as a reference or box. For
this reason, string slices are often described as <code>&amp;str</code> instead of <code>str</code> in
documentation, even though they can also be used as <code>Box&lt;str&gt;</code>, <code>Rc&lt;str&gt;</code>, etc.</p>
<p>Rust also includes types for platform-specific string representations and slices
of those strings:
<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a>
and <code>&amp;std::ffi::OsStr</code>. While these strings use the OS-specific representation,
to use one with the Rust FFI, it must still be converted to a
<a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a>.</p>
<p>Unlike C++ which has <code>std::u16string</code>, Rust has no specific representation for
UTF-16 strings. Something like <code>Vec&lt;u16&gt;</code> can be used, but the type will not
guarantee that its contents are a valid UTF-16 string. Rust does provide a
mechanisms for converting <code>String</code> to and from a UTF-16 encoding
(<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.encode_utf16"><code>String::encode_utf16</code></a>
and
<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a>,
among others) as well as similar mechanisms for accessing the underlying UTF-8
encoding
(https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8).</p>
<div class="table-wrapper"><table><thead><tr><th>Purpose</th><th>Rust type</th></tr></thead><tbody>
<tr><td>representing text</td><td><code>String</code> and <code>&amp;str</code></td></tr>
<tr><td>representing bytes</td><td>vectors, arrays, or slices of <code>u8</code></td></tr>
<tr><td>interacting with OS</td><td><code>OsString</code> and <code>&amp;OsStr</code></td></tr>
<tr><td>representing UTF-8</td><td><code>String</code></td></tr>
<tr><td>representing UTF-16</td><td>use <a href="TODO">a library</a></td></tr>
</tbody></table>
</div>
<h3 id="boolean-types"><a class="header" href="#boolean-types">Boolean types</a></h3>
<p>The <code>bool</code> type in Rust is analogous to the <code>bool</code> type in C++. Unlike C++, Rust
makes <a href="https://doc.rust-lang.org/reference/types/boolean.html">guarantees about the size, alignment, and bit pattern used to represent
values of the <code>bool</code>
type</a>.</p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<p>The following table maps the ownership-managing classes from C++ to equivalents
types in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Use</th><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>Owned</td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td>Single owner, dynamic storage</td><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>Box&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::sync::Arc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><code>std::rc::Rc&lt;std::cell::RefCell&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, thread-safe</td><td><code>std::shared_ptr&lt;std::mutex&lt;T&gt;&gt;</code></td><td><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html"><code>std::sync::Arc&lt;std::mutex::Mutex&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Const reference</td><td><code>const &amp;T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable reference</td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr>
<tr><td>Const observer pointer</td><td><code>const *T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable observer pointer</td><td><code>*T</code></td><td><code>&amp;mut T</code></td></tr>
</tbody></table>
</div>
<p>In C++, the thread safety of <code>std::shared_ptr</code> is more nuanced than it appears
in this table (e.g., some uses may require <code>std::atomic</code>). However, in safe Rust
the compiler will prevent the incorrect use of the shared owner types.</p>
<p>Unlike with C++ references, Rust can have references-to-references. Rust
references are more like observer pointers than they are like C++ references.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>Both C++ and Rust containers own their elements. However, in both the element
type may be a non-owning type, such as a pointer in C++ or a reference in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>std::vector&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::array&lt;T, N&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.array.html"><code>[T; N]</code></a></td></tr>
<tr><td><code>std::list&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>std::collections::LinkedList&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::deque&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::stack&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>std::collections::BTreeMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::unordered_map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>std::collections::HashMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>std::collections::BTreeSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::unordered_set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>std::collections::HashSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::priority_queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html"><code>std::collections::BinaryHeap&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::span&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>&amp;[T]</code></a></td></tr>
</tbody></table>
</div>
<p>For maps and sets instead of the container being parameterized over the hash or
comparison function used, the types require that the key types implement the
<code>std::hash::Hash</code> (unordered) or <code>std::cmp::Ord</code> (ordered) traits. To use the containers
with different hash or comparison functions, one must use a wrapper type with a
different implementation of the required trait.</p>
<p>Some C++ container types provided by the STL have no equivalent in Rust. Many of
those have equivalents available in third-party <a href="TODO">libraries</a>.</p>
<p>One significant different in the use of these types between C++ in Rust is with
the <code>Vec&lt;T&gt;</code> and array <code>[T; N]</code> types, from which slice references <code>&amp;[T]</code> or
<code>&amp;mut [T]</code> to part or all of the data can be cheaply created. For this reason,
when defining a function that does not modify the length of a vector and does
not need to statically know the number of elements in an array, it is more
idiomatic to take a parameter as <code>&amp;[T]</code> or <code>&amp;mut [T]</code> than as a reference to the
owned type.</p>
<p>In C++ it is better to take begin and end iterators than a <code>span</code> when possible,
since iterators are more general. The same is true with Rust and taking a
generic type that implements <code>IntoIter&lt;&amp;T&gt;</code> or <code>IntoIter&lt;&amp;mut T&gt;</code> instead of
<code>&amp;[T]</code>.</p>
<div class="comparison">
<pre><code class="language-c++">#include &lt;iterator&gt;
#include &lt;vector&gt;

template &lt;typename InputIter&gt;
void go(InputIter first, InputIter last) {
  for (auto it = first; it != last; ++it) {
    // ...
  }
}

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3};
  go(v.begin(), v.end());
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::iter::IntoIterator;

fn go&lt;'a&gt;(iter: impl IntoIterator&lt;Item = &amp;'a mut i32&gt;) {
    for x in iter {
        // ...
    }
}

fn main() {
    let mut v = vec![1, 2, 3];
    go(&amp;mut v);
}</code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;type_equivalents&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4fb18334-8405-438d-8d3e-859a8823bccf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It is guaranteed in safe Rust to represent a valid Unicode scalar value.\n&quot;,&quot;It is 32 bits wide.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It is equivalent to the C++ `wchar` type.\n&quot;,&quot;It is equivalent to the C++ `char` type.\n&quot;,&quot;It is equivalent to the C++ `char8_t` type.\n&quot;,&quot;It is equivalent to the C++ `int32_t` type.\n&quot;,&quot;It is 8 bits wide.\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about the Rust `char` type.\n&quot;}},{&quot;id&quot;:&quot;5586766c-b5ce-4bea-b995-da0b3c548b0d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It provides thread-safe read access to a value of type `T`.\n&quot;,&quot;It represents shared ownership of a value of type `T`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It provides thread-safe write access to a value of type `T`.\n&quot;,&quot;It can be empty (i.e., not own some value of type `T`).\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about `std::sync::Arc&lt;T&gt;`.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Type equivalents">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/encapsulation/private_constructors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../idioms/out_params.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/encapsulation/private_constructors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../idioms/out_params.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
