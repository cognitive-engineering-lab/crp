<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Placement new - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <meta property="og:description" content="A book to help translate C++ idioms into Rust.">
        <meta property="twitter:description" content="A book to help translate C++ idioms into Rust.">
        <meta name="twitter:card" content="summary">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="placement-new"><a class="header" href="#placement-new">Placement new</a></h1>
<div class="warning">
<p>Some of the statements about Rust in this chapter are dependent on the specifics
of how the compiler optimizes various programs. Unless otherwise state, the
results presented here are based on rustc 1.87 using the <a href="https://doc.rust-lang.org/edition-guide/introduction.html">2024 language
edition</a>.</p>
</div>
<p>The primary purposes of placement new in C++ are</p>
<ul>
<li>situations where <a href="#custom-allocators-and-custom-containers">storage allocation is separate from
initialization</a> such as in the
implementation of <code>std::vector</code> or memory pools,</li>
<li>situations where the structures need to be placed at a specific memory
location, e.g., for <a href="#memory-mapped-registers-and-embedded-development">working with memory-mapped
registers</a>, and</li>
<li><a href="#performance-and-storage-reuse">storage reuse for performance reasons</a>.</li>
</ul>
<p>You also might have ended up on this page looking for <a href="#constructing-large-values-on-the-heap">how to construct large
values directly on the heap in Rust</a>.</p>
<p>There is an <a href="https://github.com/rust-lang/rfcs/pull/2884">open proposal</a> for
adding the features analogous to placement new in Rust, but the design of the
features is still under discussion. In the meantime, for many of the use cases
of placement new, there are either alternatives in safe Rust or approaches that
use unsafe Rust that can accomplish the required behaviors.</p>
<h2 id="custom-allocators-and-custom-containers"><a class="header" href="#custom-allocators-and-custom-containers">Custom allocators and custom containers</a></h2>
<p>It is uncommon to use placement new for the first reason because the major use
cases are covered by using STL containers with custom allocators. Similarly,
Rust's standard libraries can be used with custom allocators. However, in Rust
the API for custom allocators is still
<a href="https://github.com/rust-lang/rust/issues/32838">unstable</a>, and so they are only
available when using the nightly compiler with <a href="https://doc.rust-lang.org/unstable-book/library-features/allocator-api.html">a feature
flag</a>.
The Rust Book has <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#unstable-features">instructions on how to install the nightly
toolchain</a>
and the The Rust Unstable Book has <a href="https://doc.rust-lang.org/unstable-book/">instructions on how to use unstable
features</a>.</p>
<p>For stable Rust, there are libraries that cover many of the uses of allocators.
For example, <a href="https://docs.rs/bumpalo/latest/bumpalo/">bumpalo</a> provides a safe
interface to a bump allocation arena, a <a href="https://docs.rs/bumpalo/latest/bumpalo/collections/vec/struct.Vec.html">vector type using the
arena</a>,
and other utility types using the arena.</p>
<p>For implementing custom collection types that involves separate allocation and
initialization of memory, the chapters in the Rustonomicon on <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">implementing
<code>Vec</code></a> are a useful resource.</p>
<h2 id="memory-mapped-registers-and-embedded-development"><a class="header" href="#memory-mapped-registers-and-embedded-development">Memory-mapped registers and embedded development</a></h2>
<p>If you are using Rust for embedded development, you may want to additionally
read the <a href="https://docs.rust-embedded.org/book/">Embedded Rust Book</a>. The
chapters on
<a href="https://docs.rust-embedded.org/book/peripherals/index.html">peripherals</a>
discuss how to work with structures that are located at a specific address in
memory.</p>
<p>The Embedded rust Book also includes <a href="https://docs.rust-embedded.org/book/c-tips/index.html">a chapter on advice for embedded C
programmers using Rust for embedded
development</a>.</p>
<h2 id="performance-and-storage-reuse"><a class="header" href="#performance-and-storage-reuse">Performance and storage reuse</a></h2>
<p>This use of placement new in C++ for the purpose of reusing storage can usually
be replaced in Rust by a simple assignment. Because <a href="./constructors/copy_and_move_constructors.html">assignment in Rust is
always a move, and in Rust moves do not leave behind objects that require
destruction</a>, the optimizer will
usually produce code analogous to placement new for this use case. In some
cases, this also depends on an <a href="./rvo.html">RVO or NRVO optimization</a>. While these
optimizations are not guaranteed, they are reliable enough for common coding
patterns, especially when combined with
<a href="https://bheisler.github.io/criterion.rs/book/index.html">benchmarking</a> the
performance-sensitive code to confirm that the desired optimization was
performed. Additionally, the generated assembly for specific functions can be
examined using a tool like
<a href="https://github.com/pacak/cargo-show-asm">cargo-show-asm</a>.</p>
<p>The Rust version of the following example relies on the optimizations <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyahSAVyVFyKxqiIEh1ZpgDC6embZMpATnLOAGQImbAA5TwAjbFIQADZyAAd0JWIHJjcPL19E5NShIJDwtiiY%2BJtsOzSRIhZSIgzPbx4/csqhatqiArDI6LjrGrqGrOaBzu6ikriASmt0M1JUTi4AUgAmAGYVgFYAIRxSAgA3bAgAEWwaFjN6Immds5WtAEFLczsAagDa4GwAdQImF%2BRA%2BKwA7Lsns8PjCPoCQB8LAQAF7YchQ8GPF4YzY7XZmJhKFg0U5MdAAfTYxmAjHu2yxzxoTA%2BmApAHcyABrCBshHrWJsMwg76kX4AoHYO6giFQ2EfQSkOFw5laAB0qp4Wi00shLzlcoAVGzQRszl8fv9AcCdbL9Xb4XD0Xq7dLHhtddCXQB6L2IlQfNm2u2WTAgEBIYJEMMRIyoTnkiLodQQfls%2B7uoOujFghlQpkfKnBCDTG3OmGMEGCkFKVCkFhEVBIE1mkViq2SsM4K43IjFlYZsss9lclNrAVCj41usNpDpj2YqFcWb0bjbfjeLg6cjobgAJQs1fmi2woM2fHIUc3S9mnJA2zWquksTB21iGwAHD5PzwZBtDNxpH4Ng7y0cgNy3HcuH4JQQFAy8dFmOBYBQDAcHwYgyEoag6EYVgOG4c9BGEMQJE4GQ5GEZQ1E0K9yH0NZDGpNB1khNZdmsbBbHsRwIGcYZvDWHh/CYTAJl6GJZCSFJuPSdxGhAQScmktIxOKPpZFaGSOiGOSskUzSqkGLpgh6NSJLGHTMgEoTLHGEzJnU2YlCPJZuHWDZglQDwcBNFxUBDLt%2B1wHEPKYLyzB8/sXBCQMNmC7EXjeMxPlbS0JRBcEPRhEMwxSVFyRBQF%2B3nHNioxF4iGwNgEiMSrfKIABPBJmHYE8ABUgqhbB1Eq0hmSOdBAQ%2BGMWDjXYkwgNrT1idQ53K54BqG1k/hHRbMA%2BA0p3rRsS0y20FQ%2BCAcpAPLsAKpV%2BzNLRioujYXA%2BTVrvdOEWJY3aZUHa4SA2tkIBiw6tpnEtUvFYFMtVIbLpenM5sHH0/RPQNBxGsaJrTMrBzZABaIKAD8QfbXtYc9BdsVKhLnkjAsWCLd6so%2BCQCGAVglAgRnmfQGgIAJ9LphLRtakzGEODYMgGrxU7Oe5i1QclOk3XptafubAsqrFjHPWWkd0YHZ5SeeJd/y4NcwO0fhIJcV62MnFyT3ctZ%2BHg69yCQbAWAOahlwAoCQNN2jIOg2CLzNvnyFve9H2fV8Py/Hwf2kP8Vy4DZ1zN7duEdkPyCQhB4AgFD0GqhhoiwiAMCLxgYlIHh3zBUCcN6mCIAiNOImCWoGoI/g29YUgGoAeQiXQKkvc9y44YR%2B6YehO9onAIjMYAXAkegYN4fgcCpExJDnghSBH45sDXrduoqIVli3SNOLT%2BgCAiOs%2B7cHA06IQ5gPX8gTlIRMVAuLeaWCKAK8swaBGGAEoAAagQbAbJ%2B7NQ3IReQJFJDkSIooFQGg076CEkYEwIBzCWEMHfGCkBZjoASDJNeWMsb3XIUQLGjATj0Eug7bcX9Dg4BIcWDiXE0hOBEvxAwgR7LiQMFJPIskrJiNyDJVSUwbKcQPu0IygiFG8OUXZQooibIqN0k0CyxktFmSkE5W2JijYm3AubbgHwCENgeqqWuqptQQHQiQRU7keDTEzsA7OKB5hEASEKUu5cEjF1IKEVq3A7GoAcU4k%2BhB3HwiEmg5BZFZBoKopg2i2DyBsjrAkLuXtjap39twfuQogkgk5rYg8sSeCOLBM4w6bgK7RFPBsLxPiEI3hANIJp2wNhrATrETUmp3zvm2O%2BI2gFyDAW2KBKx6coLWCDk7RCiB85oELmEyuISdnhJAMAHg2wUkMEbtQFutEe4dy7uQG5fdB7DzsHc8ezAiBTxnmneei9l70FXncze1Id5bkIPvSoJxj78FPqgc%2Bdyr5Jy3Lfe%2BHcn4X0dm/O5X8f7YD/sCwBWdQEsHAVAmBcDmB3NSeIFBGT5BZJolueijE8GoCtuxZFXCyEULSFQkMl1WVsRYpsD4WN%2B6sPQOwwER94BOUUW0bwvEBF6KESJORfQhLiJkqopSEi1UxDUUopg2l6jKoNfK41eqDC2UsvJHRmjTLyNMQsVyaximWLTpBD46h3yxCxrEaQHxgCoHqdsDUh03FkA6a67phstkBKqfstpESolcG9b6/1gbg0PVDeebAiSyDwgYlS0iUhaWUQwQyvQCk8kFKKRY0pEFymVInDUtNfqA1BpDWGiArTdntPtt44OwDZiu3dn0bhSdZnzMWR6jOqy4Ih16f01UgzhkbFGVocZkzplJxTn7RtKz1nFNYUsgOQ6emf2iCkRw0ggA%3D%3D">to
achieve the desired behavior</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;new&gt;

struct LargeWidget {
  std::size_t id;
};

template &lt;typename T&gt;
extern void blackBox(T &amp;x);

void doWork(void *scratch) {
  for (std::size_t i = 0; i &lt; 100; i++) {
    auto *w(new (scratch) LargeWidget{.id = i});
    // use w
    blackBox(w);
    w-&gt;~LargeWidget();
  }
}

int main() {
  alignas(alignof(LargeWidget)) char
      memory[sizeof(LargeWidget)];
  void *w = memory;
  doWork(w);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct LargeWidget {
    id: usize,
}

fn do_work(w: &amp;mut LargeWidget) {
    for i in 0..100 {
        *w = LargeWidget { id: i };
        // use w
        std::hint::black_box(&amp;w);
    }
}

fn main() {
    let mut scratch = LargeWidget::default();
    do_work(&amp;mut scratch);
}</code></pre></pre>
</div>
<p>Adding in a <code>Drop</code> implementation for <code>LargeWidget</code> does result in the drop
function being called on each loop iteration, but makes the generated assembly
much harder to read, and so has been omitted from the example.</p>
<h2 id="constructing-large-values-on-the-heap"><a class="header" href="#constructing-large-values-on-the-heap">Constructing large values on the heap</a></h2>
<p><code>new</code> in C++ constructs objects directly in dynamic storage, and placement <code>new</code>
constructs them directly in the provided location. In Rust, <code>Box::new</code> is a
normal function, so the value is constructed on the stack and then moved to the
heap (or to the storage provided by the custom allocator).</p>
<p>While the initial construction of the value on the stack can sometimes be
optimized away, in order to guarantee that the stack is not used for the large
value requires the use of unsafe Rust and <code>MaybeUninit</code>. Additionally, the
mechanisms available for initializing a value on the heap do not guarantee that
the values will not be created on the stack and then moved to the heap. Instead,
they just make it possible to incrementally initialize a structure (either
field-by-field or element-by-element), so that the entire structure does not
have to be on the stack at once. The same optimizations do apply, however, and
so the additional copies might be avoided.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
  constexpr unsigned int SIZE = 8000000;
  std::unique_ptr b = std::make_unique&lt;
      std::array&lt;unsigned int, SIZE&gt;&gt;();
  for (std::size_t i; i &lt; SIZE; ++i) {
    (*b)[i] = 42;
  }

  // use b so that it isn't optimized away
  for (std::size_t i; i &lt; SIZE; ++i) {
    std::cout &lt;&lt; (*b)[i] &lt;&lt; std::endl;
  }
}
</code></pre>
<!-- must be no_run because mdbook test doesn't compile with opt-level=2 -->
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;

    // optimization here makes it not overflow
    // the stack with opt-level=2
    let mut b = Box::new([0; SIZE]);
    for i in 0..SIZE {
        b[i] = 42;
    }

    // use b so that it isn't optimized away
    std::hint::black_box(&amp;b);
}</code></pre></pre>
</div>
<p>On the other hand, directly defining the array as <code>[42; SIZE]</code> does result in
the value being first constructed on the stack, which produces an error when
run.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;

    let b = Box::new([42; SIZE]);

    // use b so that it isn't optimized away
    std::hint::black_box(&amp;b);
}</code></pre></pre>
<pre><code class="language-text">thread 'main' has overflowed its stack
fatal runtime error: stack overflow
Aborted (core dumped)
</code></pre>
<p>While construction of the values directly on the heap is not possible to
enforce, it is possible to incrementally construct the value by using unsafe
Rust, which avoids overflowing the stack. This technique relies on both
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a> and
<a href="https://doc.rust-lang.org/std/ptr/macro.addr_of_mut.html"><code>addr_of_mut!</code></a>.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;
    let mut b = Box::&lt;[i32; SIZE]&gt;::new_uninit();
    let bptr = b.as_mut_ptr();
    for i in 0..SIZE {
        unsafe {
            std::ptr::addr_of_mut!(((*bptr)[i])).write(42);
        }
    }

    let b2 = unsafe { b.assume_init() };

    for i in 0..SIZE {
        println!("{}", b2[i]);
    }
}</code></pre></pre>
<p>Depending on what is need, this particular use can be generalized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_with&lt;T, const SIZE: usize&gt;(
    f: impl Fn(usize) -&gt; T,
) -&gt; Box&lt;[T; SIZE]&gt; {
    let mut b = Box::&lt;[T; SIZE]&gt;::new_uninit();
    let bptr = b.as_mut_ptr();
    for i in 0..SIZE {
        unsafe {
            std::ptr::addr_of_mut!(((*bptr)[i]))
                .write(f(i));
        }
    }

    unsafe { b.assume_init() }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that a more idiomatic way to deal with a large array on the heap is to
represent it as either a boxed slice or a vector instead of a boxed array, in
which case using iterators to define the value avoids constructing it on the
stack, and does not require the use of unsafe Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_with&lt;T, const SIZE: usize&gt;(
    f: impl Fn(usize) -&gt; T,
) -&gt; Box&lt;[T]&gt; {
    (0..SIZE).map(f).collect()
}
<span class="boring">}</span></code></pre></pre>


                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Placement new">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/rvo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../patterns/adapter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/rvo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../patterns/adapter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q3W4ES0FTM"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q3W4ES0FTM');
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
