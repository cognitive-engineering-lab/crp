<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tagged unions and std::variant - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tagged-unions-and-stdvariant"><a class="header" href="#tagged-unions-and-stdvariant">Tagged unions and <code>std::variant</code></a></h1>
<h2 id="c-style-tagged-unions"><a class="header" href="#c-style-tagged-unions">C-style tagged unions</a></h2>
<p>Because unions cannot be used for type punning in C++, they are usually used
with a tag to discriminate between which variant of the union is active.</p>
<p>Rust's equivalent to union types are always tagged. They are a generalization of
Rust enums, where additional data may be associated with the enum variants.</p>
<div class="comparison">
<pre><code class="language-cpp">enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };

  double area() {
    switch (this-&gt;tag) {
    case Rectangle: {
      return this-&gt;rectangle.width *
             this-&gt;rectangle.height;
    }
    case Triangle: {
      return 0.5 * this-&gt;triangle.base *
             this-&gt;triangle.height;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
            Shape::Triangle { base, height } =&gt; {
                0.5 * base * height
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>When matching on an enum, Rust requires that all variants of the enum be
handled. In situations where <code>default</code> would be used with a C++ <code>switch</code> on the
tag, a wildcard can be used in the Rust <code>match</code>.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;iostream&gt;
</span><span class="boring">
</span><span class="boring">enum Tag { Rectangle, Triangle, Circle };
</span><span class="boring">
</span>struct Shape {
<span class="boring">  Tag tag;
</span><span class="boring">  union {
</span><span class="boring">    struct {
</span><span class="boring">      double width;
</span><span class="boring">      double height;
</span><span class="boring">    } rectangle;
</span><span class="boring">    struct {
</span><span class="boring">      double base;
</span><span class="boring">      double height;
</span><span class="boring">    } triangle;
</span><span class="boring">    struct {
</span><span class="boring">      double radius;
</span><span class="boring">    } circle;
</span><span class="boring">  };
</span><span class="boring">
</span>  void print_shape() {
    switch (this-&gt;tag) {
    case Rectangle: {
      std::cout &lt;&lt; "Rectangle" &lt;&lt; std::endl;
      break;
    }
    default: {
      std::cout &lt;&lt; "Some other shape"
                &lt;&lt; std::endl;
      break;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn print_shape(&amp;self) {
        match self {
            Shape::Rectangle { .. } =&gt; {
                println!("Rectangle");
            }
            _ =&gt; {
                println!("Some other shape");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Rust does not support C++-style fallthrough where some behavior can be done
before falling through to the next case. However, in Rust one can match on
multiple enum variants simultaneously, so long as the simultaneous match
patterns bind the same names with the same types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn bounding_area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { height, width }
            | Shape::Triangle {
                height,
                base: width,
            } =&gt; width * height,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-the-value-without-checking-the-discriminant"><a class="header" href="#accessing-the-value-without-checking-the-discriminant">Accessing the value without checking the discriminant</a></h2>
<p>Unlike with C-style unions, Rust always requires matching on the discriminant
before accessing the values. If the variant is already known, e.g., due to an
earlier check, then the code can usually be refactored to encode the knowledge
in the type so that the second check (and corresponding error handling) can be
omitted.</p>
<p>A C++ program like the following requires more restructuring of the types to
achieve the same goal in Rust.</p>
<p>The corresponding Rust program requires defining separate types for each variant
of the <code>Shape</code> enum so that the fact that all of the value are of a given type
can be expressed in the type system by having an array of <code>Triangle</code> instead of
an array of <code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

// Uses the same Shape definition.
enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };
};

std::vector&lt;Shape&gt; get_shapes() {
  return std::vector&lt;Shape&gt;{
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},
  };
}

std::vector&lt;Shape&gt; get_shapes();

int main() {
  std::vector&lt;Shape&gt; shapes = get_shapes();

  auto is_triangle = [](Shape shape) {
    return shape.tag == Triangle;
  };

  // Create an iterator that only sees the
  // triangles. (std::views::filter is from C++20,
  // but the same effect can be acheived with a
  // custom iterator.)
  auto triangles =
      shapes | std::views::filter(is_triangle);

  double total_base = 0.0;
  for (auto &amp;triangle : triangles) {
    // Skip checking the tag because we know we
    // have only triangles.
    total_base += triangle.triangle.base;
  }

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define a separate struct for each variant.
struct Rectangle { width: f64, height: f64 }
struct  Triangle { base: f64, height: f64 }

enum Shape {
    Rectangle(Rectangle),
    Triangle(Triangle),
}

fn get_shapes() -&gt; Vec&lt;Shape&gt; {
    vec![
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Rectangle(Rectangle {
            width: 1.0,
            height: 1.0,
        }),
    ]
}

fn main() {
    let shapes = get_shapes();

    // This iterator only iterates over triangles
    // and demonstrates that by iterating over
    // the Triangle type instead of the Shape type.
    let triangles = shapes
        .iter()
        // Keep only the triangles
        .filter_map(|shape| match shape {
            Shape::Triangle(t) =&gt; Some(t),
            _ =&gt; None,
        });

    let mut total_base = 0.0;
    for triangle in triangles {
        // Because the iterator produces Triangles
        // instead of Shapes, base can be accessed
        // directly.
        total_base += triangle.base;
    }
}</code></pre></pre>
</div>
<p>This kind of use is common enough in Rust that the variants are often designed
to have their own types from the start.</p>
<p>This approach is also possible in C++. It is more commonly used along with
<code>std::variant</code> in C++17 or later.</p>
<h2 id="stdvariant-since-c17"><a class="header" href="#stdvariant-since-c17"><code>std::variant</code> (since C++17)</a></h2>
<p>When programming in C++ standards since C++17, <code>std::variant</code> can be used to
represent a tagged union in a way that has more in common with Rust enums.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        } else if constexpr (std::is_same_v&lt;T, Triangle&gt;) {
          return 0.5 * arg.base * arg.height;
        }
      },
      shape);
}
</code></pre>
<p>Because Rust doesn't depend on templates for this language feature, error
messages when a variant is missed or when a new variant is added are easier to
read, which removes one of the barriers to using tagged unions more frequently.
Compare the errors in C++ (using gcc) and Rust when the <code>Triangle</code> case is
omitted.</p>
<p>The following two programs have the same error: each fails to handle a case of
<code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        }
      },
      shape);
}
</code></pre>
<pre><code class="language-rust ignore">enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
        }
    }
}</code></pre>
</div>
<p>However, the error messages differ significantly.</p>
<div class="comparison">
<pre><code class="language-text">example.cc: In instantiation of ‘area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt; [with auto:27 = const Triangle&amp;]’:
/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from ‘constexpr _Res std::__invoke_impl(__invoke_other, _Fn&amp;&amp;, _Args&amp;&amp; ...) [with _Res = double; _Fn = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}]’
   61 |     { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from ‘constexpr typename std::__invoke_result&lt;_Functor, _ArgTypes&gt;::type std::__invoke(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}; typename __invoke_result&lt;_Functor, _ArgTypes&gt;::type = double]’
   96 |       return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   97 |                                         std::forward&lt;_Args&gt;(__args)...);
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1060:24:   required from ‘static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl&lt;std::__detail::__variant::_Multi_array&lt;_Result_type (*)(_Visitor, _Variants ...)&gt;, std::integer_sequence&lt;long unsigned int, __indices ...&gt; &gt;::__visit_invoke(_Visitor&amp;&amp;, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;&amp;&amp;; _Variants = {const std::variant&lt;Rectangle, Triangle&gt;&amp;}; long unsigned int ...__indices = {1}]’
 1060 |           return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),
      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1061 |               __element_by_index_or_cookie&lt;__indices&gt;(
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1062 |                 std::forward&lt;_Variants&gt;(__vars))...);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1820:5:   required from ‘constexpr decltype(auto) std::__do_visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Result_type = __detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}]’
 1820 |                   _GLIBCXX_VISIT_CASE(1)
      |                   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1882:34:   required from ‘constexpr std::__detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; std::visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}; __detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; = double]’
 1882 |             return std::__do_visit&lt;_Tag&gt;(
      |                    ~~~~~~~~~~~~~~~~~~~~~^
 1883 |               std::forward&lt;_Visitor&gt;(__visitor),
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1884 |               static_cast&lt;_Vp&gt;(__variants)...);
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
example.cc:17:20:   required from here
   17 |   return std::visit(
      |          ~~~~~~~~~~^
   18 |       [](auto &amp;&amp;arg) -&gt; double {
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 |         using T = std::decay_t&lt;decltype(arg)&gt;;
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 |         if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 |           return arg.width * arg.height;
      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   22 |         }
      |         ~
   23 |       },
      |       ~~
   24 |       shape);
      |       ~~~~~~
example.cc:23:7: error: no return statement in ‘constexpr’ function returning non-void
   23 |       },
      |       ^
example.cc: In lambda function:
example.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `&amp;Shape::Triangle { .. }` not covered
 --&gt; example.rs:8:15
  |
8 |         match self {
  |               ^^^^ pattern `&amp;Shape::Triangle { .. }` not covered
  |
note: `Shape` defined here
 --&gt; example.rs:1:6
  |
1 | enum Shape {
  |      ^^^^^
2 |     Rectangle { width: f64, height: f64 },
3 |     Triangle { base: f64, height: f64 },
  |     -------- not covered
  = note: the matched value is of type `&amp;Shape`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
12~             } =&gt; width * height,
13~             &amp;Shape::Triangle { .. } =&gt; todo!(),
  |
</code></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;tagged_unions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;8019115c-c84b-4b79-a18d-d2e83ff984da&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. }\n            | MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. } =&gt; // fallthrough\n            MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;,&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            _ =&gt; self.height * self.width,\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs is the most idiomatic translation of the\ngiven C++ program?\n\n```c++\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n\nenum class MediaType { Text, Image, Video };\n\nclass MediaFile {\npublic:\n  MediaType type;\n  union {\n    struct {\n      std::string language;\n      size_t length;\n    } text;\n    struct {\n      size_t height;\n      size_t width;\n    } image;\n    struct {\n      size_t height;\n      size_t width;\n      std::chrono::nanoseconds duration;\n    } video;\n  };\n\n  // constructors omitted for brevity\n\n  size_t size() const {\n    switch (type) {\n    case MediaType::Text:\n      return text.length;\n    case MediaType::Image:\n      return image.height * image.width;\n    case MediaType::Video:\n      return video.height * video.width;\n    }\n    // Should not reach here\n    return 0;\n  }\n};\n```\n\nAll of the Rust programs use this definition of `MediaFile`.\n\n```rust\nenum MediaFile {\n    Text {\n        language: String,\n        length: usize,\n    },\n    Image {\n        height: usize,\n        width: usize,\n    },\n    Video {\n        height: usize,\n        width: usize,\n        duration: std::time::Duration,\n    },\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Tagged unions and std::variant">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../idioms/data_modeling/enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../idioms/data_modeling/inheritance_and_reuse.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../idioms/data_modeling/enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../idioms/data_modeling/inheritance_and_reuse.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
