<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Private members and friends - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="private-members-and-friends"><a class="header" href="#private-members-and-friends">Private members and friends</a></h1>
<h2 id="private-members"><a class="header" href="#private-members">Private members</a></h2>
<p>In C++ the unit of encapsulation is the class. Access specifiers (<code>private</code>,
<code>protected</code>, and <code>public</code>) that control access to members are enforced at the
class boundary.</p>
<p>In Rust the module is the unit of encapsulation. Item visibility (Rust's analog
to access specifiers) controls access to items at the module boundary.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
  int age;

public:
  std::string name;

  // Because age is private, a public constructor
  // method is needed to create instances.
  Person(std::string name, int age)
      : name(name), age(age) {}

  // Free functions cannot access private members,
  // so this has to be a member function.
  static void example() {
    Person alice{"Alice", 42};
    std::ctout &lt;&lt; alice.name &lt;&lt; cout::endl;
    // The private field is visible here, within
    // the class.
    std::ctout &lt;&lt; alice.age &lt;&lt; cout::endl;
  }
};

int main() {
  Person alice("Alice", 42);
  std::cout &lt;&lt; alice.name &lt;&lt; std::endl;
  // compilation error
  // std::cout &lt;&lt; alice.age &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        // this field is private
        age: i32,
    }

    impl Person {
        // Because age is private, a public
        // constructor method is needed to create
        // values outside of the person module.
        pub fn new(
            name: String,
            age: i32,
        ) -&gt; Person {
            Person { name, age }
        }
    }

    // Free functions in the same module can
    // access private fields because the unit of
    // encapsulation is the module, not the
    // struct.
    fn example() {
        let alice =
            Person::new("Alice".to_string(), 42);
        println!("{}", alice.name);
        // The private field is visible here,
        // within the module.
        println!("{}", alice.age);
    }
}

use person::Person;

fn main() {
    let alice =
        Person::new("Alice".to_string(), 42);
    println!("{}", alice.name);
    // compilation error
    // println!("{}", alice.age);
}</code></pre></pre>
</div>
<p>In the Rust example, the <a href="/idioms/encapsulation/private_constructors.html">constructor for <code>Person</code> is
private</a> because one of the
fields is private.</p>
<h2 id="friends"><a class="header" href="#friends">Friends</a></h2>
<p>Because encapsulation is at the module level in Rust, associated methods for
types can access internals of other types defined in the same module. This
subsumes most uses of the C++ <code>friend</code> declaration.</p>
<p>For example, defining a binary tree in C++ requires that the class representing
the nodes of the tree declare the main binary tree class as a friend in order
for it to access internal methods while keeping them private from other uses.
This would be required even if the <code>TreeNode</code> class were defined as an inner
class of <code>BinaryTree</code>.</p>
<p>In Rust, however, both types can be defined in the same module, and so have
access to each other's private fields and methods. The module as a whole
provides a collection of types, methods, and functions that together define a
encapsulated concept.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;memory&gt;

class BinaryTree {
  // This needs to be an inner class in order for
  // it to be private.
  class TreeNode {
    friend class BinaryTree;

    int value;
    std::unique_ptr&lt;TreeNode&gt; left;
    std::unique_ptr&lt;TreeNode&gt; right;

  public:
    TreeNode(int value)
        : value(value), left(nullptr),
          right(nullptr) {}

  private:
    static void
    insert(std::unique_ptr&lt;TreeNode&gt; &amp;node,
           int value) {
      if (node) {
        node-&gt;insert(value);
      } else {
        node = std::make_unique&lt;TreeNode&gt;(value);
      }
    }

    void insert(int value) {
      if (value &lt; this-&gt;value) {
        insert(this-&gt;left, value);
      } else {
        insert(this-&gt;right, value);
      }
    }
  };

  std::unique_ptr&lt;TreeNode&gt; root;

public:
  BinaryTree() : root(nullptr) {}

  void insert(int value) {
    TreeNode::insert(root, value);
  }
};

int main() {
  BinaryTree b;
  b.insert(42);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod binary_tree {
    pub struct BinaryTree {
        // This field is not visible outside of
        // the module.
        root: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl BinaryTree {
        pub fn new() -&gt; BinaryTree {
            BinaryTree { root: None }
        }

        pub fn insert(&amp;mut self, value: i32) {
            insert(&amp;mut self.root, value);
        }
    }

    // This struct and all its fields are not
    // visible outside of the module.
    struct TreeNode {
        value: i32,
        left: Option&lt;Box&lt;TreeNode&gt;&gt;,
        right: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl TreeNode {
        fn new(value: i32) -&gt; TreeNode {
            TreeNode {
                value,
                left: None,
                right: None,
            }
        }

        fn insert(&amp;mut self, value: i32) {
            if value &lt; self.value {
                insert(&amp;mut self.left, value);
            } else {
                insert(&amp;mut self.right, value);
            }
        }
    }

    // This free function is not visible outside
    // of the module.
    fn insert(
        node: &amp;mut Option&lt;Box&lt;TreeNode&gt;&gt;,
        value: i32,
    ) {
        match node {
            None =&gt; {
                *node = Some(Box::new(
                    TreeNode::new(value),
                ));
            }
            Some(ref mut left) =&gt; {
                left.insert(value);
            }
        }
    }
}

// This brings the (public) type into scope.
use binary_tree::BinaryTree;

fn main() {
    let mut b = BinaryTree::new();
    b.insert(42);
}</code></pre></pre>
</div>
<h2 id="passkey-idiom"><a class="header" href="#passkey-idiom">Passkey idiom</a></h2>
<p>In the previous C++ example, the <code>TreeNode</code> constructor has to be public in
order to be used with <code>make_unique</code>. Fortunately, the constructor is still
inaccessible outside of the containing class, but it is not always the case that
such helper classes can be inner classes.</p>
<p>To make the constructor effectively private when it is not possible, one might
need to use a programming pattern like <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/patterns/passkey.md">the passkey
idiom</a>.</p>
<p>The passkey idiom is also sometimes used to provide finer-grained control over
access to members than is possible with friend declarations. In either case, the
effect is achieved by modeling a capability-like system.</p>
<p>In Rust, it is possible to express the same idiom in order to achieve the same
effect.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

class Person {
  int age;

  class Passkey {};

public:
  std::string name;

  Person(Passkey, std::string name, int age)
      : name(name), age(age) {}

  static std::unique_ptr&lt;Person&gt;
  createPerson(std::string name, int age) {
    // Other uses of make_unique are not possible
    // because the Passkey type cannot be
    // constructed.
    return std::make_unique&lt;Person&gt;(Passkey(),
                                    name, age);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust">pub trait Maker&lt;K, B&gt; {
    fn make(passkey: K, args: B) -&gt; Self;
}

// Generic helper that we want to be able to call
// an otherwise private function or method.
fn alloc_thing&lt;K, B, T: Maker&lt;K, B&gt;&gt;(
    passkey: K,
    args: B,
) -&gt; Box&lt;T&gt; {
    Box::new(Maker::&lt;K, B&gt;::make(passkey, args))
}

mod person {
    use super::*;
    use std::marker::PhantomData;

    pub struct Person {
        pub name: String,
        age: u32,
    }

    // A zero-sized type to act as the passkey.
    pub struct Passkey {
        // This field is zero-sized. It is also
        // private, which prevents construction
        // of Passkey outside of the person
        // module.
        _phantom: PhantomData&lt;()&gt;,
    }

    impl Person {
        // Private method that will be exposed
        // with a passkey wrapper.
        fn new(name: String, age: u32) -&gt; Person {
            Person { name, age }
        }

        // Method that uses external helper that
        // requires access to another
        // otherwise-private method.
        fn alloc(
            name: String,
            age: u32,
        ) -&gt; Box&lt;Person&gt; {
            alloc_thing(
                Passkey {
                    _phantom: PhantomData {},
                },
                MakePersonArgs { name, age },
            )
        }
    }

    // Helper structure needed to make the trait
    // providing the interface generic.
    pub struct MakePersonArgs {
        pub name: String,
        pub age: u32,
    }

    // Implementation of the trait that exposes
    // the method requiring a passkey.
    impl Maker&lt;Passkey, MakePersonArgs&gt; for Person {
        fn make(
            _passkey: Passkey,
            args: MakePersonArgs,
        ) -&gt; Person {
            Person::new(args.name, args.age)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</div>
<p>However the Passkey idiom is unlikely to be used in Rust because</p>
<ul>
<li>coupled types are usually defined in the same module (or a <code>pub (in path)</code>
declaration can be used), making it unnecessary, and</li>
<li>it requires cooperation from the interface by which the calling function will
use a type.</li>
</ul>
<p>The second point contrasts with the use above involving <code>std::make_unique</code> which
is able to forward to the underlying constructor without knowing about it at the
point of the definition of <code>std::make_unique</code>. While the example below is not
useful (because <code>alloc_thing</code> is not a useful helper), it does demonstrate what
would types have to be defined in order to achieve the same effect as when using
the idiom in C++.</p>
<h2 id="friends-and-testing"><a class="header" href="#friends-and-testing">Friends and testing</a></h2>
<p>Another common use of friend declarations is to make the internals of a class
available for unit testing. Though this practice is often discouraged in C++, it
is sometimes necessary in order to test other-wise private helper inner classes
or helper methods.</p>
<p>In Rust, tests are usually defined in the same module as the code being tested.
Because the content of modules is visible to submodules, this makes it so that
all of the content of the module is available for testing.</p>
<div class="comparison">
<pre><code class="language-cpp">// Using Boost.Test
// https://www.boost.org/doc/libs/1_84_0/libs/test/doc/html/index.html
#include &lt;string&gt;

class Person {
public:
  std::string name;

private:
  int age;

  friend class PersonTest;

public:
  Person(std::string name, int age)
      : name(name), age(age) {}

  void have_birthday() {
    this-&gt;age = this-&gt;age + 1;
  }
};

#define BOOST_TEST_MODULE PersonTestModule
#include &lt;boost/test/included/unit_test.hpp&gt;

class PersonTest {
public:
  static void test_have_birthday() {
    Person alice("Alice", 42);
    BOOST_CHECK_EQUAL(alice.age, 42);

    alice.have_birthday();
    BOOST_CHECK_EQUAL(alice.age, 43);
  }
};

BOOST_AUTO_TEST_CASE(have_birthday_test) {
  PersonTest::test_have_birthday();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
    pub name: String,
    age: u32,
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Person {
        Person { name, age }
    }

    pub fn have_birthday(&amp;mut self) {
        self.age = self.age + 1;
    }
}

#[cfg(test)]
mod test {
    use super::Person;

    #[test]
    fn test_have_birthday() {
        let mut alice =
            Person::new("alice".to_string(), 42);

        assert_eq!(alice.age, 42);
        alice.have_birthday();
        assert_eq!(alice.age, 43);
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Testing in Rust is described in more detail in the <a href="/tooling/unit_tests.html">chapter on unit
testing</a>.</p>
<h2 id="visibility-of-methods-on-rust-traits"><a class="header" href="#visibility-of-methods-on-rust-traits">Visibility of methods on Rust traits</a></h2>
<p>Because traits in Rust are intended for the definition of interfaces, the
methods for some type that are declared by a trait are visible whenever both the
trait and the type are visible. In other words, it is not possible to have
private trait methods.</p>
<p>The default visibility for trait methods differs from Rust structs where the
default visibility is private to the defining module.</p>
<h2 id="private-constructors-and-friends"><a class="header" href="#private-constructors-and-friends">Private constructors and friends</a></h2>
<p>In C++ one can control which classes can derive from a specific class by making
all of the constructors private and then declaring classes which may derive from
it as friends.</p>
<p>In Rust, one can achieve the similar goal of controlling which types can
implement a trait by using the <a href="https://predr.ag/blog/definitive-guide-to-sealed-traits-in-rust/">sealed trait
pattern</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;private_and_friends&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Methods for trait implementations are visible wherever both the type and the\ntrait are visible.\n&quot;,&quot;id&quot;:&quot;0cf46fc5-2456-44b1-bb4e-f5adac2ffaf3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It does not compile because the triangle module is not visible from `main`.\n&quot;,&quot;It does not compile because the `area` method of the `Shape` implementation for\nTriangle isn't visible from `main`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because the shapes module is not visible from the location\nof `use`.\n&quot;,&quot;It does not compile because the `area` method of the `Shapes` trait is not\nvisible from `main`.\n&quot;,&quot;It does not compile because the `area` method of the `Shape` trait is not\nvisible from the implementation of the `Shape` trait for `Triangle`.\n&quot;],&quot;prompt&quot;:&quot;Which of the following are reasons why this program does not compile?\n\n```rust\nmod shapes {\n    pub trait Shape {\n        fn area(&amp;self) -&gt; f64;\n    }\n\n    mod triangle {\n        use super::*;\n\n        pub struct Triangle {\n            pub base: f64,\n            pub height: f64,\n        }\n\n        impl Shape for Triangle {\n            fn area(&amp;self) -&gt; f64 {\n                0.5 * self.base * self.height\n            }\n        }\n    }\n}\n\nuse shapes::*;\n\nfn main() {\n    let t = triangle::Triangle {\n        base: 1.0,\n        height: 2.0,\n    };\n    println!(\&quot;{}\&quot;, t.area());\n}\n```\n&quot;}},{&quot;id&quot;:&quot;86a2afdc-85f8-4662-aa1b-b219cb99c457&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Change `mod triangle` to `pub mod triangle`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Change `impl Shape for Triangle` to `pub impl Shape for Triangle`.\n&quot;,&quot;Change `fn area(&amp;self) -&gt; f64` to `pub fn area(&amp;self) -&gt; f64` in the\nimplementation of `Shape` for `Triangle`.\n&quot;,&quot;Change `fn area(&amp;self) -&gt; f64` to `pub fn area(&amp;self) -&gt; f64` in the\ndefinition of the `Shape` trait.\n&quot;],&quot;prompt&quot;:&quot;What changes are required to make this program compile?\n\n```rust\nmod shapes {\n    pub trait Shape {\n        fn area(&amp;self) -&gt; f64;\n    }\n\n    mod triangle {\n        use super::*;\n\n        pub struct Triangle {\n            pub base: f64,\n            pub height: f64,\n        }\n\n        impl Shape for Triangle {\n            fn area(&amp;self) -&gt; f64 {\n                0.5 * self.base * self.height\n            }\n        }\n    }\n}\n\nuse shapes::*;\n\nfn main() {\n    let t = triangle::Triangle {\n        base: 1.0,\n        height: 2.0,\n    };\n    println!(\&quot;{}\&quot;, t.area());\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Private members and friends">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../idioms/encapsulation/anonymous_namespaces.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../idioms/encapsulation/private_constructors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../idioms/encapsulation/anonymous_namespaces.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../idioms/encapsulation/private_constructors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
