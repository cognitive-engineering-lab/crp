<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lambdas, closures,and function objects - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <meta property="og:description" content="A book to help translate C++ idioms into Rust.">
        <meta property="twitter:description" content="A book to help translate C++ idioms into Rust.">
        <meta name="twitter:card" content="summary">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lambdas-closures-and-function-objects"><a class="header" href="#lambdas-closures-and-function-objects">Lambdas, closures, and function objects</a></h1>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function pointers</a></h2>
<p>Both C++ and Rust permit the use of functions as values. In both, the values can
have <a href="https://doc.rust-lang.org/std/primitive.fn.html">function pointer types</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int process(int n) {
  std::cout &lt;&lt; n &lt;&lt; std::endl;
  return 2 * n;
}

int main() {
  auto f = process;
  // or with type annotation
  // int (*f)(int) = process;

  std::cout &lt;&lt; f(42) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn process(n: i32) -&gt; i32 {
    println!("{}", n);
    2 * n
}

fn main() {
    let f = process;
    // or with type annotation
    // let f: fn(i32) -&gt; i32 = process;

    println!("{}", f(42));
}</code></pre></pre>
</div>
<p>Non-capturing closures are also convertible function pointers in both C++ and
Rust. In the following example the type could be inferred in both C++ and Rust,
but the type is explicitly given to demonstrate that in both cases the closure
has a function pointer type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
  int (*f)(int) = [](int n) {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    return 2 * n;
  };

  std::cout &lt;&lt; f(42) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f = |n: i32| {
        println!("{}", n);
        2 * n
    };
    // or with type annotation
    // let f: fn(i32) -&gt; i32 = process;

    println!("{}", f(42));
}</code></pre></pre>
</div>
<p>Unlike in C++, in Rust functions can be defined within other functions. This has
the same meaning as defining the functions outside of the function (i.e., the
function is not a capturing closure and so cannot capture variables defined in
the outer function), but the name of the function is only available within the
outer function.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn process(n: i32) -&gt; i32 {
        println!("{}", n);
        2 * n
    }

    println!("{}", process(42));
}</code></pre></pre>
<h2 id="rusts-call-operator-traits"><a class="header" href="#rusts-call-operator-traits">Rust's call operator traits</a></h2>
<p>In C++, any class can implement the call operator trait <code>operator()</code> and be a
function object. Closures defined by lambdas do so automatically. In Rust the
equivalent are the call operator traits.</p>
<div class="table-wrapper"><table><thead><tr><th>Trait</th><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce&lt;Args&gt;</code></a></td><td><code>fn call_once(self, args: Args) -&gt; Self::Output</code></td><td>Can be called at most once</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut&lt;Args&gt;</code></a></td><td><code>fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output</code></td><td>Can be called multiple times and may mutate captures (like the <code>mutable</code> specifier in C++)</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn&lt;Args&gt;</code></a></td><td><code>fn call(&amp;self, args: Args) -&gt; Self::Output</code></td><td>Can be called multiple times and do not mutate captures</td></tr>
</tbody></table>
</div>
<p>Rust function pointers implement all three traits. Other closures implement the
traits depending on how they use the captured variables.</p>
<details>
<summary>
<p>Closure implementing only <code>FnOnce</code></p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hi");
  auto f = [x = std::move(x)]() mutable {
    return std::move(x);
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl;
  // compiles, but the captured value has been
  // moved
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints ""
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let f = {
       let x = String::from("hi");
       // f : FnOnce()
       move || x
   };

   // f() is equivalent to f.call_once()
   println!("{}", f()); // prints "hi"

   // Won't compile--call_once consumes f.
   // println!("{}", f());
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>FnMut</code> and taking ownership of the capture</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [x = std::move(x)]() mutable {
    x.push_back('!');
    return x.size();
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "1"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "2"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut f = {
        let mut x = String::from("");
        // f : FnMut() -&gt; usize
        move || {
            x.push('!');
            x.len()
        }
    };

    println!("{}", f()); // prints "1"
    println!("{}", f()); // prints "2"
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>FnMut</code> and capturing by mutable reference</p>
</summary>
<p>In this case, <code>x</code> has to be alive as long as the closure might be used, since
the closure borrows <code>x</code>. Therefore, <code>x</code> can't be declared in a block with the
lambda like in the previous example.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [&amp;x]() {
    x.push_back('!');
    return x.size();
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "1"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "2"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("");
    // g : FnMut() -&gt; usize
    let mut f = || {
        x.push('!');
        x.len()
    };

    println!("{}", f()); // prints "1"
    println!("{}", f()); // prints "2"
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>Fn</code></p>
</summary>
<p>Whether <code>x</code> is <code>mut</code> or not doesn't affect whether the closure implements <code>Fn</code>
or <code>FnMut</code>. What matters is how <code>x</code> is used by the closure.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [&amp;x]() { return x.size(); };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "0"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "0"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f = {
        let x = String::from("");
        // g : Fn() -&gt; usize
        move || x.len()
    };

    println!("{}", f()); // prints "0"
    println!("{}", f()); // prints "0"
}</code></pre></pre>
</div>
</details>
<h2 id="lambdas-and-closures"><a class="header" href="#lambdas-and-closures">Lambdas and closures</a></h2>
<p>In neither C++ nor Rust can the concrete type of a capturing closure be written.
In both languages, for local variables this means that the type must be
inferred.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
  std::string greeting = "hello";
  // Can't write the type of the closure
  auto sayHelloTo = [&amp;](std::string &amp;who) {
    std::ostringstream out;
    out &lt;&lt; greeting &lt;&lt; " " &lt;&lt; who;
    return out.str();
  };

  std::string world("world");
  std::string moon("moon");

  std::cout &lt;&lt; sayHelloTo(world) &lt;&lt; std::endl;
  std::cout &lt;&lt; sayHelloTo(moon) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to = |who: &amp;str| {
        format!("{} {}", greeting, who)
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
</div>
<p>In both C++ and Rust if the closure is heap-allocated a type can be given. In
C++ this is done using <code>std::function</code> while in Rust it again is done with the
call operator traits.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
  std::string greeting = "hello";
  // Can't write the type of the closure
  std::function&lt;std::string(std::string &amp;)&gt;
      sayHelloTo([&amp;](std::string &amp;who) {
        std::ostringstream out;
        out &lt;&lt; greeting &lt;&lt; " " &lt;&lt; who;
        return out.str();
      });

  std::string world("world");
  std::string moon("moon");

  std::cout &lt;&lt; sayHelloTo(world) &lt;&lt; std::endl;
  std::cout &lt;&lt; sayHelloTo(moon) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to: Box&lt;
        dyn Fn(&amp;str) -&gt; String,
    &gt; = Box::new(|who: &amp;str| {
        format!("{} {}", greeting, who)
    });

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
</div>
<p>Since <code>std::function</code> can be empty the above example isn't strictly equivalent.
However, since <code>std::function</code> is often used with the side condition that the
value not be empty, the <code>Box</code> without an <code>Option</code> wrapper for representing the
empty case is the more practical translation.</p>
<p>A type can also be given in terms of one of the function operator traits for
references to closures in Rust.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to = |who: &amp;str| {
        format!("{} {}", greeting, who)
    };

    let say: &amp;dyn Fn(&amp;str) -&gt; String = &amp;say_hello_to;

    println!("{}", say("world"));
    println!("{}", say("moon"));
}</code></pre></pre>
<p>Additionally, in both C++ and Rust, the return type of the closure can be
annotated as part of the lambda expression. This is useful when the return type
either cannot be inferred or should be less specific than what would be
inferred. In the following example this is used to return a value in terms of an
interface it implements instead of the concrete type that would otherwise be
inferred.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

// The common interface
struct Debug {
  virtual std::ostream &amp;
  emit(std::ostream &amp;out) const = 0;
};

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
                         const Debug &amp;d) {
  d.emit(out);
  return out;
}

// Two things that implement the interface
struct A : public Debug {
  std::ostream &amp;
  emit(std::ostream &amp;out) const override {
    out &lt;&lt; "A";
    return out;
  }
};

struct B : public Debug {
  std::ostream &amp;
  emit(std::ostream &amp;out) const override {
    out &lt;&lt; "B";
    return out;
  }
};

int main() {
  // Without the return-type annotation,
  // std::unique_ptr&lt;A&gt; would be inferred.
  auto f = [](std::unique_ptr&lt;A&gt; a,
              std::unique_ptr&lt;B&gt; b)
      -&gt; std::unique_ptr&lt;Debug&gt; { return a; };
  std::cout &lt;&lt; *f(std::make_unique&lt;A&gt;(),
                  std::make_unique&lt;B&gt;())
            &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// The common interface
use std::fmt::Debug;

// Two things that implement the interface
#[derive(Debug)]
struct A;

#[derive(Debug)]
struct B;

fn main() {
    // Without the return type annotation,
    // Box&lt;A&gt; would be inferred.
    let f = move |a: Box&lt;A&gt;,
                  b: Box&lt;B&gt;|
          -&gt; Box&lt;dyn Debug&gt; { a };
    println!("{:?}", f(Box::new(A), Box::new(B)));
}</code></pre></pre>
</div>
<h2 id="capturing-variables"><a class="header" href="#capturing-variables">Capturing variables</a></h2>
<p>In C++ capture specifiers are used to indicate whether a variable should be
captured by reference, by copy, or by move. The capture specifiers can be given
for all of the variables at once, for each variable, or given as a default along
with specific choices for each variable.</p>
<p>In Rust, the variables are captured either all by reference or all by move using
a <code>move</code> specifier. In order to express other capture strategies, the references
and copies need to be explicitly defined and the closure needs to capture those
variables instead.</p>
<p>Expressing the pattern of explicitly making copies or taking references
leverages the fact that in Rust blocks are expressions. In the examples that
need to do that, notice the lack of a semicolon in the last statement of the
block that is being assigned to the variable to hold the closure.</p>
<p>The following examples show examples of different patterns of capturing
variables in C++ and their analogs in Rust.</p>
<details>
<summary>
<p>Capture <code>x</code> and <code>y</code> by reference</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [&amp;]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x and y borrowed by f, but still available
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    let f = || {
        println!("{}", x);
        println!("{}", y);
    };

    // x and y borrowed by f, but still available
    println!("{}", x);
    println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Capture <code>x</code> and <code>y</code> by mutable reference</p>
</summary>
<p>The C++ version is same as when capturing by mutable reference.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [&amp;]() {
    x.push_back('!');
    y.push_back('!');
  };

  // x and y borrowed by mutably f, but still
  // available anyway
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();

  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("hello world");
    let mut y = String::from("goodnight moon");

    // f needs to be mut because it mutates
    // its captured variables
    let mut f = || {
        x.push('!');
        y.push('!');
    };

    // x and y borrowed mutably by f, and so
    // can't be used here
    // println!("{}", x);
    // println!("{}", y);

    f();

    println!("{}", x);
    println!("{}", y);
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Copy <code>x</code> and <code>y</code> to capture by value</p>
</summary>
<p>In C++ this requires that the lambda have the <code>mutable</code> specifier. In Rust this
requires</p>
<ul>
<li>making a copy of the values for the closure to capture,</li>
<li>marking those copy as mutable with <code>mut</code>,</li>
<li>marking the closure itself as mutable with <code>mut</code>, and</li>
<li>using the <code>move</code> specifier to move ownership of the copies into the closure.</li>
</ul>
<p>Types that indicate they are <a href="constructors/copy_and_move_constructors.html#trivially-copyable-types">trivially copyable by implementing the <code>Copy</code>
trait</a> do
not need to be explicitly cloned.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [=]() mutable {
    x.push_back('!');
    y.push_back('!');
  };

  // copies of x and y owned by f, originals
  // still available
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();

  // still don't have the !, since the copies
  // were modified not the originals
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    let mut f = {
        // Shadow outer variables with copies.
        // This needs to happen outside of the
        // closure expression.
        let mut x = x.clone();
        let mut y = y.clone();
        move || {
            x.push('!');
            y.push('!');
        }
    };

    // clones of x and y owned by f, originals
    // still available
    println!("{}", x);
    println!("{}", y);

    f();

    // still don't have the !, since the copies
    // were modified not the originals
    println!("{}", x);
    println!("{}", y);
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Move <code>x</code> and <code>y</code> to capture by value</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [x = std::move(x),
            y = std::move(y)]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x and y moved into f,
  // empty strings left behind.
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    // captures x and y by value
    let f = move || {
        println!("{}", x);
        println!("{}", y);
    };

    // x and y moved into f,
    // original variables cannot be used
    // println!("{}", x);
    // println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Move <code>x</code> to capture by value, capture <code>y</code> by reference</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [x = std::move(x), &amp;y]() mutable {
    x.push_back('!');
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x moved into f, y borrowed by f
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("hello world");
    let y = String::from("goodnight moon");

    let mut f = {
        let y = &amp;y;
        // Actually captures both x and y by
        // value, but y is a reference
        move || {
            x.push('!');
            println!("{}", x);
            println!("{}", y);
        }
    };

    // x moved into f, y borrowed by f
    // println!("{}", x);
    println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<h2 id="function-objects"><a class="header" href="#function-objects">Function objects</a></h2>
<p>Unlike in C++, in Rust only functions and closures implement the function call
operator traits. The ability to directly implement the traits is <a href="https://github.com/rust-lang/rust/issues/29625">not yet part
of stable Rust</a>.</p>
<p>Instead, one can implement a <a href="./user-defined_conversions.html">conversion
function</a>. The standard conversion traits <code>From</code>
and <code>Into</code> cannot be implemented for this purpose, however, because the <code>impl Trait</code> syntax cannot be used in trait implementations.<sup class="footnote-reference" id="fr-impl-trait-impl-1"><a href="#footnote-impl-trait-impl">1</a></sup> Instead
a separate method must be defined.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct MyClosure {
  std::string msg;

  std::size_t operator()() {
    std::cout &lt;&lt; msg &lt;&lt; std::endl;
    return msg.size();
  }
};

int main() {
  MyClosure myClosure{"hello world"};
  myClosure();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2024">struct MyClosure {
    msg: String,
}

impl MyClosure {
    fn as_fn(&amp;self) -&gt; impl Fn() -&gt; usize {
        move || {
            println!("{}", self.msg);
            self.msg.len()
        }
    }
}

fn main() {
    let my_closure = MyClosure {
        msg: String::from("hello world"),
    };
    let f = my_closure.as_fn();

    f();
}</code></pre></pre>
</div>
<p>In Rust editions earlier than 2024, the above example requires a precise
capturing annotation using the <a href="https://doc.rust-lang.org/std/keyword.use.html#precise-capturing"><code>use&lt;'a&gt;</code>
syntax</a> to
specify that the returned closure borrows from the parameters, since otherwise a
lifetime bound is not inferred.</p>
<h2 id="member-functions-as-function-pointers"><a class="header" href="#member-functions-as-function-pointers">Member functions as function pointers</a></h2>
<p>In C++, pointers to member functions can be invoked with the <code>.*</code> operator or
can be converted to <code>std::function</code> values using <code>std::mem_fn</code>, enabling them to
be used in the same way as other <code>std::function</code> values. When called on a
derived class, whether the method whose address was taken or the overriding
method in the derived class is called depends on whether the method is defined
as virtual.</p>
<p>In Rust pointers to member functions are normal function pointers. For example,
a method on a type <code>T</code> with a <code>&amp;self</code> parameter is a function whose first
argument has type <code>&amp;T</code>. When the method is named via a trait, then the first
argument of the function has type <code>&amp;dyn T</code> with a lifetime bound. Determining
whether vtables are involved in the use of a pointer to a member function is
determined at the time that the method is referenced, rather than when the
method is defined.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

struct Interface {
  virtual void showVirtual() = 0;
};

struct A : public Interface {
  void show() {
    std::cout &lt;&lt; "A" &lt;&lt; std::endl;
  }

  void showVirtual() override {
    std::cout &lt;&lt; "A" &lt;&lt; std::endl;
  }
};

struct B : public Interface {
  void showVirtual() override {
    std::cout &lt;&lt; "B" &lt;&lt; std::endl;
  }

  void show() {
    std::cout &lt;&lt; "B" &lt;&lt; std::endl;
  }
};

int main() {
  auto showV = &amp;Interface::showVirtual;
  auto showA = &amp;A::show;
  auto showB = &amp;B::show;

  A a;
  B b;

  (a.*showV)(); // prints A
  (b.*showV)(); // prints B

  (a.*showA)(); // prints A
  (b.*showB)(); // prints B
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Interface {
    fn show(&amp;self);
}

struct A;

impl Interface for A {
    fn show(&amp;self) {
        println!("A");
    }
}

struct B;

impl Interface for B {
    fn show(&amp;self) {
        println!("B");
    }
}

fn main() {
    // types could be inferred, but given to show
    // that they are just a function pointers
    let show_a: fn(&amp;A) = A::show;
    let show_b: fn(&amp;B) = B::show;
    let show_v: fn(&amp;(dyn Interface + 'static)) =
        Interface::show;

    show_a(&amp;A); // prints A
    show_b(&amp;B); // prints B

    show_v(&amp;A); // prints A
    show_v(&amp;B); // prints B
}</code></pre></pre>
</div>
<h2 id="closures-as-parameters"><a class="header" href="#closures-as-parameters">Closures as parameters</a></h2>
<p>In both C++ and Rust, unboxed closures can be accepted as parameters. Just as
using <code>auto</code> as the type of a parameter in C++ makes the function actually a
function template, using <code>impl Trait</code> as the type of a parameter in Rust makes
the function generic. <a href="data_modeling/concepts.html#templates-vs-generic-functions">The resulting generic function is checked statically,
just like it would be if the type parameter and bound were given
explicitly.</a></p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int apply_to_0(auto f) {
  return f(0);
}

int main() {
  int x = 1;
  auto f([=](int n) { return n + x; });
  std::cout &lt;&lt; apply_to_0(f) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn apply_to_0(f: impl FnOnce(i32) -&gt; i32) -&gt; i32 {
    f(0)
}

fn main() {
    let x = 1;
    let f = move |n: i32| x + n;
    println!("{}", apply_to_0(&amp;f));
}</code></pre></pre>
</div>
<p>When accepting closures as type parameters in Rust, it is best practice to
specify the type as the the least restrictive interface required for how the
closure will be used.</p>
<p>Using <code>FnOnce</code> as the bound is the least restrictive, and so should be used so
that the function accepting a closure as a parameter is as compatible with as
many closures as possible . <code>FnOnce</code> works with <code>Fn</code> and <code>FnMut</code> because there
are <code>FnOnce</code> trait implementations for <code>&amp;Fn</code> and <code>&amp;FnMut</code>. The <code>FnMut</code> trait is
the next most restrictive, followed by <code>Fn</code>, and then actual function pointers,
whose types are written with a lowercase <code>fn</code>.</p>
<p>In both C++ it is also possible to pass references or pointers to closures. In
the following example, the closure is in dynamically allocated storage in both
C++ and in Rust.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

int apply_to_0(std::function&lt;int(int)&gt; f) {
  return f(0);
}

int main() {
  int x = 1;
  // closure is on heap
  auto f(std::function(
      [=](int n) { return n + x; }));
  std::cout &lt;&lt; apply_to_0(f) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn apply_to_0(f: Box&lt;dyn FnOnce(i32) -&gt; i32&gt;) -&gt; i32 {
    f(0)
}

fn main() {
    let x = 1;
    let f = Box::new(move |n: i32| x + n);
    println!("{}", apply_to_0(f));
}</code></pre></pre>
</div>
<p><code>FnOnce</code> can be called when in a <code>Box</code>, because the box owns the trait object,
but not when in a reference which doesn't. <code>Fn</code> and <code>FnMut</code> do not have the same
restriction.</p>
<h2 id="returning-closures"><a class="header" href="#returning-closures">Returning closures</a></h2>
<p>In C++, <code>auto</code> or <code>decltype(auto)</code> can be used as the return type for a function
returning a closure. In Rust, once again the <code>impl Trait</code> syntax can be used.
Just as how in C++ using <code>auto</code> in this way does not denote an abbreviated
function template, it does not denote a generic function in Rust. Instead the
type is inferred, and must satisfy the trait.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

decltype(auto) makeConst(int n) {
  return [n]() { return n; };
}

int main() {
  auto f = makeConst(42);
  std::cout &lt;&lt; f() &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn make_const(n: i32) -&gt; impl Fn() -&gt; i32 {
    move || n
}

fn main() {
    let f = make_const(42);
    println!("{}", f());
}</code></pre></pre>
</div>
<p>In places in C++ where <code>decltype</code> is used to name the closure, e.g., when
returning a closure in a template class, in Rust the <code>impl Trait</code> syntax is
used. If a type needs to be given in a let binding, then an underscore <code>_</code> can
be used to indicate that the part of the type that is the closure's type should
be inferred.</p>
<pre><pre class="playground"><code class="language-rust">struct Wrapper&lt;T&gt;(T);

fn make_closure() -&gt; Wrapper&lt;impl Fn(i32) -&gt; i32&gt;
{
    let x = 1;
    Wrapper(move |n: i32| x + n)
}

fn main() {
    let w: Wrapper&lt;_&gt; = make_closure();
    w.0(0);
}</code></pre></pre>
<p>There are several other places where <code>decltype</code> works but <code>impl Trait</code> does not
yet, such as <a href="https://github.com/rust-lang/rust/issues/99697">the output type for <code>Fn</code>
traits</a>. This means that one can
define closures that return closures in Rust, but cannot give them a type, and
therefore cannot return them from functions. The following compiles in C++ but
fails to compile in Rust for that reason.</p>
<div class="comparison">
<pre><code class="language-cpp">decltype(auto) makeClosure(int n) {
  return [n]() { return [n]() { return n; }; };
}
</code></pre>
<pre><code class="language-rust ignore">// Does not compile: not yet supported
fn make_closure(
    n: i32,
) -&gt; impl Fn() -&gt; impl Fn() -&gt; i32 {
    move || move || n
}</code></pre>
</div>
<h2 id="template-lambdas"><a class="header" href="#template-lambdas">Template lambdas</a></h2>
<p>Rust does not support generic closures. Thus, the following has no equivalent in
rust.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  int n = 0;

  auto idCounter = [&amp;]&lt;typename T&gt;(T x) {
    n++;
    return x;
  };

  int y = idCounter(5);
  std::string z =
      idCounter.template operator()&lt;std::string&gt;(std::string("hi"));
}
</code></pre>
<p>However, if the lambda doesn't capture anything, it is possible to write the
following equivalent in Rust, by using an inner function definition.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  auto id = []&lt;typename T&gt;(T x) { return x; };
  int y = id(5);
  std::string z = id(std::string("hi"));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn id&lt;T&gt;(x: T) -&gt; T {
        x
    }

    id(5);
    id(String::from("hi"));
}</code></pre></pre>
</div>
<h2 id="partial-application-and-stdbind"><a class="header" href="#partial-application-and-stdbind">Partial application and <code>std::bind</code></a></h2>
<p>There is no equivalent to the C++ template <code>std::bind</code> in the Rust standard
library. The idiomatic way to express partial application in Rust is to write
out the lambda.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;functional&gt;

int add(int x, int y) {
  return x + y;
}

int main() {
  using namespace std::placeholders;

  auto addTen = std::bind(add, 10, _1);
  assert(42 == addTen(32));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

fn main() {
    let add_ten = move |y| add(10, y);
    assert_eq!(42, add_ten(32));
}</code></pre></pre>
</div>
<p>The third-party crate
<a href="https://docs.rs/partial_application/latest/partial_application/">partial_application</a>
provides something akin to <code>std::bind</code> using Rust macros.</p>
<pre><code class="language-rust ignore">use partial_application::*;

fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

fn main() {
    let add_ten = partial!(move add =&gt; 10, _);

    assert_eq!(42, add_ten(32));
}</code></pre>
<h2 id="returning-references-to-captured-variables"><a class="header" href="#returning-references-to-captured-variables">Returning references to captured variables</a></h2>
<p>In Rust it is not possible to have a closure return a reference to a captured
variable. This is due to a limitation with how the <code>Fn</code> family of traits are
defined: <code>Fn::Output</code> does not have a way to express a lifetime bound.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string msg("hello world");
  auto f = [=]() -&gt; const std::string &amp; {
    return msg;
  };
  std::cout &lt;&lt; f() &lt;&lt; std::endl;
}
</code></pre>
<pre><code class="language-rust ignore">fn main() {
    let msg = String::from("hello world");
    // fails to compile!
    let f = move || &amp;msg;

    println!("{}", f());
}</code></pre>
</div>
<p>The workarounds to this limitation in Rust involve either heap-allocating and
using a shared pointer <code>Rc</code> or defining a new trait instead of using one of the
<code>Fn</code> traits. The following example shows a trait that resembles a generalized
<code>Fn</code> trait and its use. In practice, however, it is usually better either to
define a custom trait for each use case or to elide the trait entirely if a
single struct is sufficient.</p>
<pre><pre class="playground"><code class="language-rust">trait Closure&lt;Args&gt; {
    // The lifetime parameter enables expressing
    // the bound.
    type Output&lt;'a&gt;
    where
        Self: 'a;

    // The bound from self can then be
    // provided to Output.
    fn call&lt;'a&gt;(
        &amp;'a self,
        args: Args,
    ) -&gt; Self::Output&lt;'a&gt;;
}

struct MyClosure {
    msg: String,
}

impl Closure&lt;()&gt; for MyClosure {
    type Output&lt;'a&gt; = &amp;'a str;

    fn call(&amp;self, _: ()) -&gt; &amp;str {
        &amp;self.msg
    }
}

fn main() {
    let f = MyClosure {
        msg: String::from("hello world"),
    };

    println!("{}", f.call(()));
}</code></pre></pre>
<h2 id="closures-ownership-and-fnonce"><a class="header" href="#closures-ownership-and-fnonce">Closures, ownership, and <code>FnOnce</code></a></h2>
<p>Closures are a part of Rust where the borrow checker is likely to cause
frustration for a C++ programmer. This is usually not because of lifetimes,
which have to be similarly considered in C++, but rather because C++ defaults to
copy semantics while Rust defaults to move semantics. For example, this small
adjustment to one of the earlier examples fails to compile.</p>
<pre><code class="language-rust ignore">fn main() {
    let greeting = "hello ".to_string();

    // Can't write the type of the closure
    let say_hello_to = move |who: &amp;str| {
        greeting + who
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre>
<p>This fails to compile because the <code>+</code> operator takes ownership of <code>greeting</code>,
which makes it no longer accessible for later invocations. Because of this, the
closure only implements <code>FnOnce</code>, not <code>Fn</code>, and therefore can only be called
once, because the call takes ownership of the closure itself.</p>
<pre><code class="language-text">error[E0382]: use of moved value: `say_hello_to`
 --&gt; example.rs:9:20
  |
8 |     println!("{}", say_hello_to("world"));
  |                    --------------------- `say_hello_to` moved due to this call
9 |     println!("{}", say_hello_to("moon"));
  |                    ^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `greeting` out of its environment
 --&gt; example.rs:6:26
  |
6 |         move |who: &amp;str| greeting + who;
  |                          ^^^^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; example.rs:8:20
  |
8 |     println!("{}", say_hello_to("world"));
  |
</code></pre>
<p>In many cases like this, the answer is to clone the value so that the copy owned
by the closure can be retained for future invocations.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello ".to_string();

    // Can't write the type of the closure
    let say_hello_to = move |who: &amp;str| {
        greeting.clone() + who
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
<p>If cloning isn't desired because it is too expensive, then the closure needs to
be redesigned to avoid giving away ownership of its captured variables.</p>
<h2 id="documentation-best-practices"><a class="header" href="#documentation-best-practices">Documentation best practices</a></h2>
<p>C++ often recommended to explicitly list captures in a lambda expression,
especially in situations where a closure will outlive its context. The purpose
of this is to assist in reasoning about the lifetimes of the captures to ensure
that the closure does not outlive any of the objects it has captured.</p>
<p>In Rust the same decisions about captures with respect to lifetimes have to be
made, but the compiler tracks them instead of having to do the reasoning
manually. That is, in spite of the type of the closure not being expressible, it
does still include the lifetimes of variables captured by reference, and so is
checked the same way that any other structure would be.</p>
<p>This results in the best practices for documenting closures in Rust not
including enumerating captures, even in situations where one would do so in C++.</p>
<p>The same is true about the destructibility of the content of the captures in a
closure. The example involving <code>FnOnce</code> functions in <a href="#closures-ownership-and-fnonce">the previous
section</a> may be a point of frustration
initially, but the behavior  the benefit of reducing the documentation and reasoning
burdens.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-impl-trait-impl">
<p>That is, one can write neither <code>impl From&lt;&amp;MyClosure&gt; for impl Fn() -&gt; usize {...}</code> nor <code>impl Into&lt;impl Fn() -&gt; usize&gt; for &amp;MyClosure {...}</code>. <a href="#fr-impl-trait-impl-1">â†©</a></p>
</li>
</ol>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Lambdas, closures,and function objects">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/rtti.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../idioms/object_identity.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/rtti.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../idioms/object_identity.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q3W4ES0FTM"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q3W4ES0FTM');
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
