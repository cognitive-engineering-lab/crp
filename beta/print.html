<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ to Rust Phrasebook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <meta property="og:description" content="A book to help translate C++ idioms into Rust.">
        <meta property="twitter:description" content="A book to help translate C++ idioms into Rust.">
        <meta name="twitter:card" content="summary">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c-to-rust-phrasebook"><a class="header" href="#c-to-rust-phrasebook">C++ to Rust Phrasebook</a></h1>
<p>This book is designed to help C++ programmers learn Rust. It provides translations of common C++ patterns into idiomatic Rust. Each pattern is described through concrete code examples along with high-level discussion of engineering trade-offs.</p>
<p>The book can be read front-to-back, but it is designed to be used random-access.
When you are writing Rust code and think, "I know how to do this in C++ but not Rust," then
look for the corresponding chapter in this book.</p>
<p>This book was hand-written by expert C++ and Rust programmers at Brown University's <a href="https://cel.cs.brown.edu/">Cognitive Engineering Lab</a>. Our goal is to provide accurate information with a tasteful degree of detail. No text in this book was written by AI.</p>
<p>If you would like updates on when we add new chapters to this book, you can <a href="https://forms.gle/rcrdZihmT81LWy6F6">drop your email here</a>.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>If you have zero Rust experience, you might consider first reading <a href="https://rust-book.cs.brown.edu/">The Rust Programming
Language</a> or getting a quick overview at <a href="https://learnxinyminutes.com/rust/">Learn X in Y Minutes</a>.</p>
<p>If you are primarily an embedded systems programmer using C or C++, this book is
a complement to <a href="https://docs.rust-embedded.org/book/">The Embedded Rust Book</a>.</p>
<p>Compared to resources like the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> and <a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>, this book is less about "Rust behind the scenes" and more about explicitly describing how Rust works in terms of C++.</p>
<h2 id="feedback-on-this-book"><a class="header" href="#feedback-on-this-book">Feedback on this book</a></h2>
<p>At the bottom of every page there is a link
to a form where you can submit feedback: typos, factual errors, or any other issues you spot.</p>
<p>If you answer the quizzes at the end of each chapter, we will save your
responses anonymously for research purposes.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>This work was supported by the DARPA under Agreement No. HR00112420354. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not reflect the views of our funders.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>In C++, constructors initialize objects. At the point when a constructor is executed, storage for the object has been
allocated and the constructor is only performing initialization.</p>
<p>Rust does not have constructors in the same way as C++. In Rust, there is a
single fundamental way to create an object, which is to initialize all of its
members at once. The term "constructor" or "constructor method" in Rust refers
to something more like a factory: a static method associated with a type (i.e.,
a method that does not have a <code>self</code> parameter), which returns a value of the
type.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;thread&gt;
</span><span class="boring">unsigned int cpu_count() {
</span><span class="boring">    return std::thread::hardware_concurrency();
</span><span class="boring">}
</span><span class="boring">
</span>class ThreadPool {
  unsigned int num_threads;

public:
  ThreadPool() : num_threads(cpu_count()) {}
  ThreadPool(unsigned int nt) : num_threads(nt) {}
};

int main() {
  ThreadPool p1;
  ThreadPool p2(4);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn cpu_count() -&gt; usize {
</span><span class="boring">    std::thread::available_parallelism().unwrap().get()
</span><span class="boring">}
</span><span class="boring">
</span>struct ThreadPool {
  num_threads: usize
}

impl ThreadPool {
    fn new() -&gt; Self {
        Self { num_threads: cpu_count() }
    }

    fn with_threads(nt: usize) -&gt; Self {
        Self { num_threads: nt }
    }
}

fn main() {
    let p1 = ThreadPool::new();
    let p2 = ThreadPool::with_threads(4);
}</code></pre></pre>
</div>
<p>In Rust, typically the primary constructor for a type is named <code>new</code>, especially if it
takes no arguments. (See the chapter on <a href="idioms/./constructors/default_constructors.html">default
constructors</a>.) Constructors based on
some specific property of the value are usually named <code>with_&lt;something&gt;</code>, e.g.,
<code>ThreadPool::with_threads</code>. See the <a href="https://rust-lang.github.io/api-guidelines/naming.html">naming
guidelines</a> for the
conventions on how to name constructor methods in Rust.</p>
<p>If the fields to be initialized are visible, there is a reasonable default
value, and the value does not manage a resource, then it is also common to use
record update syntax to initialize a value based on some default value.</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

impl Point {
    const fn zero() -&gt; Self {
        Self { x: 0, y: 0, z: 0 }
    }
}

fn main() {
    let x_unit = Point {
        x: 1,
        ..Point::zero()
    };
}</code></pre></pre>
<p>Despite the name, "record update syntax" does not modify a record but instead
creates a new value based on another one, taking ownership of it in order to do
so.</p>
<h2 id="storage-allocation-vs-initialization"><a class="header" href="#storage-allocation-vs-initialization">Storage allocation vs initialization</a></h2>
<p>In Rust, the actual construction of a structure or enum value occurs where the
structure construction syntax (e.g., <code>ThreadPool { ... }</code>) is, after the
evaluation of the expressions for the fields (e.g., <code>cpu_count()</code>).</p>
<p>A significant implication of this difference is that storage is not allocated
for a struct in Rust at the point where the constructor method (such as
<code>ThreadPool::with_threads</code>) is called, and in fact is not allocated until after the
values of the fields of a struct have been computed (in terms of the semantics
of the language — the optimizer may still avoid the copy). Therefore there is no
straightforward way in Rust to translate patterns such as a class which stores a pointer to
itself upon construction (in Rust, this requires tools like <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> and <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>).</p>
<h2 id="fallible-constructors"><a class="header" href="#fallible-constructors">Fallible constructors</a></h2>
<p>In C++, the primary way constructors can indicate failure is by throwing
exceptions. In Rust, because constructors are normal static methods, fallible
constructors can instead return <code>Result</code> (akin to <code>std::expected</code>) or <code>Option</code>
(akin to <code>std::optional</code>).<sup class="footnote-reference" id="fr-NonZero-1"><a href="#footnote-NonZero">1</a></sup></p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

class ThreadPool {
  unsigned int num_threads;

public:
  ThreadPool(unsigned int nt) : num_threads(nt) {
    if (num_threads == 0) {
      throw std::domain_error(
          "Cannot have zero threads");
    }
  }
};

int main() {
  try {
    ThreadPool p(0);
    // use p here
  } catch (const std::domain_error &amp;e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct ThreadPool {
    num_threads: usize,
}

#[derive(Debug)]
enum ThreadPoolError {
    ZeroThreads,
}

impl ThreadPool {
    fn with_threads(
        nt: usize,
    ) -&gt; Result&lt;Self, ThreadPoolError&gt; {
        if nt == 0 {
            Err(ThreadPoolError::ZeroThreads)
        } else {
            Ok(Self { num_threads: nt })
        }
    }
}

fn main() {
    match ThreadPool::with_threads(0) {
        Err(err) =&gt; println!("{:?}", err),
        Ok(p) =&gt; {
            // use p here
        }
    }
}</code></pre></pre>
</div>
<p>See <a href="idioms/./exceptions.html">the chapter on exceptions</a> for more information on
how C++ exceptions and exception handling translate to Rust.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-NonZero">
<p>An alternative approach here would be to use <code>NonZero&lt;usize&gt;</code> as the
type so that the error case wasn't possible in the first place. <a href="#fr-NonZero-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="default-constructors"><a class="header" href="#default-constructors">Default constructors</a></h1>
<p>C++ has a special concept of default constructors to support several scenarios
in which they are implicitly called.
Rust does not have the same notion of a default constructor. The most similar mechanism is the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code>
trait</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
    int age;

public:
    // Default constructor
    Person() : age(0) {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
   age: i32,
}

impl Person {
    pub const fn new() -&gt; Self {
        Self { age: 0 }
    }
}

impl Default for Person {
    fn default() -&gt; Self {
        Self::new()
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>If a structure has a useful default value (such as would be constructed by a
default constructor in C++), then the type should provide
<a href="https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits">both</a>
a <code>new</code> method that takes no arguments and an implementation of <code>Default</code>.</p>
<p>Because <code>Default</code> is a normal trait, the default constructor defined in the
example can be invoked using the usual syntax for invoking a static trait
method, e.g., <code>Default::default()</code>.</p>
<h2 id="implicit-initialization-of-class-members"><a class="header" href="#implicit-initialization-of-class-members">Implicit initialization of class members</a></h2>
<p>In C++, if a member is not explicitly initialized by a constructor, then it is
default-initialized. When the type of the member is a class, the
default-initialization invokes the default constructor.</p>
<p>In Rust, if all of the fields of a struct implement the <code>Default</code> trait, then an
implementation for the structure can be provided by the compiler.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
}

class Student {
  Person person;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The <code>#[derive(Default)]</code> macros in Rust are equivalent to writing the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
}

impl Default for Person {
    fn default() -&gt; Self {
        Self {
            age: Default::default()
        }
    }
}

struct Student {
    person: Person,
}

impl Default for Student {
    fn default() -&gt; Self {
        Self {
            person: Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike C++ where the default initialization value for integers is indeterminate,
in Rust the default value for the primitive integer and floating point types <a href="https://doc.rust-lang.org/std/primitive.i32.html#impl-Default-for-i32">is
zero</a>.</p>
<p><a name="struct-update"></a> Deriving the <code>Default</code> trait has a similar effect
on code concision as eliding initialization in C++. In situations where all of
the types implement the <code>Default</code> trait, but only some of the fields should have
their default values, one can use <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update
syntax</a>
to define a constructor method without enumerating the values for all of the
fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
    favorite_color: Option&lt;String&gt;,
}

impl Student {
    pub fn with_favorite_color(color: String) -&gt; Self {
        Student {
            favorite_color: Some(color),
            ..Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The performance of the struct update syntax <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyahSAVyVFyKxqiIEh1ZpgDC6embZMQAJnLOAGQImbAA5TwAjbFIpAE5yAAd0JWIHJjcPL19E5NShIJDwtiiYnnibbDs0kSIWUiIMz28ea2xbeyEauqICsMjog0tuxqyWofreopKpAEprdDNSVE4uAFIfAGZVgFYAIRxSAgA3bAgAEWwaFjN6Ihmds9WtAEEEswiAaktzOw/VaKUQg%2BqwA7Lsns8PlCPixgJwPgQNn4IaDHi8UZsdvtosdThcrjc7g8IW9Pt8zL8amYcMJgWCIdCPgkAY4/iymOQGdCrkcyMRsAB9DD0MggD4AeQSHSYqw2LhqhxMstwnPRILRzwhBDYCXoHypNKIdPBL0ZpI%2BNCYHwA7sQkAKeXyiILhWQIK6YvqiIrgDMPgBaZX6to0Y1cxlQg3MI2gk2QiMJx2HZ1C9yi/XoDjutOkObhhPQgB0hfx11uIBAOAJtwg91NBdR%2BcbarOXDm9G42343i4OnI6G4ACULEbAYtlsDNnxyERtG25gBrEDbLSGbjSfhsZernt9gdcfhKECr2e9tvkOCwFAYHUMaKUag3hJ3mKkHgADhBq7otwB1Aic7kBEwR1AAntw07AawpCgeKES6JUp7TjeHDCOKTD0OBZ7kDgERmMALgSPQR68PwOBsMYwCSNhhCkIhuIkX22DqJUZjOhB/DBM6HbYfQBARKQYFuDggHetqHHkCcpARMk2AXBRJh8SYc5zDQRjAEoABqBDYNakrMBJgjCGIEicDIcjCMoaiaNh%2BgtEYynmJYhj8UekBzOgUppCR/ouB8nlEP6jAnPQspnD4/DoFJhw4G5tatO0aROEwrjuE0Uh%2BIEwR9MUAzvjkKTSiMzR%2BEkhVpJM/QxPlFRVJ0tT1MVGUJfR9XdJVuXVdYDUNGlox%2BOMPTZVMeVzGOSxme2nbdoB%2B4fE5RCoB8PCFp%2BhZaB8ED4MQZCThsPAzPwp46DMcxINgLAHNQi7bmuXAbuQu6Rdwh7HjOKlTVwEXkFu0jbOtWjSGU748NsPggz4IIAGyPbNL3vWecyXgg8AQNeWB4IQJAUFQtB3qwHCGfIJmSOZRmKCoGiAfofgOaYI4tXV3gQM4TUtFlhRVVILRlXk6R9c0BV8x10w8GMbStUwXSNQLgwS0z0tDZznXc91wyy2MPUiwMYtjQsE3cOsWx7AcuLnJcZZEtsGrmuSvz/KQgJWrG%2BawvCiLIi2KLopiJs4ic5vVlbNvvF83oUkaUa0i79ZQsyjusg7TuqvGUJJvyqYip6krSrK8piUqGwqii6re882q6l61LRmGsdMqHlo2naDosLyyYujm2ZZ2KCrBL6AZBiIIa16nEaMEabBsV8wIbGcwb0DQFZVpbtaynGBZfIW6cph6M9zyImanB69wbOvBZKE2pctuePFdrD2H7sOlhfPrE5G99x3zuQ52XQM8VLiuO6D0twbBBIWbY989zwyPCeFSF5EBozQJmZ8jAcaPmQS%2BEAb5PzfgYM6R2/5AJQTAhJYhME4IITsBJFC0Z0KYUArhfChF6DEQkuRSi1E%2By0XoicRi/BmKsXYqRSgwg2iAT4gJISGNRKHC3MIqSMkVDyQ4X3OBalYRaR0npZkPZpzkxJmZWQ5MrJU1stkOmWCGYSLih5LyQgfJ%2BQCkFbAIUwrfSitEGK2AbGM2lMlVKmRBYcxyqLIWRUNZhIqsNLm4tEptRloEuWcSpZa2iSrTW6tEkZImGk0WetxycB8J9O%2BT1%2BzcHmiOJaK01obS2ljXa79DoIxOmdC6V1/63R4g9Up%2B5XqwMRp9b6W5tjSELLEWI2x3xaA/NIEEH4QQ%2BD%2BpA56B5mlfyXDwLQq4eIbBmg/eGn9TqSQBElaQQA%3D%3D%3D">is up to the optimizer</a>.</p>
<h2 id="implicit-initialization-of-array-values"><a class="header" href="#implicit-initialization-of-array-values">Implicit initialization of array values</a></h2>
<p>In C++, arrays without explicit initialization are default-initialized using the
default constructors.</p>
<p>In Rust, the value with which to initialize the array must be provided.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
};

int main() {
  Person people[3];
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    // std::array::from_fn provides the index to the callback
    let people: [Person; 3] =
        std::array::from_fn(|_| Default::default());
    // ...
}</code></pre></pre>
</div>
<p>If the type happens to be <a href="idioms/constructors/./copy_and_move_constructors.html#trivially-copyable-types">trivially
copyable</a>,
then a shorthand can be used.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: [Person; 3] = [Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="container-element-initialization"><a class="header" href="#container-element-initialization">Container element initialization</a></h2>
<p>In C++, the default constructor could be used to implicitly define collection
types, such as <code>std::vector</code>. Before C++11, one value would be default
constructed, and the elements would be copy constructed from that initial
element. Since C++11, all elements are default constructed.</p>
<p>As with array initialization, the values must be explicitly specified in Rust.
The vector can be constructed from an array, enabling the same syntax as with
arrays.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;vector&gt;

class Person {
    int age;

public:
    Person() : age(0) {}
}

int main() {
    std::vector&lt;Person&gt; people(3);
    // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    let people_arr: [Person; 3] =
        std::array::from_fn(|_| Default::default());
    let people: Vec&lt;Person&gt; = Vec::from(people_arr);
    // ...
}</code></pre></pre>
</div>
<p>In Rust, the vector can also be constructed <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html#methods-that-produce-other-iterators">from an
iterator</a>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: Vec&lt;Person&gt; = (0..3).map(|_| Default::default()).collect();
    // ...
}</code></pre></pre>
<p>If the type implements the <code>Clone</code> trait, then the array can be constructed
using the <code>vec!</code> macro. See the chapter on <a href="idioms/constructors/./copy_and_move_constructors.html">copy
constructors</a> for more
details on <code>Clone</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: Vec&lt;Person&gt; = vec![Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="implicit-initialization-of-local-variables"><a class="header" href="#implicit-initialization-of-local-variables">Implicit initialization of local variables</a></h2>
<p>In C++, the default constructor is used to perform default-initialization of
local variables that are not explicitly initialized.</p>
<p>In Rust, initialization of local variables is always explicit.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
    int age;

public:
    Person() : age(0) {}
};

int main() {
    Person person;
    // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let person = Person::default();
    // ...
}</code></pre></pre>
</div>
<h2 id="implicit-initialization-of-the-base-class-object"><a class="header" href="#implicit-initialization-of-the-base-class-object">Implicit initialization of the base class object</a></h2>
<p>In C++, the default constructor is used to initialize the base class object if
no other constructor is specified.</p>
<pre><code class="language-cpp">class Base {
  int x;

public:
  Base() : x(0) {}
};

class Derived : Base {
public:
  // Calls the default constructor for Base
  Derived() {}
};
</code></pre>
<p>Since Rust does not have inheritance, there is no equivalent to this case.
See the chapter on <a href="idioms/constructors/../data_modeling/inheritance_and_reuse.html">implementation
reuse</a> or the section on <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits
in the Rust book</a> for
alternatives.</p>
<h2 id="stdunique_ptr"><a class="header" href="#stdunique_ptr"><code>std::unique_ptr</code></a></h2>
<p>There are some additional cases where the <code>Default</code> trait is used in Rust, but
default constructors are not used for initialization in C++.</p>
<p>Rust's equivalent of smart pointers implement <code>Default</code> by delegating to the
<code>Default</code> implementation of the contained type.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    let b: Box&lt;Person&gt; = Default::default();
    // ...
}</code></pre></pre>
<p>This differs from the treatment of <code>std::unique_ptr</code> in C++ because unlike <code>Box</code>,
<code>std::unique_ptr</code> is nullable, and so the default constructor for
<code>std:unique_ptr</code> produces a pointer that owns nothing. The equivalent type in
Rust is <code>Option&lt;Box&lt;Person&gt;&gt;</code>, for which the <code>Default</code> implementation produces
<code>None</code>.</p>
<h2 id="other-uses-of-default"><a class="header" href="#other-uses-of-default">Other uses of <code>Default</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>
makes use of <code>Default</code>, which makes getting a default value when the <code>Option</code>
does not contain a value more convenient.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;optional&gt;
#include &lt;string&gt;

void go(std::optional&lt;std::string&gt; x) {
  std::string a =
      x.or_else([]() {
         return std::make_optional&lt;std::string&gt;();
       }).value();
  // if x was nullopt, then a is ""

  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: Option&lt;String&gt;) {
    let a: String = x.unwrap_or_default();
    // if x was None, then a is ""

    // ...
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In C++ <code>std::optional::value_or</code> is not equivalent, because it would always
construct the default, as opposed to only constructing the default when the
<code>std::optional</code> is <code>std::nullopt</code>. The equivalent requires using
<code>std::optional::or_else</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;default_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust does not have implicit default initialization like C++ does. Variables must\nbe explicitly initialized before use, or the program will fail to compile.\n&quot;,&quot;id&quot;:&quot;5019323d-1534-4c70-a8e7-b015f87be228&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `w` is not explicitly initialized before it is used.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile because `Widget` does not implement the `Default` trait.\n&quot;,&quot;It does not compile because `Widget` does not implement a `new` method.\n&quot;,&quot;It does not compile because `Widget` does not implement both the `Default`\ntrait and a `new` method.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\nstruct Widget {\n    color: String,\n}\n\nfn main() {\n    let w: Widget;\n    println!(\&quot;{}\&quot;, w.color);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;When there is a reasonable default value, it is most idiomatic in Rust to\nprovide [both a `new` method and an implementation of the `Default`\ntrait.](https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits)\n\nIn this case, an even more idiomatic implementation would be to [derive\n`Default`](https://doc.rust-lang.org/std/default/trait.Default.html#derivable)\nand use the derived method to implement new.\n&quot;,&quot;id&quot;:&quot;a436177e-821d-45d1-8e46-4fafc3d78cd3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Vec2 {\n     pub fn new() -&gt; Self {\n        Vec2 { x: 0.0, y: 0.0 }\n     }\n}\n\nimpl Default for Vec2 {\n     fn default() -&gt; Self {\n        Self::new()\n     }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Vec2 {\n     pub fn new() -&gt; Self {\n        Vec2 { x: 0.0, y: 0.0 }\n     }\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Default for Vec2 {\n     fn default() -&gt; Self {\n        Self::new()\n     }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n\n    Vec2() : x(0.0), y(0.0) {}\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-move-constructors"><a class="header" href="#copy-and-move-constructors">Copy and move constructors</a></h1>
<p>In both C++ and Rust, one rarely has to write copy or move constructors (or
their Rust equivalents) by hand. In C++ this is because the implicit definitions
are good enough for most purposes, especially when using smart pointers (i.e.,
following <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of
zero</a>). In Rust this
is because move semantics are the default, and the automatically derived
implementations of the <code>Clone</code> and <code>Copy</code> traits are good enough for most
purposes.</p>
<p>For the following C++ classes, the implicitly defined copy and move constructors
are sufficient. The equivalent in Rust uses a derive macro provided by the
standard library to implement the corresponding traits.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">#include &lt;string&gt;
</span><span class="boring">
</span>struct Age {
  unsigned int years;

  Age(unsigned int years) : years(years) {}

  // copy and move constructors and destructor
  // implicitly declared and defined
};

struct Person {
  Age age;
  std::string name;
  std::shared_ptr&lt;Person&gt; best_friend;

  Person(Age age,
         std::string name,
         std::shared_ptr&lt;Person&gt; best_friend)
      : age(std::move(age)), name(std::move(name)),
        best_friend(std::move(best_friend)) {}

  // copy and move constructors and destructor
  // implicitly declared and defined
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Clone, Copy)]
struct Age {
    years: u32,
}

#[derive(Clone)]
struct Person {
    age: Age,
    name: String,
    best_friend: Rc&lt;Person&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>std::shared_ptr</code> and <code>Rc</code> differ slightly in terms of thread-safety. See the chapter on <a href="idioms/constructors/../type_equivalents.html#pointers">type
equivalents</a> for more details.</p>
</div>
<h2 id="user-defined-constructors"><a class="header" href="#user-defined-constructors">User-defined constructors</a></h2>
<p>On the other hand, the following example requires a user-defined copy and move
constructor because it manages a resource (a pointer acquired from a C library).
The equivalent in Rust requires a custom implementation of the <code>Clone</code> trait.<sup class="footnote-reference" id="fr-deleter-1"><a href="#footnote-deleter">1</a></sup></p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t *);
void copy_widget(widget_t *dst, widget_t *src);

// widget.cc
class Widget {
  widget_t *widget;

public:
  Widget() : widget(alloc_widget()) {}

  Widget(const Widget &amp;other) : widget(alloc_widget()) {
    copy_widget(widget, other.widget);
  }

  Widget(Widget &amp;&amp;other) : widget(other.widget) {
    other.widget = nullptr;
  }

  ~Widget() {
    free_widget(widget);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod example {
</span>mod widget_ffi {
    // Models an opaque type.
    // See https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs
    #[repr(C)]
    pub struct CWidget {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(
            *mut u8,
            core::marker::PhantomPinned,
        )&gt;,
    }

    extern "C" {
        pub fn make_widget() -&gt; *mut CWidget;
        pub fn copy_widget(
            dst: *mut CWidget,
            src: *mut CWidget,
        );
        pub fn free_widget(ptr: *mut CWidget);
    }
}

use self::widget_ffi::*;

struct Widget {
    widget: *mut CWidget,
}

impl Widget {
    fn new() -&gt; Self {
        Widget {
            widget: unsafe { make_widget() },
        }
    }
}

impl Clone for Widget {
    fn clone(&amp;self) -&gt; Self {
        let widget = unsafe { make_widget() };
        unsafe {
            copy_widget(widget, self.widget);
        }
        Widget { widget }
    }
}

impl Drop for Widget {
    fn drop(&amp;mut self) {
        unsafe { free_widget(self.widget) };
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</div>
<p>Just as with how in C++ it is uncommon to need user-defined implementations for
copy and move constructors or user-defined implementations for destructors, in
Rust it is rare to need to implement the <code>Clone</code> and <code>Drop</code> traits by hand for
types that do not represent resources.</p>
<p>There is one exception to this. If the type has type parameters, it might be
desirable to implement <code>Clone</code> (and <code>Copy</code>) manually even if the clone should be
done field-by-field. See the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#how-can-i-implement-clone">standard library documentation of
<code>Clone</code></a>
and <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#how-can-i-implement-copy">of
<code>Copy</code></a>
for details.</p>
<h2 id="trivially-copyable-types"><a class="header" href="#trivially-copyable-types">Trivially copyable types</a></h2>
<p>In C++, a class type is trivially copyable when it has no non-trivial copy
constructors, move constructors, copy assignment operators, move assignment
operators and it has a trivial destructor. Values of a trivially copyable type
are able to be copied by copying their bytes.</p>
<p>In the first C++ example above, <code>Age</code> is trivially copyable, but <code>Person</code> is
not. This is because despite using a default copy constructor, the constructor
is not trivial because <code>std::string</code> and <code>std::shared_ptr</code> are not trivially
copyable.</p>
<p>Rust indicates whether types are trivially copyable with the <code>Copy</code> trait. Just
as with trivially copyable types in C++, values of types that implement <code>Copy</code>
in Rust can be copied by copying their bytes. Rust requires explicit calls to
the <code>clone</code> method to make copies of values of types that do not implement
<code>Copy</code>.</p>
<p>In the first Rust example above, <code>Age</code> implements the <code>Copy</code> trait but <code>Person</code>
does not. This is because neither <code>std::String</code> nor <code>Rc&lt;Person&gt;</code> implement
<code>Copy</code>. They do not implement <code>Copy</code> because they own data that lives on the
heap, and so are not trivially copyable.</p>
<p>Rust prevents implementing <code>Copy</code> for a type if any of its fields are not
<code>Copy</code>, but does not prevent implementing <code>Copy</code> for types that should not be
copied bit-for-bit due to their intended meaning, which is usually indicated by
a user-defined <code>Clone</code> implementation.</p>
<p>Rust does not permit the implementation of both <code>Copy</code> and <code>Drop</code> for the same
type. This aligns with the C++ standard's requirement that trivially copyable
types not implement a user-defined destructor.</p>
<h2 id="move-constructors"><a class="header" href="#move-constructors">Move constructors</a></h2>
<p>In Rust, all types support move semantics by default, and custom move semantics
cannot be (and do not need to be) defined. This is because what "move" means in
Rust is not the same as it is in C++. In Rust, moving a value means changing
what owns the value. In particular, there is no "old" object to be destructed
after a move, because the compiler will prevent the use of a variable whose
value has been moved.</p>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment operators</a></h2>
<p>Rust does not have a copy or move assignment operator. Instead, assignment
either moves (by transferring ownership), explicitly clones and then moves, or
implicitly copies and then moves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Box::&lt;u32&gt;::new(5);
    let y = x; // moves
    let z = y.clone(); // explicitly clones and then moves the clone
    let w = *y; // implicitly copies the content of the Box and then moves the copy
}</code></pre></pre>
<p>For situations where something like a user-defined copy assignment could avoid
allocations, the <code>Clone</code> trait has an additional method called <code>clone_from</code>. The
method is automatically defined, but can be overridden when implementing the
<code>Clone</code> trait to provide an efficient implementation. The default implementation
is the same as calling <code>Clone::clone</code> and performing a normal assignment.</p>
<p>The method is not used for normal assignments, but can be explicitly used in
situations where the performance of the assignment is significant and would be
improved by using the more efficient implementation, if one is defined. The
implementation can be made more efficient because <code>clone_from</code> takes ownership
of the object to which the values are being assigned, and so can do things like
reuse memory to avoid allocations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: &amp;Vec&lt;u32&gt;) {
    let mut y = vec![0; x.len()];
    // ...
    y.clone_from(&amp;x);
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-concerns-and-copy"><a class="header" href="#performance-concerns-and-copy">Performance concerns and <code>Copy</code></a></h2>
<p>The decision to implement <code>Copy</code> should be based on the semantics of the type,
not on performance. If the size of objects being copied is a concern, then one
should instead use a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) or put the value on the heap
(<a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> or
<a href="https://doc.rust-lang.org/std/rc/index.html"><code>Rc&lt;T&gt;</code></a>). These approaches
correspond to passing by reference, or using a <code>std::unique_ptr</code> or
<code>std::shared_ptr</code> in C++.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;copy_and_move_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;A type can only implement `Copy` if all of its fields implement `Copy`, just how\nin C++ a type is only trivially copyable if all of its members are. `Box` does\nnot implement `Copy`.\n&quot;,&quot;id&quot;:&quot;ec3c58d9-cb13-4f88-ac67-7c1d5baf46e2&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `Box` doesn't implement `Copy`, so `Copy` can't be\nimplemented for `BinaryTreeNode`.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile because `Box` doesn't implement `Clone`, so `Clone` can't be\nderived for `BinaryTreeNode`.\n&quot;,&quot;It does not compile because only one of `Clone` or `Copy` can be implemented for\na type.\n&quot;,&quot;It does not compile because `Drop` is not implemented for `BinaryTreeNode`\neven though `Clone` is.\n&quot;],&quot;prompt&quot;:&quot;Does the following program compile?\n\n```rust\n#[derive(Clone, Copy)]\nstruct BinaryTreeNode {\n    value: i32,\n    left_child: Option&lt;Box&lt;BinaryTreeNode&gt;&gt;,\n    right_child: Option&lt;Box&lt;BinaryTreeNode&gt;&gt;,\n}\n```\n&quot;}},{&quot;context&quot;:&quot;While `Copy` requires `Clone`, it does not pose any constraints on the\nimplementation of clone. Even though the given implementation of `Clone` is most\ncertainly wrong, the program will still compile.\n&quot;,&quot;id&quot;:&quot;0a4bc647-44c9-4244-9dfc-3002d6abc069&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does compile, but implementing `Clone` in a way that doesn't match `Copy` is\na bad idea.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because only one of `Clone` or `Copy` can be implemented\nfor a type.\n&quot;,&quot;It does not compile because `Clone` must be derived in order to derive `Copy`.\n&quot;,&quot;It does not compile because `Drop` is not implemented for `Age` even though\n`Clone` is.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n#[derive(Copy)]\nstruct Age {\n    value: u32,\n}\n\nimpl Clone for Age {\n    fn clone(&amp;self) -&gt; Self {\n       Age {\n           value: 1 + self.value,\n       }\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The C++ `Vec2` implements a copy constructor which corresponds to the `Clone`\ntrait in Rust. It is also trivially copyable, which corresponds to implementing\nthe `Copy` trait in Rust.\n&quot;,&quot;id&quot;:&quot;4636f71a-599b-46d3-a6e6-e0c35b344140&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n#[derive(Clone, Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n#[derive(Clone)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\n#[derive(Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n};\n```\n&quot;}},{&quot;context&quot;:&quot;The C++ `Vec2` has a user-defined copy constructor which corresponds to the\n`Clone` trait in Rust. Despite being user-defined, it does exactly what the\ndefault trait would do. Because the implementation is user-defined, it prevents\nthe type from being trivially copyable, which corresponds to not implementing\nthe `Copy` trait in Rust.\n&quot;,&quot;id&quot;:&quot;c8e3b4da-19a1-42e9-97d4-bbb61dcd5652&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n#[derive(Clone)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n#[derive(Clone, Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\n#[derive(Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n\n    Vec2(const Vec2 &amp;other) : x(other.x), y(other.y) {};\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><hr>
<ol class="footnote-definition"><li id="footnote-deleter">
<p>Another common approach to the C++ version of the example is to use
the <code>Deleter</code> template argument for <code>std::unique_ptr</code>. The version shown in
the example was chosen to make the correspondence to Rust version clearer. <a href="#fr-deleter-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="rule-of-threefivezero"><a class="header" href="#rule-of-threefivezero">Rule of three/five/zero</a></h1>
<h2 id="rule-of-three"><a class="header" href="#rule-of-three">Rule of three</a></h2>
<p>In C++ the rule of three is a rule of thumb that if a class has a user-defined
destructor, copy constructor or copy assignment operator, it probably should
have all three.</p>
<p>The corresponding rule for Rust is that if a type has a user-defined <code>Clone</code> or
<code>Drop</code> implementation, it probably needs both. This is for the same reason as
the rule of three in C++: if a type has a user-defined implementation for
<code>Clone</code> or <code>Drop</code>, it is probably because the type manages a resource, and both
<code>Clone</code> and <code>Drop</code> will need to take special actions for the resource.</p>
<h2 id="rule-of-five"><a class="header" href="#rule-of-five">Rule of five</a></h2>
<p>The rule of five in C++ states that if move semantics are needed for a type with
a user-defined copy constructor or copy assignment operator, then a user-defined
move constructor and move assignment should also be provided, because no
implicit move constructor or move assignment operator will be generated.</p>
<p>In Rust, this rule is not relevant because of the <a href="idioms/constructors/copy_and_move_constructors.html#move-constructors">difference in move semantics
between C++ and Rust.</a></p>
<h2 id="rule-of-zero"><a class="header" href="#rule-of-zero">Rule of zero</a></h2>
<p>The rule of zero states that classes with user-defined copy/move constructors,
assignment operators, and destructors should deal only with ownership, and other
classes should not have those constructors or destructors. In practice, most
classes should make use of types from the STL (<code>shared_ptr</code>, <code>vector</code>, etc.) for
dealing with ownership concerns so that the implicitly defined copy and move
constructors are sufficient.</p>
<p>In Rust, the same is true. See the list of Rust type equivalents for equivalents
of C++ <a href="idioms/constructors/../type_equivalents.html#pointers">smart pointer types</a> and
equivalents of C++ <a href="idioms/constructors/../type_equivalents.html#containers">container types</a>.</p>
<p>One difference between C++ and Rust in applying the rule of zero is that in C++
<code>std::unique_ptr</code> can take a custom deleter, making it possible to use
<code>std::unique_ptr</code> for wrapping raw pointers that require custom destruction
logic. In Rust, the <code>Box</code> type is not parameterized in the same way. To
accomplish the same goal, one instead must define a new type with a user-defined
<code>Drop</code> implementation, as is done in <a href="idioms/constructors/./copy_and_move_constructors.html#user-defined-constructors">the example in the chapter on copy and
move
constructors</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;rule_of_three_five_zero&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;cddc736a-b6c3-4f3f-a3a7-b42eb362d650&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`Clone`&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Move`&quot;,&quot;`Copy`&quot;],&quot;prompt&quot;:&quot;If the `Drop` trait is implemented for a type in Rust, which other traits should\nprobably be implemented?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="destructors-and-resource-cleanup"><a class="header" href="#destructors-and-resource-cleanup">Destructors and resource cleanup</a></h1>
<p>In C++, a destructor for a class <code>T</code> is defined by providing a special member
function <code>~T()</code>. To achieve the equivalent in Rust, the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code>
trait</a> is implemented for a
type.</p>
<p>For an example, see <a href="idioms/./constructors/copy_and_move_constructors.html#user-defined-constructors">the chapter on copy and move
constructors</a>.</p>
<p><code>Drop</code> implementations play the same role as destructors in C++ for types that
manage resources. That is, they enable cleanup of resources owned by the value
at the end of the value's lifetime.</p>
<p>In Rust the <code>Drop::drop</code> method of a value is called automatically by a
destructor when the variable that owns the value goes out of scope. Unlike in
C++, the drop method cannot be called manually. Instead the automatic "drop
glue" implicitly calls the destructors of fields.</p>
<h2 id="lifetimes-destructors-and-destruction-order"><a class="header" href="#lifetimes-destructors-and-destruction-order">Lifetimes, destructors, and destruction order</a></h2>
<p>C++ destructors are called in reverse order of construction when variables go
out of scope, or for dynamically allocated objects, when they are deleted. This
includes destructors of moved-from objects.</p>
<p>In Rust, the drop order for items going out of scope is similar to that of C++
(reverse order of declaration). If additional specific details about the drop
order are needed (e.g., for writing unsafe code), the full rules for the drop
order are described in <a href="https://doc.rust-lang.org/reference/destructors.html">the language
reference</a>. However,
moving an object in Rust does not leave a moved-from object on which a
destructor will be called.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A {
  int id;

  A(int id) : id(id) {}

  // copy constructor
  A(A &amp;other) : id(other.id) {}

  // move constructor
  A(A &amp;&amp;other) : id(other.id) {
    other.id = 0;
  }

  // destructor
  ~A() {
    std::cout &lt;&lt; id &lt;&lt; std::endl;
  }
};

int accept(A x) {
  return x.id;
} // the destructor of x is called after the
  // return expression is evaluated

// Prints:
// 2
// 3
// 0
// 1
int main() {
  A x(1);
  A y(2);

  accept(std::move(y));

  A z(3);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct A {
    id: i32,
}

impl Drop for A {
    fn drop(&amp;mut self) {
        println!("{}", self.id)
    }
}

fn accept(x: A) -&gt; i32 {
    return x.id;
}

// Prints:
// 2
// 3
// 1
fn main() {
    let x = A { id: 1 };
    let y = A { id: 2 };

    accept(y);

    let z = A { id: 3 };
}</code></pre></pre>
</div>
<p>In Rust, after ownership of <code>y</code> is moved into the function <code>accept</code>, there is
no additional object remaining, and so there is no additional <code>Drop::drop</code> call
(which in the C++ example prints <code>0</code>).</p>
<p>Rust's drop methods do run when leaving scope due to a panic, though not if the
panic occurs in a destructor that was called in response to an initial panic.</p>
<p>The drop order of fields in Rust is essentially the reverse of that of
non-static class members in C++. Again, the specific details of what happens in
a Rust destructor are given in <a href="https://doc.rust-lang.org/reference/destructors.html#r-destructors.operation">the language
reference</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

struct Part {
  std::string name;

  ~Part() {
    std::cout &lt;&lt; "Dropped " &lt;&lt; name &lt;&lt; std::endl;
  }
};

struct Widget {
  Part part1;
  Part part2;
  Part part3;
};

int main() {
  Widget w{"1", "2", "3"};
  // Prints:
  // 3
  // 2
  // 1
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Part(&amp;'static str);

impl Drop for Part {
    fn drop(&amp;mut self) {
        println!("{}", self.0);
    }
}

struct Widget {
    part1: Part,
    part2: Part,
    part3: Part,
}

fn main() {
    let w = Widget {
        part1: Part("1"),
        part2: Part("2"),
        part3: Part("3"),
    };
    // Prints:
    // 1
    // 2
    // 3
}</code></pre></pre>
</div>
<h2 id="early-cleanup-and-explicitly-destroying-values"><a class="header" href="#early-cleanup-and-explicitly-destroying-values">Early cleanup and explicitly destroying values</a></h2>
<p>In C++ you can explicitly destroy an object. This is mainly useful for
situations where placement new has been used to allocate the object at a
specific memory location, and so the destructor will not be implicitly called.</p>
<p>However, once the destructor has been explicitly called, <a href="https://eel.is/c++draft/class.dtor#note-8">it may not be called
again, even implicitly</a>. Thus the
destructor can't be used for early cleanup. Instead, either the class must be
designed with a separate cleanup method that releases the resources but leaves
the object in a state where the destructor can be called or the function using
the object must be structured so that the variable goes out of scope at the
desired time.</p>
<p>In Rust, values can be dropped early for early cleanup by using
<a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>. This works
because (<a href="idioms/./constructors/copy_and_move_constructors.html#trivially-copyable-types">for non-<code>Copy</code>
types</a>)
ownership of the object is actually transferred to <code>std::mem::drop</code> function,
and so <code>Drop::drop</code> is called at the end of <code>std::mem::drop</code> when the lifetime
of the parameter ends.</p>
<p>Thus, <code>std::mem::drop</code> can be used for early cleanup of resources without having
to restructure a function to force variables out of scope early.</p>
<p>For example, the following allocates a large vector on the heap, but explicitly
drops it before allocating a second large vector on the heap, reducing the
overall memory usage.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![0u32; 100000];
    // ... use v

    std::mem::drop(v);
    // can no longer use v here

    let v2 = vec![0u32; 100000];
    // ... use v2
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;destructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The call to `passthrough` moves ownership of the value in `w` into the\nfunction's parameter, and then moves ownership back out again when it returns,\nso that `w2` ends up owning the value. None of those steps cause `drop` to be\ncalled because no initialized variable goes out of scope. When the ownership of\nthe value is moved from the `w` into the parameter, or from the `a` in the\n`passthrough` function to `w2`, `w` and `a` are left uninitialized.\n\nAt the end of `main`, `w2` is dropped first, since it is declared last. Then its\nmembers are dropped in order of declaration in the struct definition. Each field\nis completely destructed before the next field is, thus when the `Box` in field\n`boxed_sub` is dropped, it drops the value it owns before the value in `sub` is\ndropped. Finally `s3`, is dropped.\n\n`w`, `s2`, and `s1` are not dropped because they are not initialized.\n&quot;,&quot;id&quot;:&quot;9132e738-cc0b-4ba5-a323-9200b99bcbc4&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;3\n1\n2\n4\n&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;struct SubWidget {\n    id: i32,\n}\n\nimpl Drop for SubWidget {\n    // Prints the id and then sets it to 0\n    fn drop(&amp;mut self) {\n        println!(\&quot;{}\&quot;, self.id);\n        self.id = 0;\n    }\n}\n\nstruct Widget {\n    id: i32,\n    boxed_sub: Box&lt;SubWidget&gt;,\n    sub: SubWidget,\n}\n\nimpl Drop for Widget {\n    // Prints the id and then sets it to 0\n    fn drop(&amp;mut self) {\n        println!(\&quot;{}\&quot;, self.id);\n        self.id = 0;\n    }\n}\n\nfn passthrough(a: Widget) -&gt; Widget {\n    a\n}\n\nfn accept(a: Widget) {}\n\nfn main() {\n    let s1 = Box::new(SubWidget { id: 1 });\n    let s2 = SubWidget { id: 2 };\n    let w = Widget {\n        id: 3,\n        sub: s2,\n        boxed_sub: s1,\n    };\n    let s3 = SubWidget { id: 4 };\n\n    let w2 = passthrough(w);\n}\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="data-modeling"><a class="header" href="#data-modeling">Data modeling</a></h1>
<p>In C++ the mechanisms available for data modeling are classes, enums, and
unions.</p>
<p>Rust, on the other hand, uses records
(<a href="https://doc.rust-lang.org/book/ch05-00-structs.html">structs</a>) and algebraic
data types (<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">enums</a>).</p>
<p>Although Rust supports one major piece of object oriented design, polymorphism
using interfaces, Rust also has language features for modeling things using
algebraic data types (which in simple cases are like a much more ergonomic
<code>std::variant</code>).</p>
<p>This section gives examples of common constructions used when programming in C++
and how to achieve the same effects using Rust's features.</p>
<h2 id="fixed-operations-varying-data"><a class="header" href="#fixed-operations-varying-data">Fixed operations, varying data</a></h2>
<p>In situations where one needs to model a fixed set of operations that clients
will use, but the data that implements those operations are not fixed ahead of
time, the approach in C++ and the approach in Rust are the same. In both cases
interfaces that define the required operations are defined. Concrete types,
possibly defined by the client, implement those interfaces.</p>
<p>This way of modeling data can make use of either
<a href="idioms/./data_modeling/abstract_classes.html">dynamic</a> or <a href="idioms/./data_modeling/concepts.html">static
dispatch</a>, each of which is covered in its
own section.</p>
<h2 id="fixed-data-varying-operations"><a class="header" href="#fixed-data-varying-operations">Fixed data, varying operations</a></h2>
<p>In situations where there is a fixed set of data but the operations that the
data must support vary, there are a few approaches in C++. Which approaches are
available to use depend on the version of the standard in use.</p>
<p>In older versions of the standard, one might use manually defined tagged unions.
In newer versions, <code>std::variant</code> is available to improve the safety and
ergonomics of tagged unions. <a href="idioms/./data_modeling/tagged_unions.html">Both of these approaches map to the same approach
in Rust</a>.</p>
<p>Additionally, despite it not being strictly necessary to model a fixed set of
variants, the visitor pattern is sometimes used for this situation, especially
when using versions of the C++ standard before the introduction of
<code>std::variant</code>. In most of these cases the idiomatic Rust solution is the same
as what one would do when converting a C++ solution that uses <a href="idioms/./data_modeling/tagged_unions.html">tagged
unions</a>. The chapter on the <a href="idioms/../patterns/visitor.html">visitor
pattern</a> describes when to use a Rust version of the
visitor pattern or when to use Rust's enums (which are closer to <code>std::variant</code>
than to C++ enums) to model the data.</p>
<h2 id="varying-data-and-operations"><a class="header" href="#varying-data-and-operations">Varying data and operations</a></h2>
<p>When both data and operations may be extended by a client, the required
solutions are more complex. In C++, the approach usually involves some kind of
extension to the <a href="idioms/../patterns/visitor.html">visitor pattern</a> along with dynamic
casting. Because Rust does not support the kind of RTTI necessary for a dynamic
cast operator, different approaches need to be used. Some of those approaches
are discussed in the <a href="idioms/../patterns/visitor.html#expression-problem">chapter on the visitor
pattern</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes-interfaces-and-dynamic-dispatch"><a class="header" href="#abstract-classes-interfaces-and-dynamic-dispatch">Abstract classes, interfaces, and dynamic dispatch</a></h1>
<p>In C++ when an interface will be used with dynamic dispatch to resolve invoked
methods, the interface is defined using an abstract class. Types that implement
the interface inherit from the abstract class. In Rust the interface is given by
a <em>trait</em>, which is then implemented for the types that support that trait.
Programs can then be written over <em>trait objects</em> that use that trait as their
base type.</p>
<p>The following example defines an interface, two implementations of that
interface, and a function that takes an argument that satisfies the interface.
In C++ the interface is defined with an abstract class with pure virtual
methods, and in Rust the interface is defined with a trait. In both languages,
the function (<code>printArea</code> in C++ and <code>print_area</code> in Rust) invokes a method
using dynamic dispatch.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

// Define an abstract class for an interface
struct Shape {
  Shape() = default;
  virtual ~Shape() = default;
  virtual double area() = 0;
};

// Implement the interface for a concrete class
struct Triangle : public Shape {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() override {
    return 0.5 * base * height;
  }
};

// Implement the interface for a concrete class
struct Rectangle : public Shape {
  double width;
  double height;

  Rectangle(double width, double height)
      : width(width), height(height) {}

  double area() override {
    return width * height;
  }
};

// Use an object via a reference to the interface
void printArea(Shape &amp;shape) {
  std::cout &lt;&lt; shape.area() &lt;&lt; std::endl;
}

int main() {
  Triangle triangle = Triangle{1.0, 1.0};

  printArea(triangle);

  // Use an object via an owned pointer to the
  // interface
  std::unique_ptr&lt;Shape&gt; shape;
  if (true) {
    shape = std::make_unique&lt;Rectangle&gt;(1.0, 1.0);
  } else {
    shape = std::make_unique&lt;Triangle&gt;(
        std::move(triangle));
  }

  // Convert to a reference to the interface
  printArea(*shape);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define an interface
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }
}

// Use a value via a reference to the interface
fn print_area(shape: &amp;dyn Shape) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    print_area(&amp;triangle);

    // Use a value via an owned pointer to the
    // interface
    let shape: Box&lt;dyn Shape&gt; = if true {
        Box::new(Rectangle {
            width: 1.0,
            height: 1.0,
        })
    } else {
        Box::new(triangle)
    };

    // Convert to a reference to the interface
    print_area(shape.as_ref());
}</code></pre></pre>
</div>
<p>There are several places where the Rust implementation differs slightly from the
C++ implementation.</p>
<p>In Rust, a trait's methods are always visible whenever the trait itself is
visible. Additionally, the fact that a type implements a trait is always visible
whenever both the trait and the type are visible. These properties of Rust
explain the lack of visibility declarations in places where one might find them
in C++.</p>
<p>In C++, to associate methods with a type rather than value of that type, you use
the <code>static</code> keyword. In Rust, non-static methods take an explicit <code>self</code> parameter.
This syntactic choice makes it possible to indicate (in way similar to other parameters) whether the
method mutates the object (by taking <code>&amp;mut self</code> instead of <code>&amp;self</code>) and whether
it takes ownership of the object (by taking <code>self</code> instead of <code>&amp;self</code>).</p>
<p>Rust methods do not need to be declared as virtual. Because of differences in
vtable representation, all methods for a type are available for dynamic
dispatch. Types of values that use vtables are indicated with the <code>dyn</code> keyword.
This is further described <a href="idioms/data_modeling/abstract_classes.html#vtables-and-rust-trait-object-types">below</a>.</p>
<p>Additionally, Rust does not have an equivalent for the virtual destructor
declaration because in Rust every vtable includes the drop behavior (whether
given by a user defined <code>Drop</code> implementation or not) required for the value.</p>
<h2 id="vtables-and-rust-trait-object-types"><a class="header" href="#vtables-and-rust-trait-object-types">Vtables and Rust trait object types</a></h2>
<p>C++ and Rust both requires some kind of indirection to perform dynamic dispatch
against an interface. In C++ this indirection takes the form of a pointer to the
abstract class (instead of the derived concrete class), making use of a vtable
to resolve the virtual method.</p>
<p>In the above Rust example, the type <code>dyn Shape</code> is the type of a trait object
for the <code>Shape</code> trait. A trait object includes a vtable along with the
underlying value.</p>
<p>In C++ all objects whose class inherits from a class with a virtual method have
a vtable in their representation, whether dynamic dispatch is used or not.
Pointers or references to objects are the same size as pointers to objects
without virtual methods, but every object includes its vtable.</p>
<p>In Rust, vtables are present only when values are represented as trait objects.
The reference to the trait object is twice the size of a normal reference since
it includes both the pointer to the value and the pointer to the vtable. In the
Rust example above, the local variable <code>triangle</code> in <code>main</code> does not have a
vtable in its representation, but when the reference to it is converted to a
reference to a trait object (so that it can be passed to <code>print_area</code>), that
does include a pointer to the vtable.</p>
<p>Additionally, just as abstract classes in C++ cannot be used as the type of a
local variable, the type of a parameter of a function, or the type of a return
value of a function, trait object types in Rust cannot be used in corresponding
contexts. In Rust, this is enforced by the type <code>dyn Shape</code> not implementing the
<code>Sized</code> marker trait, preventing it from being used in contexts that require
knowing the size of a type statically.</p>
<p>The following example shows some places where a trait object type can and cannot
be used due to not implementing <code>Sized</code>. The uses forbidden in Rust would also
be forbidden in C++ because <code>Shape</code> is an abstract class.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // Local variables must have a known size.
    // let v: dyn Shape = Triangle { base: 1.0, height: 1.0 };

    // References always have a known size.
    let shape: &amp;dyn Shape = &amp;Triangle {
        base: 1.0,
        height: 1.0,
    };
    // Boxes also always have a known size.
    let boxed_shape: Box&lt;dyn Shape&gt; = Box::new(Triangle {
        base: 1.0,
        height: 1.0,
    });

    // Types like Option&lt;T&gt; include the value of type T directly, and so also
    // need to know the size of T.
    // let v: Option&lt;dyn Shape&gt; = Some(Triangle { base: 1.0, height: 1.0 });
}

// Parameter types must have a known size.
// fn print_area(shape: dyn Shape) { }
fn print_area(shape: &amp;dyn Shape) {}</code></pre></pre>
<p>The decision to include the vtable in the reference instead of in the value is
one part of what makes it reasonable to use traits both for polymorphism via
dynamic dispatch and for <a href="idioms/data_modeling/./concepts.html">polymorphism via static dispatch, where one would use
concepts in C++</a>.</p>
<h2 id="limitations-of-trait-objects-in-rust"><a class="header" href="#limitations-of-trait-objects-in-rust">Limitations of trait objects in Rust</a></h2>
<p>In Rust, not all traits can be used as the base trait for trait objects. The
most commonly encountered restriction is that traits that require knowledge of
the object's size via a <code>Sized</code> supertrait are not <code>dyn</code>-compatible. There are
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">additional
restrictions</a>.</p>
<h2 id="trait-objects-and-lifetimes"><a class="header" href="#trait-objects-and-lifetimes">Trait objects and lifetimes</a></h2>
<p>Objects which are used with dynamic dispatch may contain pointers or references
to other objects. In C++ the lifetimes of those references must be tracked
manually by the programmer.</p>
<p>Rust checks the bounds on the lifetimes of references that the trait objects may
contain. If the bounds are not given explicitly, they are determined according
to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#r-lifetime-elision.trait-object">lifetime elision
rules</a>.
The bound is part of the type of the trait object.</p>
<p>Usually the elision rules pick the correct lifetime bound. Sometimes, the rules
result in surprising error messages from the compiler. In those situations or
when the compiler cannot determine which lifetime bound to assign, the bound may
be given manually. The following example shows explicitly what the inferred
lifetimes are for a structure storing a trait object and for the <code>print_area</code>
function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Scaled {
    scale: f64,
    // 'static is the lifetime that would be inferred by the lifetime elision
    // rule [lifetime-elision.trait-object.default].
    shape: Box&lt;dyn Shape + 'static&gt;,
}

impl Shape for Scaled {
    fn area(&amp;self) -&gt; f64 {
        self.scale * self.shape.area()
    }
}

// These are the lifetimes that would be inferred by the lifetime elision rule
// [lifetime-elision.function.implicit-lifetime-parameters] for the reference
// and [lifetime-elision.trait-object.containing-type-unique] for the trait
// bound.
fn print_area&lt;'a&gt;(shape: &amp;'a (dyn Shape + 'a)) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };
    print_area(&amp;triangle);

    let scaled_triangle = Scaled {
        scale: 2.0,
        shape: Box::new(triangle),
    };
    print_area(&amp;scaled_triangle);
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;abstract_classes&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;507115c6-4ed1-4a16-9f40-f5a01d3830a8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\ntrait Iterable {\n  type Item;\n  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nstruct Iterable&lt;Item&gt; {}\nimpl&lt;Item&gt; Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\nstruct Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\ntrait Iterable {\n  type Item;\n  fn new() -&gt; Self;\n  fn drop(self);\n  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n```\n&quot;],&quot;prompt&quot;:&quot;For the following C++ abstract virtual class, which of the following snippets represents the most idiomatic translation into Rust?\n```cpp\ntemplate&lt;typename Item&gt;\nstruct Iterable {\n  Iterable() {};\n  virtual ~Iterable() {};\n  virtual Item* next() = 0;\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-interfaces-and-static-dispatch"><a class="header" href="#concepts-interfaces-and-static-dispatch">Concepts, interfaces, and static dispatch</a></h1>
<p>In C++, static dispatch over an interface is achieved by implementing a template
function or template method that interacts with the type using some expected
interface.</p>
<p>The template function <code>twiceArea</code> in the example below makes use of an <code>area()</code>
method on the template type parameter.</p>
<p>To achieve the same goal in Rust involves defining a trait (<code>Shape</code>) with the
desired method (<code>twice_area</code>) and using the trait as a bound on the type
parameter for the generic function.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  // NOT virtual: it will be used with static
  // dispatch
  double area() const {
    return 0.5 * base * height;
  }
};

// Generic function using interface
template &lt;class T&gt;
double twiceArea(const T &amp;shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Interface that generic function will use
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implementation of interface for type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

// Generic function using interface
fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    println!("{}", twice_area(&amp;triangle));
}</code></pre></pre>
</div>
<p>Note that in the Rust example, the definition of the trait and the struct have
not changed from the example in the chapter on <a href="idioms/data_modeling/./abstract_classes.html">virtual methods and dynamic
dispatch</a>. Even so, this example
does use static dispatch. This is the result of a design trade-off in Rust
around the representation of vtables and vptrs which is <a href="idioms/data_modeling/./abstract_classes.html#vtables-and-rust-trait-object-types">described later in that
chapter</a>.</p>
<p>The difference between Rust and C++ in the above examples arises from Rust being
nominally typed (types must opt in to supporting a specific interface, merely
having the right methods isn't enough) and C++'s template meta-programming
enabling a kind of structural or duck typing (types only need to have the
methods actually used, and there is no need to explicitly opt in to supporting
an interface).</p>
<h2 id="templates-vs-generic-functions"><a class="header" href="#templates-vs-generic-functions">Templates vs generic functions</a></h2>
<p>The reason why Rust is nominally typed instead of structurally typed has to do
with the difference between C++ templates and Rust generic functions. In
particular, C++ templates are only type checked after all of the template
arguments are provided and they are fully expanded, while Rust generic functions
are type checked independently of the type arguments.</p>
<p>Since the functions are checked before the type arguments are known, the methods
and functions that can be applied to values of those types also need to be known
before the type arguments are known.</p>
<p>This point in the programming language design space favors simplicity of
reasoning about these functions over the flexibility that comes from the
template programming approach. This becomes especially valuable when writing
libraries that both provide generic functions defined in terms of other generic
functions, for which a C++ compiler can give many fewer static guarantees, since
it would not be possible to test all possible instantiations.</p>
<p>In both C++ and Rust, however, multiple implementations are generated by the
compiler in order to achieve static dispatch.</p>
<h2 id="c-constraints-and-concepts"><a class="header" href="#c-constraints-and-concepts">C++ constraints and concepts</a></h2>
<p>Rust's approach to static dispatch over an interface can be partially (but only
partially) modeled with a strict application of <a href="https://en.cppreference.com/w/cpp/language/constraints">C++
concepts</a>.</p>
<p>The usual way to apply concepts is still structural and does not model Rust's
approach: it only requires that a specific method can be called, producing a
specific type.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

template &lt;typename T&gt;
concept shape = requires(const T &amp;t) {
  { t.area() } -&gt; std::same_as&lt;double&gt;;
};

template &lt;shape T&gt;
double twiceArea(const T &amp;shape) {
  return shape.area() * 2.0;
}
</code></pre>
<p>A closer equivalent to the above Rust program in C++ is to use a combination of
abstract classes and concepts.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;
#include &lt;iostream&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() const = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

struct Triangle : public Shape {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  // still will be used with static dispatch
  double area() const override {
    return 0.5 * base * height;
  }
};

template &lt;shape T&gt;
double twiceArea(const T &amp;shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>This is still not the same, however, because the concept only creates a
requirement on the use of the template, not on the use of values of type <code>T</code>
within the template. In Rust, the trait bound constrains both. So the following
still compiles in C++.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

template &lt;shape T&gt;
double twiceArea(const T &amp;shape) {
  // note the call to a method not defined in Shape
  return shape.volume() * 2;
}
</code></pre>
<p>However, the equivalent does not compile in Rust and instead produces an error.</p>
<pre><code class="language-rust ignore">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    // note the call to a method not defined in Shape
    2.0 * shape.volume()
}</code></pre>
<pre><code class="language-text">error[E0599]: no method named `volume` found for reference `&amp;T` in the current scope
 --&gt; example.rs:7:17
  |
7 |     2.0 * shape.volume()
  |                 ^^^^^^ method not found in `&amp;T`
</code></pre>
<p>These additional static checks mean that in many situations where C++ templates
would be useful but hard to implement correctly, Rust generics are freely used.</p>
<h2 id="required-traits-and-ergonomics"><a class="header" href="#required-traits-and-ergonomics">Required traits and ergonomics</a></h2>
<p>In the above examples, the function requiring a trait was defined using a generic type <code>T</code> with a separate requirement that <code>T</code> is a <code>Shape</code>, like this:</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;shape T&gt;
double twiceArea(const T &amp;shape) {
  return 2.0 * shape.area();
}
</code></pre>
<pre><code class="language-rust ignore">fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
</div>
<p>These syntaxes are both common shorthands for <code>requires</code> clauses (C++) or <code>where</code> clauses (Rust):</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;typename T&gt;
  requires shape&lt;T&gt;
double twiceArea(const T &amp;shape) {
  return 2.0 * shape.area();
}
</code></pre>
<pre><code class="language-rust ignore">fn twice_area&lt;T&gt;(shape: &amp;T) -&gt; f64
where
    T: Shape,
{
    2.0 * shape.area()
}</code></pre>
</div>
<p>The more verbose form is preferred when there are many type parameters or those
type parameters must implement many traits. An even shorter-hand available in some
cases is the <code>impl</code> keyword.</p>
<div class="comparison">
<pre><code class="language-cpp">double twiceArea(const shape auto &amp;shape) {
  return 2.0 * shape.area();
}
</code></pre>
<pre><code class="language-rust ignore">fn twice_area(shape: &amp;impl Shape) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
</div>
<h2 id="generics-and-lifetimes"><a class="header" href="#generics-and-lifetimes">Generics and lifetimes</a></h2>
<p>When defining a template in C++ that makes use of a type template parameter, the
lifetimes of references stored within objects of that type must be tracked
manually by the programmer.</p>
<p>The following (contrived) C++ example compiles without error, but could be used
in a way that results in undefined behavior.</p>
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">
</span><span class="boring">struct Shape {
</span><span class="boring">  Shape() {}
</span><span class="boring">  virtual ~Shape() {}
</span><span class="boring">  virtual double area() = 0;
</span><span class="boring">};
</span><span class="boring">
</span>template&lt;typename S&gt;
void store(S s, std::unique_ptr&lt;Shape&gt; data) {
    // Will pointers or references in `s` become dangling while `data`
    // is still in use?
	*data = s;
}
</code></pre>
<p>Rust checks the bounds on lifetimes of references contained within type
parameters. <a href="idioms/data_modeling/./abstract_classes.html#trait-objects-and-lifetimes">Just as with trait object
types</a>,
these bounds are usually inferred according to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision
rules</a>. When they
cannot be inferred, or they are inferred incorrectly, the bounds can be declared
manually.</p>
<p>In the Rust transliteration of the above example, the lifetime bounds have to be
given manually because the inferred bounds are incorrect. Without explicit
bounds, the compiler produces an error.</p>
<pre><code class="language-rust ignore"><span class="boring">trait Shape {}
</span><span class="boring">
</span>fn store&lt;S: Shape&gt;(x: S, data: &amp;mut Box&lt;dyn Shape&gt;) {
    *data = Box::new(x);
}</code></pre>
<pre><code class="language-text">error[E0310]: the parameter type `S` may not live long enough
 --&gt; example.rs:7:5
  |
7 |     *data = Box::new(x);
  |     ^^^^^
  |     |
  |     the parameter type `S` must be valid for the static lifetime...
  |     ...so that the type `S` will meet its required lifetime bounds
  |
</code></pre>
<p>The error message becomes clearer when the inferred lifetime bounds are made
explicit. With the given type for <code>store</code>, the argument for <code>x</code> could be
something that has a lifetime that does not last as long as the lifetimes in the
contents in the box.</p>
<pre><code class="language-rust ignore"><span class="boring">trait Shape {}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {}
</span><span class="boring">
</span>// The type parameter S is assigned no lifetime bound.
fn store&lt;'a, S: Shape&gt;(
    x: S,
    // The reference is assigned a fresh lifetime by rule
    // [lifetime-elision.function.implicit-lifetime-parameters].
    //
    // The trait object is assigned 'static by rule
    // [lifetime-elision.trait-object.default] and
    // [lifetime-elision.trait-object.innermost-type].
    data: &amp;'a mut Box&lt;dyn Shape + 'static&gt;,
) {
    *data = Box::new(x);
}

// An example of how the implementation of store could be misused with
// the given type.
fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 2.0,
    };
    let mut b: Box&lt;dyn Shape&gt; = Box::new(triangle);
    {
        let short_lived_triangle = Triangle {
            base: 5.0,
            height: 10.0,
        };
        store(short_lived_triangle, &amp;mut b);
    }
    // Here b contains a dangling reference.
}</code></pre>
<p>For this specific case, the most general solution is to define a new lifetime
parameter to bound both <code>S</code> and <code>dyn Shape</code>. The type parameter for the
reference can be elided, because it will be assigned a fresh lifetime parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape {}

// Note the common bound
// -----------------here-\
// ----------------------|---------------------------and here-\
//                       v                                    v
fn store&lt;'s, S: Shape + 's&gt;(x: S, data: &amp;mut Box&lt;dyn Shape + 's&gt;) {
    *data = Box::new(x);
}
<span class="boring">}</span></code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;concepts&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust needs to know that the type of `Scaled::shape` supports the `area` method,\nso a trait bound on the type parameter is necessary. Trait implementations are\nall or nothing, so the requirement applies to the whole implementation, not the\nindividual method.\n&quot;,&quot;id&quot;:&quot;3cb5759b-5fe0-491e-ac87-4ba455b26e8f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T: Shape&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;,&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64\n    where\n        T: Shape,\n    {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;,&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T: Shape&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Consider the following C++ program.\n\n```cpp\ntemplate&lt;typename T&gt;\nstruct Scaled {\n\tdouble scale;\n\tT shape;\n\n\tdouble area() const {\n\t\treturn scale * shape.area();\n\t}\n};\n\ntemplate &lt;typename T&gt;\nvoid printArea(const T &amp;shape) {\n\tstd::cout &lt;&lt; shape.area() &lt;&lt; std::endl;\n}\n```\n\nWhich of the following snippets represents the most idiomatic translation of the\n`Scaled` template class into Rust?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>In C++, enums are often used to model a fixed set of alternatives, especially when
each of those enumerators corresponds to a specific integer value, such as is needed
when working with hardware, system calls, or protocol implementations.</p>
<p>For example, the various modes for a GPIO pin could be modeled as an enum, which
would restrict methods using the mode to valid values.</p>
<p>While Rust enums are <a href="idioms/data_modeling/./tagged_unions.html">more general</a>,
they can still be used for this sort of modeling.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

enum Pin : uint8_t {
  Pin1 = 0x01,
  Pin2 = 0x02,
  Pin3 = 0x04
};

enum Mode : uint8_t {
  Output = 0x03,
  Pullup = 0x04,
  Analog = 0x27
  // ...
};

void low_level_set_pin(uint8_t pin, uint8_t mode);

void set_pin_mode(Pin pin, Mode mode) {
  low_level_set_pin(pin, mode);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

#[repr(u8)]
#[derive(Clone, Copy)]
enum Mode {
    Output = 0x03,
    Pullup = 0x04,
    Analog = 0x27,
    // ...
}

extern "C" {
    fn low_level_set_pin(pin: u8, mode: u8);
}

fn set_pin_mode(pin: Pin, mode: Mode) {
    unsafe {
        low_level_set_pin(pin as u8, mode as u8)
    };
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The <code>#[repr(u8)]</code> attribute ensures that the representation of the enum is the
same as a byte (like declaring the underlying type of an enum in C++). The enum
values can then be freely converted to the underlying type with the <code>as</code>.</p>
<p>In C++ the standard way to convert from an integer to an enum is a static cast.
However, this <a href="https://eel.is/c++draft/expr.static.cast#9">requires that the user check the validity of the cast
themselves</a>. Often the conversion is
done by a function that checks that the value to convert is a valid enum value.</p>
<p>In Rust the standard way to perform the conversion is to implement the <code>TryFrom</code>
trait for the type and then use the <code>try_from</code> method or <code>try_into</code> method.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;cstdint&gt;
</span><span class="boring">
</span><span class="boring">enum Pin : uint8_t {
</span><span class="boring">  Pin1 = 0x01,
</span><span class="boring">  Pin2 = 0x02,
</span><span class="boring">  Pin3 = 0x04
</span><span class="boring">};
</span><span class="boring">
</span>struct InvalidPin {
    uint8_t pin;
};

Pin to_pin(uint8_t pin) {
  // The values are not contiguous, so we can't
  // just check the bounds and then cast.
  switch (pin) {
  case 0x1: { return Pin1; }
  case 0x2: { return Pin2; }
  case 0x4: { return Pin3; }
  }
  throw InvalidPin{pin};
}

int main() {
  try {
    Pin p(to_pin(2));
  } catch (InvalidPin &amp;e) {
    return 0;
  }

  // use pin p
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Pin {
</span><span class="boring">    Pin1 = 0x01,
</span><span class="boring">    Pin2 = 0x02,
</span><span class="boring">    Pin3 = 0x04,
</span><span class="boring">}
</span><span class="boring">
</span>use std::convert::TryFrom;

struct InvalidPin(u8);

impl TryFrom&lt;u8&gt; for Pin {
    type Error = InvalidPin;

    fn try_from(
        value: u8,
    ) -&gt; Result&lt;Self, Self::Error&gt; {
        match value {
            0x01 =&gt; Ok(Pin::Pin1),
            0x02 =&gt; Ok(Pin::Pin2),
            0x04 =&gt; Ok(Pin::Pin3),
            pin =&gt; Err(InvalidPin(pin)),
        }
    }
}

fn main() {
  let Ok(p) = Pin::try_from(2) else {
    return;
  };

  // use pin p
}</code></pre></pre>
</div>
<p>See <a href="idioms/data_modeling/../exceptions.html">Exceptions and error handling</a> for examples of how
to ergonomically handle the result of <code>try_from</code>.</p>
<p>If low-level performance is more of a concern than memory safety,
<code>std::mem::transmute</code> is analogous to a C++ reinterpret cast, but requires
unsafe Rust because its use can result in undefined behavior. Uses of
<code>std::mem::transmute</code> for this purpose should not be hidden behind an interface
that can be called from safe Rust unless the interface can actually guarantee
that the call will never happen with an invalid value.</p>
<h2 id="enums-and-methods"><a class="header" href="#enums-and-methods">Enums and methods</a></h2>
<p>In C++ enums cannot have methods. Instead, to model an enum with methods one
must define a wrapper class for the enum and define the methods on that wrapper
class. In Rust, methods can be defined on an enum with an <code>impl</code> block, just
like any other type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

// Actual enum
enum PinImpl : uint8_t {
  Pin1 = 0x01,
  Pin2 = 0x02,
  Pin3 = 0x04
};

class LastPin{};

// Wrapper type
struct Pin {
  PinImpl pin;

  // Conversion constructor so that PinImpl can be
  // used as a Pin.
  Pin(PinImpl p) : pin(p) {}

  // Conversion method so wrapper type can be
  // used with switch statement.
  operator PinImpl() {
    return this-&gt;pin;
  }

  Pin next() const {
    switch (pin) {
    case Pin1:
      return Pin(Pin2);
    case Pin2:
      return Pin(Pin3);
    default:
      throw LastPin{};
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

struct LastPin;

impl Pin {
    fn next(&amp;self) -&gt; Result&lt;Self, LastPin&gt; {
        match self {
            Pin::Pin1 =&gt; Ok(Pin::Pin2),
            Pin::Pin2 =&gt; Ok(Pin::Pin3),
            Pin::Pin3 =&gt; Err(LastPin),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;enums&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;b1f69693-be11-4105-b408-7f8925c4303d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nimpl TryFrom&lt;u8&gt; for Color {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        match c {\n            0 =&gt; Ok(Color::Red),\n            1 =&gt; Ok(Color::Blue),\n            2 =&gt; Ok(Color::Green),\n            3 =&gt; Ok(Color::Yellow),\n            _ =&gt; Err(InvalidColor(c)),\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nimpl TryFrom&lt;u8&gt; for Color {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        match c {\n            0 | 2 | 3 =&gt; Ok(c as Color),\n            _ =&gt; Err(InvalidColor(c)),\n        }\n    }\n}\n```\n&quot;,&quot;```rust\n#[derive(Clone, Copy)]\nstruct ColorWrapper {\n    color: Color,\n}\n\nimpl TryFrom&lt;u8&gt; for ColorWrapper {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        let color = match c {\n            0 =&gt; Ok(Color::Red),\n            1 =&gt; Ok(Color::Blue),\n            2 =&gt; Ok(Color::Green),\n            3 =&gt; Ok(Color::Yellow),\n            _ =&gt; Err(InvalidColor(c)),\n        }?;\n        Ok(ColorWrapper { color })\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of these Rust programs is the most idiomatic translation of the following\nC++ program?\n\n```cpp\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nenum ColorImpl : uint8_t {\n  Red,\n  Blue,\n  Green,\n  Yellow,\n};\n\nstruct InvalidColor {\n  uint8_t color;\n};\n\nstruct Color {\n  ColorImpl color;\n\n  Color(ColorImpl c) : color(c) {}\n\n  operator ColorImpl() {\n    return color;\n  }\n\n  explicit Color(uint8_t c) {\n    if (c &lt; Red || c &gt; Yellow) {\n      throw InvalidColor{c};\n    }\n    color = static_cast&lt;ColorImpl&gt;(c);\n  }\n};\n```\n\nAll of the Rust options start with the following import and definitions.\n\n```rust\nuse std::convert::TryFrom;\n\n#[repr(u8)]\n#[derive(Clone, Copy)]\nenum Color {\n    Red,\n    Blue,\n    Green,\n    Yellow,\n}\n\nstruct InvalidColor(u8);\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-unions-and-stdvariant"><a class="header" href="#tagged-unions-and-stdvariant">Tagged unions and <code>std::variant</code></a></h1>
<h2 id="c-style-tagged-unions"><a class="header" href="#c-style-tagged-unions">C-style tagged unions</a></h2>
<p>Because unions cannot be used for type punning in C++, they are usually used
with a tag to discriminate between which variant of the union is active.</p>
<p>Rust's equivalent to union types are always tagged. They are a generalization of
Rust enums, where additional data may be associated with the enum variants.</p>
<div class="comparison">
<pre><code class="language-cpp">enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };

  double area() {
    switch (this-&gt;tag) {
    case Rectangle: {
      return this-&gt;rectangle.width *
             this-&gt;rectangle.height;
    }
    case Triangle: {
      return 0.5 * this-&gt;triangle.base *
             this-&gt;triangle.height;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
            Shape::Triangle { base, height } =&gt; {
                0.5 * base * height
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>When matching on an enum, Rust requires that all variants of the enum be
handled. In situations where <code>default</code> would be used with a C++ <code>switch</code> on the
tag, a wildcard can be used in the Rust <code>match</code>.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;iostream&gt;
</span><span class="boring">
</span><span class="boring">enum Tag { Rectangle, Triangle, Circle };
</span><span class="boring">
</span>struct Shape {
<span class="boring">  Tag tag;
</span><span class="boring">  union {
</span><span class="boring">    struct {
</span><span class="boring">      double width;
</span><span class="boring">      double height;
</span><span class="boring">    } rectangle;
</span><span class="boring">    struct {
</span><span class="boring">      double base;
</span><span class="boring">      double height;
</span><span class="boring">    } triangle;
</span><span class="boring">    struct {
</span><span class="boring">      double radius;
</span><span class="boring">    } circle;
</span><span class="boring">  };
</span><span class="boring">
</span>  void print_shape() {
    switch (this-&gt;tag) {
    case Rectangle: {
      std::cout &lt;&lt; "Rectangle" &lt;&lt; std::endl;
      break;
    }
    default: {
      std::cout &lt;&lt; "Some other shape"
                &lt;&lt; std::endl;
      break;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn print_shape(&amp;self) {
        match self {
            Shape::Rectangle { .. } =&gt; {
                println!("Rectangle");
            }
            _ =&gt; {
                println!("Some other shape");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Rust does not support C++-style fallthrough where some behavior can be done
before falling through to the next case. However, in Rust one can match on
multiple enum variants simultaneously, so long as the simultaneous match
patterns bind the same names with the same types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn bounding_area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { height, width }
            | Shape::Triangle {
                height,
                base: width,
            } =&gt; width * height,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-the-value-without-checking-the-discriminant"><a class="header" href="#accessing-the-value-without-checking-the-discriminant">Accessing the value without checking the discriminant</a></h2>
<p>Unlike with C-style unions, Rust always requires matching on the discriminant
before accessing the values. If the variant is already known, e.g., due to an
earlier check, then the code can usually be refactored to encode the knowledge
in the type so that the second check (and corresponding error handling) can be
omitted.</p>
<p>A C++ program like the following requires more restructuring of the types to
achieve the same goal in Rust.</p>
<p>The corresponding Rust program requires defining separate types for each variant
of the <code>Shape</code> enum so that the fact that all of the value are of a given type
can be expressed in the type system by having an array of <code>Triangle</code> instead of
an array of <code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

// Uses the same Shape definition.
enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };
};

std::vector&lt;Shape&gt; get_shapes() {
  return std::vector&lt;Shape&gt;{
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},
  };
}

std::vector&lt;Shape&gt; get_shapes();

int main() {
  std::vector&lt;Shape&gt; shapes = get_shapes();

  auto is_triangle = [](Shape shape) {
    return shape.tag == Triangle;
  };

  // Create an iterator that only sees the
  // triangles. (std::views::filter is from C++20,
  // but the same effect can be acheived with a
  // custom iterator.)
  auto triangles =
      shapes | std::views::filter(is_triangle);

  double total_base = 0.0;
  for (auto &amp;triangle : triangles) {
    // Skip checking the tag because we know we
    // have only triangles.
    total_base += triangle.triangle.base;
  }

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define a separate struct for each variant.
struct Rectangle { width: f64, height: f64 }
struct  Triangle { base: f64, height: f64 }

enum Shape {
    Rectangle(Rectangle),
    Triangle(Triangle),
}

fn get_shapes() -&gt; Vec&lt;Shape&gt; {
    vec![
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Rectangle(Rectangle {
            width: 1.0,
            height: 1.0,
        }),
    ]
}

fn main() {
    let shapes = get_shapes();

    // This iterator only iterates over triangles
    // and demonstrates that by iterating over
    // the Triangle type instead of the Shape type.
    let triangles = shapes
        .iter()
        // Keep only the triangles
        .filter_map(|shape| match shape {
            Shape::Triangle(t) =&gt; Some(t),
            _ =&gt; None,
        });

    let mut total_base = 0.0;
    for triangle in triangles {
        // Because the iterator produces Triangles
        // instead of Shapes, base can be accessed
        // directly.
        total_base += triangle.base;
    }
}</code></pre></pre>
</div>
<p>This kind of use is common enough in Rust that the variants are often designed
to have their own types from the start.</p>
<p>This approach is also possible in C++. It is more commonly used along with
<code>std::variant</code> in C++17 or later.</p>
<h2 id="stdvariant-since-c17"><a class="header" href="#stdvariant-since-c17"><code>std::variant</code> (since C++17)</a></h2>
<p>When programming in C++ standards since C++17, <code>std::variant</code> can be used to
represent a tagged union in a way that has more in common with Rust enums.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        } else if constexpr (std::is_same_v&lt;T, Triangle&gt;) {
          return 0.5 * arg.base * arg.height;
        }
      },
      shape);
}
</code></pre>
<p>Because Rust doesn't depend on templates for this language feature, error
messages when a variant is missed or when a new variant is added are easier to
read, which removes one of the barriers to using tagged unions more frequently.
Compare the errors in C++ (using gcc) and Rust when the <code>Triangle</code> case is
omitted.</p>
<p>The following two programs have the same error: each fails to handle a case of
<code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        }
      },
      shape);
}
</code></pre>
<pre><code class="language-rust ignore">enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
        }
    }
}</code></pre>
</div>
<p>However, the error messages differ significantly.</p>
<div class="comparison">
<pre><code class="language-text">example.cc: In instantiation of ‘area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt; [with auto:27 = const Triangle&amp;]’:
/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from ‘constexpr _Res std::__invoke_impl(__invoke_other, _Fn&amp;&amp;, _Args&amp;&amp; ...) [with _Res = double; _Fn = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}]’
   61 |     { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from ‘constexpr typename std::__invoke_result&lt;_Functor, _ArgTypes&gt;::type std::__invoke(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}; typename __invoke_result&lt;_Functor, _ArgTypes&gt;::type = double]’
   96 |       return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   97 |                                         std::forward&lt;_Args&gt;(__args)...);
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1060:24:   required from ‘static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl&lt;std::__detail::__variant::_Multi_array&lt;_Result_type (*)(_Visitor, _Variants ...)&gt;, std::integer_sequence&lt;long unsigned int, __indices ...&gt; &gt;::__visit_invoke(_Visitor&amp;&amp;, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;&amp;&amp;; _Variants = {const std::variant&lt;Rectangle, Triangle&gt;&amp;}; long unsigned int ...__indices = {1}]’
 1060 |           return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),
      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1061 |               __element_by_index_or_cookie&lt;__indices&gt;(
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1062 |                 std::forward&lt;_Variants&gt;(__vars))...);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1820:5:   required from ‘constexpr decltype(auto) std::__do_visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Result_type = __detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}]’
 1820 |                   _GLIBCXX_VISIT_CASE(1)
      |                   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1882:34:   required from ‘constexpr std::__detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; std::visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}; __detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; = double]’
 1882 |             return std::__do_visit&lt;_Tag&gt;(
      |                    ~~~~~~~~~~~~~~~~~~~~~^
 1883 |               std::forward&lt;_Visitor&gt;(__visitor),
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1884 |               static_cast&lt;_Vp&gt;(__variants)...);
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
example.cc:17:20:   required from here
   17 |   return std::visit(
      |          ~~~~~~~~~~^
   18 |       [](auto &amp;&amp;arg) -&gt; double {
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 |         using T = std::decay_t&lt;decltype(arg)&gt;;
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 |         if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 |           return arg.width * arg.height;
      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   22 |         }
      |         ~
   23 |       },
      |       ~~
   24 |       shape);
      |       ~~~~~~
example.cc:23:7: error: no return statement in ‘constexpr’ function returning non-void
   23 |       },
      |       ^
example.cc: In lambda function:
example.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `&amp;Shape::Triangle { .. }` not covered
 --&gt; example.rs:8:15
  |
8 |         match self {
  |               ^^^^ pattern `&amp;Shape::Triangle { .. }` not covered
  |
note: `Shape` defined here
 --&gt; example.rs:1:6
  |
1 | enum Shape {
  |      ^^^^^
2 |     Rectangle { width: f64, height: f64 },
3 |     Triangle { base: f64, height: f64 },
  |     -------- not covered
  = note: the matched value is of type `&amp;Shape`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
12~             } =&gt; width * height,
13~             &amp;Shape::Triangle { .. } =&gt; todo!(),
  |
</code></pre>
</div>
<h2 id="using-unsafe-rust-to-avoid-checking-the-discriminant"><a class="header" href="#using-unsafe-rust-to-avoid-checking-the-discriminant">Using unsafe Rust to avoid checking the discriminant</a></h2>
<p>In situations where rewriting code to use the <a href="idioms/data_modeling/tagged_unions.html#accessing-the-value-without-checking-the-discriminant">above
approach</a> is not
possible, one can check the discriminant anyway and then use the <a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code>
macro</a> to avoid handling
the impossible case. However, that still involves actually checking the
discriminant. If the cost of checking the discriminant must be avoided, then the
<a href="https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html">unsafe function
<code>unreachable_unchecked</code></a>
can be used to both avoid handling the case and to indicate to the compiler that
the optimizer should assume that the case cannot be reached, so the discriminant
check can be optimized away.</p>
<p>Much like how in the C++ example accessing an inactive variant is undefined
behavior, reaching <code>unreachable_unchecked</code> is also undefined behavior.
As with any <code>unsafe</code>-based performance optimizations, you always should measure the performance impact
of safety checks first, and only reach for unsafe code if absolutely necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        match self {
</span><span class="boring">            Shape::Rectangle {
</span><span class="boring">                width,
</span><span class="boring">                height,
</span><span class="boring">            } =&gt; width * height,
</span><span class="boring">            Shape::Triangle { base, height } =&gt; {
</span><span class="boring">                0.5 * base * height
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_triangles() -&gt; Vec&lt;Shape&gt; {
</span><span class="boring">    vec![
</span><span class="boring">        Shape::Triangle {
</span><span class="boring">            base: 1.0,
</span><span class="boring">            height: 1.0,
</span><span class="boring">        },
</span><span class="boring">        Shape::Triangle {
</span><span class="boring">            base: 1.0,
</span><span class="boring">            height: 1.0,
</span><span class="boring">        },
</span><span class="boring">    ]
</span><span class="boring">}
</span><span class="boring">
</span>use std::hint::unreachable_unchecked;

fn main() {
    let mut total_base = 0.0;
    for triangle in get_triangles() {
        let Shape::Triangle { base, .. } = triangle else {
            // SAFETY: get_triangles is guaranteed to produce triangles, so
            // other cases aren't reachable.
            unsafe { unreachable_unchecked() }
        };
        total_base += base;        
    }
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;tagged_unions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;8019115c-c84b-4b79-a18d-d2e83ff984da&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. }\n            | MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. } =&gt; // fallthrough\n            MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;,&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            _ =&gt; self.height * self.width,\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs is the most idiomatic translation of the\ngiven C++ program?\n\n```c++\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n\nenum class MediaType { Text, Image, Video };\n\nclass MediaFile {\npublic:\n  MediaType type;\n  union {\n    struct {\n      std::string language;\n      size_t length;\n    } text;\n    struct {\n      size_t height;\n      size_t width;\n    } image;\n    struct {\n      size_t height;\n      size_t width;\n      std::chrono::nanoseconds duration;\n    } video;\n  };\n\n  // constructors omitted for brevity\n\n  size_t size() const {\n    switch (type) {\n    case MediaType::Text:\n      return text.length;\n    case MediaType::Image:\n      return image.height * image.width;\n    case MediaType::Video:\n      return video.height * video.width;\n    }\n    // Should not reach here\n    return 0;\n  }\n};\n```\n\nAll of the Rust programs use this definition of `MediaFile`.\n\n```rust\nenum MediaFile {\n    Text {\n        language: String,\n        length: usize,\n    },\n    Image {\n        height: usize,\n        width: usize,\n    },\n    Video {\n        height: usize,\n        width: usize,\n        duration: std::time::Duration,\n    },\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance-and-implementation-reuse"><a class="header" href="#inheritance-and-implementation-reuse">Inheritance and implementation reuse</a></h1>
<p>Rust does not have inheritance and so the primary means of reuse of
implementations in Rust are composition, aggregation, and
<a href="idioms/data_modeling/./templates.html">generics</a>.</p>
<p>However, Rust traits do have support for default methods which resemble one
simple case of using inheritance for reuse of implementations. For example, in
the following example two virtual methods are used to support a method whose
implementation is provided by the abstract class.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Device {
public:
    virtual void powerOn() = 0;
    virtual void powerOff() = 0;

    virtual void resetDevice() {
        std::cout &lt;&lt; "Resetting device..." &lt;&lt; std::endl;
        powerOff();
        powerOn();
    }

    virtual ~Device() {}
};

class Printer : public Device {
    bool powered = false;
public:
    void powerOn() override {
        this.powered = true;
        std::cout &lt;&lt; "Printer is powered on." &lt;&lt; std::endl;
    }

    void powerOff() override {
        this.powered = false;
        std::cout &lt;&lt; "Printer is powered off." &lt;&lt; std::endl;
    }
};

int main() {
    Printer myPrinter;
    myPrinter.resetDevice();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Device {
    fn power_on(&amp;mut self);
    fn power_off(&amp;mut self);

    fn reset_device(&amp;mut self) {
        println!("Resetting device...");
        self.power_off();
        self.power_on();
    }
}

struct Printer {
    powered: bool,
}

impl Printer {
    fn new() -&gt; Printer {
        Printer { powered: false }
    }
}

impl Device for Printer {
    fn power_on(&amp;mut self) {
        self.powered = true;
        println!("Printer is powered on");
    }

    fn power_off(&amp;mut self) {
        self.powered = false;
        println!("Printer is powered off");
    }
}

fn main() {
    let mut p = Printer::new();
    p.reset_device();
}</code></pre></pre>
</div>
<p>In practice, the <code>resetDevice()</code> method in the <code>Device</code> class might be made
non-virtual in C++ if it is not expected that it will be overridden. In order to
make it align with the Rust example, we have made it virtual here, since Rust
traits can be used either for <a href="idioms/data_modeling/./abstract_classes.html">dynamic
dispatch</a> or <a href="idioms/data_modeling/./concepts.html">static
dispatch</a> (with <a href="idioms/data_modeling/./abstract_classes.html#vtables-and-rust-trait-object-types">no vtable overhead in the
static dispatch
case</a>).</p>
<p>Rust traits differ from abstract classes in few more ways. For example,
Rust traits cannot define data members and cannot define private or protected
methods. This limits the effectiveness of using traits to implement the template
method pattern.</p>
<p>Rust traits also cannot be privately implemented. Anywhere that both a trait
and a type that implements that trait are visible, the methods of the trait are
visible as methods on the type.</p>
<p>Traits can, however, inherit from each other, including multiple inheritance. As
in modern C++, inheritance hierarchies in Rust tend to be shallow. In situations
with complex multiple inheritance, however, the diamond problem cannot arise in
Rust because traits cannot override other traits implementations. Therefore, all
paths to a common parent trait resolve to the same implementation.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;inheritance_and_reuse&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Unlike with a C++ parent class, the default method is not part of `BareLogger`,\neven when accessed statically via the trait.\n&quot;,&quot;id&quot;:&quot;2bc058d0-99e4-44e0-9abe-5497b713731e&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;a message\nan error\nanother message\nanother error\n&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;trait Logger {\n    fn log(&amp;self, message: &amp;str);\n\n    fn error(&amp;self, message: &amp;str) {\n        self.log(&amp;format!(\&quot;ERROR: {}\&quot;, message));\n    }\n}\n\nstruct BareLogger;\n\nimpl Logger for BareLogger {\n    fn log(&amp;self, message: &amp;str) {\n        println!(\&quot;{}\&quot;, message);\n    }\n\n    fn error(&amp;self, message: &amp;str) {\n        // Omits the ERROR: prefix\n        println!(\&quot;{}\&quot;, message)\n    }\n}\n\nfn main() {\n    let logger = BareLogger;\n    logger.log(\&quot;a message\&quot;);\n    logger.error(\&quot;an error\&quot;);\n    &lt;BareLogger as Logger&gt;::log(&amp;logger, \&quot;another message\&quot;);\n    &lt;BareLogger as Logger&gt;::error(&amp;logger, \&quot;another error\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;A trait only defines an interface, with the ability to define default methods as\na convenience for when some methods on the trait can be defined in terms of\nothers.\n&quot;,&quot;id&quot;:&quot;78c03495-5d3d-4faf-8375-b9f338a377ff&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because in Rust traits cannot have fields.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile, because `health` isn't initialized when `Enemy` implements\n`Damageable`.\n&quot;,&quot;It does not compile, because `e.health` isn't initialized before using `e` in\n`main`.\n&quot;],&quot;prompt&quot;:&quot;Does the following program compile? If not, why not?\n\n```rust\ntrait Damageable {\n    health: u32;\n\n    fn take_damage(&amp;mut self, damage: u32) {\n        self.health = self.health.saturating_sub(damage);\n    }\n}\n\nstruct Enemy;\n\nimpl Damageable for Enemy {}\n\nfn main() {\n    let e = Enemy;\n    e.take_damage(10);\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="template-classes-functions-and-methods"><a class="header" href="#template-classes-functions-and-methods">Template classes, functions, and methods</a></h1>
<p>The most common uses of templates in C++ are to define classes, methods, or
functions that work for any type (or at least for any type that provides certain
methods). This use case is common in the STL for container classes (such as
<code>&lt;vector&gt;</code>) and for the algorithms library (<code>&lt;algorithm&gt;</code>).</p>
<p>The following example defines a template for a directed graph represented as an
adjacency list, where the graph is generic in the type of the labels on the
nodes. Though the example shows a template class, the same comparisons with Rust
apply to template methods and template functions.</p>
<p>The same kind of reusable code can be created in Rust using generic types.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  std::vector&lt;Label&gt; nodeLabels;

public:
  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(std::move(label));
    return numNodes() - 1;
  }

  void addEdge(size_t from, size_t to) {
    size_t numNodes = this-&gt;numNodes();
    if (from &gt;= numNodes || to &gt;= numNodes) {
      throw std::invalid_argument(
          "Node index out of range");
    }
    adjacencies[from].push_back(to);
  }

  size_t numNodes() const {
    return adjacencies.size();
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DirectedGraph&lt;Label&gt; {
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    node_labels: Vec&lt;Label&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn add_node(
        &amp;mut self,
        label: Label,
    ) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn add_edge(
        &amp;mut self,
        from: usize,
        to: usize,
    ) -&gt; Result&lt;(), &amp;str&gt; {
        let num_nodes = self.num_nodes();
        if from &gt;= num_nodes || to &gt;= num_nodes {
            Err("Node index out of range.")
        } else {
            self.adjacencies[from].push(to);
            Ok(())
        }
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In the use case demonstrated in the above example, there are few practical
differences between using C++ template to define a class and using and Rust's
generics to define a struct. Whenever one would use a template that takes a
<code>typename</code> or <code>class</code> parameter in C++, one can instead take a type parameter in
Rust.</p>
<h2 id="operations-on-the-parameterized-type"><a class="header" href="#operations-on-the-parameterized-type">Operations on the parameterized type</a></h2>
<p>The differences become more apparent when one attempts to perform operations on
the values. The following code listing adds a method to get the smallest node in
the graph to both the Rust and the C++ examples.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;optional&gt;
<span class="boring">#include &lt;stdexcept&gt;
</span><span class="boring">#include &lt;vector&gt;
</span>
template &lt;typename Label&gt;
class DirectedGraph {
<span class="boring">  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
</span><span class="boring">  std::vector&lt;Label&gt; nodeLabels;
</span><span class="boring">
</span>public:
<span class="boring">  size_t addNode(Label label) {
</span><span class="boring">    adjacencies.push_back(std::vector&lt;size_t&gt;());
</span><span class="boring">    nodeLabels.push_back(std::move(label));
</span><span class="boring">    return numNodes() - 1;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  void addEdge(size_t from, size_t to) {
</span><span class="boring">    size_t numNodes = this-&gt;numNodes();
</span><span class="boring">    if (from &gt;= numNodes || to &gt;= numNodes) {
</span><span class="boring">      throw std::invalid_argument(
</span><span class="boring">          "Node index out of range");
</span><span class="boring">    }
</span><span class="boring">    adjacencies[from].push_back(to);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  size_t numNodes() const {
</span><span class="boring">    return adjacencies.size();
</span><span class="boring">  }
</span><span class="boring">
</span>  std::optional&lt;size_t&gt; smallestNode() {
    if (nodeLabels.empty()) {
      return std::nullopt;
    }
    Label &amp;least = nodeLabels[0];
    size_t index = 0;

    for (int i = 1; i &lt; nodeLabels.size(); i++) {
      if (least &gt; nodeLabels[i]) {
        least = nodeLabels[i];
        index = i;
      }
    }
    return std::optional(index);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        // Matches the C++, but is not the idomatic
        // implementation!
        if self.node_labels.is_empty() {
            None
        } else {
            let mut least = &amp;self.node_labels[0];
            let mut index = 0;
            for i in 1..self.node_labels.len() {
                if *least &gt; self.node_labels[i] {
                    least = &amp;self.node_labels[i];
                    index = i;
                }
            }
            Some(index)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The major difference between these implementations is that in the C++ version
the <code>&gt;</code> operator or <code>operator&gt;</code> method is used on the values without knowing
whether the either is defined for the type. In the Rust version, there is a
constraint requiring that the <code>Label</code> type implement the <code>Ord</code> trait. (See the
chapter on <a href="idioms/data_modeling/./concepts.html">concepts, interfaces, and static dispatch</a> for more
details on Rust traits and how they relate to C++ concepts.)</p>
<p>Unlike C++ templates, generic definitions in Rust are type checked at the point
of definition rather than at the point of use. This means that for operations to
be used on values with the type of a type parameter, the parameter has to be
constrained to types that implement some trait. As can be seen in the above
example, much like with C++ concepts and <code>requires</code>, the constraint can be
required for individual methods rather than for the whole generic class.</p>
<p>It is best practice in Rust to put the trait bounds on the specific things that
require the bounds, in order to make the overall use of the types more flexible.</p>
<p>As an aside, a more idiomatic implementation of <code>smallest_node</code> makes use of
Rust's iterators. This style of implementation may take some getting used to for
programmers more accustomed to implementations in the style used in the earlier
example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        self.node_labels
            .iter()
            .enumerate()
            .map(|(i, l)| (l, i))
            .min()
            .map(|(_, i)| i)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>An even more idiomatic implementation would make use of the <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.position_min">itertools
crate</a>.</p>
<pre><code class="language-rust ignore">use itertools::*;

<span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        self.node_labels.iter().position_min()
    }
}</code></pre>
<h2 id="constexpr-template-parameters"><a class="header" href="#constexpr-template-parameters"><code>constexpr</code> template parameters</a></h2>
<p>Rust also supports the equivalent of constexpr template parameters. For example,
one can define a generic function that returns an array of consecutive integers
starting from a specific value and whose size is determined at compile time.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cstddef&gt;

template &lt;size_t N&gt;
std::array&lt;int, N&gt;
makeSequentialArray(int start) {
  std::array&lt;int, N&gt; arr;
  for (size_t i = 0; i &lt; N; i++) {
    arr[i] = start + i;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_sequential_array&lt;const N: usize&gt;(
    start: i32,
) -&gt; [i32; N] {
    std::array::from_fn(|i| start + i as i32)
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The corresponding idiomatic Rust function uses the helper <code>std::array::from_fn</code>
to construct the array. <code>from_fn</code> itself takes as type parameters the element
type and the constant. Those arguments are elided because Rust can infer them,
because both are part of the type of the produced array.</p>
<h2 id="rusts-self-type"><a class="header" href="#rusts-self-type">Rust's <code>Self</code> type</a></h2>
<p>Within a Rust struct defintion, <code>impl</code> block, or <code>impl</code> trait block, there is a
<code>Self</code> type that is in scope. The <code>Self</code> type is the type of the class being
defined with all of the generic type parameters filled in. It can be useful to
refer to this type especially in cases where there are many parameters that
would otherwise have to be listed out.</p>
<p>The <code>Self</code> type is necessary when defining generic traits to refer to the
concrete implementing type. Because Rust does not have inheritance between
concrete types and does not have method overriding, this is sufficient to avoid
the need to pass the implementing type as a type parameter.</p>
<p>For examples of this, see the chapter on the <a href="idioms/data_modeling/../../patterns/crtp.html#method-chaining">curiously reoccurring template
pattern</a>.</p>
<h2 id="a-note-on-type-checking-and-type-errors"><a class="header" href="#a-note-on-type-checking-and-type-errors">A note on type checking and type errors</a></h2>
<p>The checking of generic types at the point of definition rather than at the
point of template expansion impacts when errors are detected and how they are
reported. Some of this difference cannot be achieved by consistently using C++
concepts to declare the operations required.</p>
<p>For example, one might accidentally make the <code>nodeLabels</code> member a vector of
<code>size_t</code> instead of a vector of the label parameter. If all of the test cases
for the graph used label types that were convertible to integers, the error
would not be detected.</p>
<p>A similar Rust program fails to compile, even without a function that
instantiates the generic structure with a concrete type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  // The mistake is here: size_t should be Label
  std::vector&lt;size_t&gt; nodeLabels;

public:
  Label getNode(size_t nodeId) {
    return nodeLabels[nodeId];
  }

  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(std::move(label));
    return numNodes() - 1;
  }

  size_t numNodes() const {
    return adjacencies.size();
  }
};

#define BOOST_TEST_MODULE DirectedGraphTests
#include &lt;boost/test/included/unit_test.hpp&gt;

BOOST_AUTO_TEST_CASE(test_add_node_int) {
  DirectedGraph&lt;int&gt; g;
  auto n1 = g.addNode(1);
  BOOST_CHECK_EQUAL(1, g.getNode(n1));
}

BOOST_AUTO_TEST_CASE(test_add_node_float) {
  DirectedGraph&lt;float&gt; g;
  float label = 1.0f;
  auto n1 = g.addNode(label);
  BOOST_CHECK_CLOSE(label, g.getNode(n1), 0.0001);
}
</code></pre>
<pre><code class="language-rust ignore">pub struct DirectedGraph&lt;Label&gt; {
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    // The mistake is here: size_t should be Label
    node_labels: Vec&lt;usize&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn get_node(
        &amp;self,
        node_id: usize,
    ) -&gt; Option&lt;&amp;Label&gt; {
        self.node_labels.get(node_id)
    }

    pub fn add_node(
        &amp;mut self,
        label: Label,
    ) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }
}</code></pre>
</div>
<p>Despite the error, the C++ example compiles and passes the tests.</p>
<pre><code class="language-text">Running 2 test cases...

*** No errors detected
</code></pre>
<p>Even without test cases, the Rust example fails to compile and produces a
message useful for identifying the error.</p>
<pre><code class="language-text">error[E0308]: mismatched types
    --&gt; example.rs:26:31
     |
6    | impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
     |      ----- found this type parameter
...
26   |         self.node_labels.push(label);
     |                          ---- ^^^^^ expected `usize`, found type parameter `Label`
     |                          |
     |                          arguments to this method are incorrect
     |
     = note:        expected type `usize`
             found type parameter `Label`
</code></pre>
<h2 id="lifetimes-parameters"><a class="header" href="#lifetimes-parameters">Lifetimes parameters</a></h2>
<p>Rust's generics are also used for classes, methods, traits, and functions that
are generic in the lifetimes of the references they manipulate. Unlike other
type parameters, using a function with different lifetimes does not cause
additional copies of the function to be generated in the compiled code, because
lifetimes do not impact the runtime representation.</p>
<p>The chapter on concepts includes <a href="idioms/data_modeling/./concepts.html#generics-and-lifetimes">examples of how lifetimes interact with Rust's
generics</a>.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>One significant difference between C++ templates and Rust generics is that C++
templates are actually a more general purpose macro language, supporting things
like conditional compilation (e.g., when used in conjunction with <code>if constexpr</code>, <code>requires</code>, or <code>std::enable_if</code>). Rust supports these use cases with
its macro system, which differs significantly from C++. The most common use of
the macro system, conditional compilation, is provided by <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">the <code>cfg</code> attribute
and <code>cfg!</code> macro</a>.</p>
<p>The separation of conditional compilation from generics in Rust involves similar
design considerations as the omission of <a href="idioms/data_modeling/./template_specialization.html">template
specialization</a> from Rust.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;templates&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;07a5f967-6274-456e-ba10-ccc66bea69b7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt; {\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt;\n    where\n        K: Eq,\n    {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt; {\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt; {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;,&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt;\nwhere\n    K: Eq,\n{\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt; {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename K, typename V&gt;\nclass Assoc {\n  std::vector&lt;std::pair&lt;K, V&gt;&gt; assocs;\n\npublic:\n  void insert(K key, V value) {\n    assocs.push_front(std::make_pair(key, value));\n  }\n\n  std::optional&lt;V &amp;&gt; lookup(K key) const {\n    K k;\n    V v;\n    for (std::pair&lt;K, V&gt; assoc : assocs) {\n      std::tie(k, v) = assoc;\n      if (k == key) {\n        return std::make_optional(v);\n      }\n    }\n    return std::nullopt;\n  }\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="template-specialization"><a class="header" href="#template-specialization">Template specialization</a></h1>
<p>Template specialization in C++ makes it possible for a template entity to have
different implementations for different parameters. Most STL implementations
make use of this to, for example, provide a <a href="https://en.cppreference.com/w/cpp/container/vector_bool">space-efficient representation of
<code>std::vector&lt;bool&gt;</code></a>.</p>
<p>Because of the possibility of template specialization, when a C++ function
operates on values of a template class like <code>std::vector</code>, the function is
essentially defined in terms of the interface provided by the template class,
rather than for a specific implementation.</p>
<p>To accomplish the same thing in Rust requires defining the function in terms of
a trait for the interface against which it operates. This enables clients to
select their choice of representation for data by using any concrete type that
implements the interface.</p>
<p>This is more practical to do in Rust than in C++, because generics not being a
general metaprogramming facility means that <a href="idioms/data_modeling/./templates.html#a-note-on-type-checking-and-type-errors">generic entities can be type
checked
locally</a>,
making them easier to define. It is more common to do in Rust than in C++
because Rust does not have <a href="idioms/data_modeling/./inheritance_and_reuse.html">implementation
inheritance</a>, so there is a
sharper line between interface and implementation than there is in C++.</p>
<p>The following example shows how a Rust function can be implemented so that
different concrete representations can be selected by a client. For a compact
bit vector representation, the example uses the
<a href="https://docs.rs/bitvec/latest/bitvec/vec/struct.BitVec.html"><code>BitVec</code></a> type
from the <a href="https://docs.rs/bitvec/latest/bitvec/">bitvec crate</a>. <code>BitVec</code> is
intended intended to provide an API similar to <code>Vec&lt;bool&gt;</code> or
<code>std::vector&lt;bool&gt;</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void push_if_even(int n,
                  std::vector&lt;T&gt; &amp;collection,
                  T item) {
  if (n % 2 == 0) {
    collection.push_back(std::move(item));
  }
}

int main() {
  // Operate on the default std::vector
  // implementation
  std::vector&lt;std::string&gt; v{"a", "b"};
  push_if_even(2, v, std::string("c"));

  // Operate on the (likely space-optimized)
  // std::vector implementation
  std::vector&lt;bool&gt; bv{false, true};
  push_if_even(2, bv, false);
}
</code></pre>
<pre><code class="language-rust ignore">// The Extend trait is for types that support
// appending values to the collection.
fn push_if_even&lt;T, I: Extend&lt;T&gt;&gt;(
    n: u32,
    collection: &amp;mut I,
    item: T,
) {
    if n % 2 == 0 {
        collection.extend([item]);
    }
}

use bitvec::prelude::*;

fn main() {
    // Operate on Vec
    let mut v =
        vec!["a".to_string(), "b".to_string()];
    push_if_even(2, &amp;mut v, "c".to_string());

    // Operate on BitVec
    let mut bv = bitvec![0, 1];
    push_if_even(2, &amp;mut bv, 0);
}</code></pre>
</div>
<h2 id="trade-offs-between-generics-and-templates"><a class="header" href="#trade-offs-between-generics-and-templates">Trade-offs between generics and templates</a></h2>
<p>Because generic functions can only interact with generic values in ways defined
by the trait bounds, it is easier to test generic implementations. In
particular, code testing a generic implementation only has to consider the
possible behaviors of the given trait.</p>
<p>For a comparison, consider the following programs.</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;totally_ordered T&gt;
T max(const T &amp;x, const T &amp;y) {
  return (x &gt; y) ? x : y;
}

template &lt;&gt;
int max(const int &amp;x, const int &amp;y) {
  return (x &gt; y) ? x + 1 : y + 1;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, T: Ord&gt;(x: &amp;'a T, y: &amp;'a T) -&gt; &amp;'a T {
    if x &gt; y {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In the Rust program, <em>parametricity</em> means that (assuming safe Rust) from the
type alone one can tell that if the function returns, it must return exactly one
of <code>x</code> or <code>y</code>. This is because the trait bound <code>Ord</code> doesn't give any way to
construct new values of type <code>T</code>, and the use of references doesn't give any way
for the function to store one of <code>x</code> or <code>y</code> from an earlier call to return in a
later call.</p>
<p>In the C++ program, a call to <code>max</code> with <code>int</code> as the template parameter will
give a distinctly different result than with any other parameter because of the
template specialization enabling the behavior of the function to vary based on
the type.</p>
<p>The trade-off is that in Rust specialized implementations are harder to use
because they must have different names, but that they are easier to write
because it is easier to write generic code while being confident about its
correctness.</p>
<h2 id="niche-optimization"><a class="header" href="#niche-optimization">Niche optimization</a></h2>
<p>There are several cases where the Rust compiler will perform optimizations to
achieve more efficient representations. Those situations are all ones where the
efficiency gains do not otherwise change the observable behavior of the code.</p>
<p><a href="https://doc.rust-lang.org/std/option/index.html#representation">The most common case is with the <code>Option</code>
type</a>. When
<code>Option</code> is used with a type where the compiler can tell that there are unused
values, one of those unused values will be used to represent the <code>None</code> case, so
that <code>Option&lt;T&gt;</code> will not require an extra word of memory to indicate the
discriminant of the enum.</p>
<p>This optimization is applied to reference types (<code>&amp;</code> and <code>&amp;mut</code>), since
references cannot be null. It is also applied to <code>NonNull&lt;T&gt;</code>, which represents
a non-null pointer to a value of type <code>T</code>, and to <code>NonZeroU8</code> and other non-zero
integral types. The optimization for the reference case is what makes
<code>Option&lt;&amp;T&gt;</code> and <code>Option&lt;&amp;mut T&gt;</code> safer equivalents to using non-owning
observation pointers in C++.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;template_specialization&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;&gt; Both will display \&quot;Unknown type\&quot; for everything other than `int` or `i32`.\n\nIn both cases what will be displayed for other types will depend on\nimplementations/specializations elsewhere in the program.\n\n&gt; Both `displayWithType` and `display_with_type` can be called with ANY\n&gt; arguments whose types overload `&lt;&lt;` or implement `Display`.\n\nThe default function implementation `type_display_name` in the `DisplayWithType`\ntrait does not make it possible to call `display_with_type` on any type. Types\nstill need to explicitly declare that they implement the trait.\n&quot;,&quot;id&quot;:&quot;6ac15484-9038-45b7-9b47-f08918551d3a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Both `displayWithType` and `display_with_type` can ONLY be called with arguments\nwhose types overload `&lt;&lt;` or implement `Display`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Both `displayWithType` and `display_with_type` will display \&quot;Unknown type\&quot; for\neverything other than `int` or `i32`.\n&quot;,&quot;Both `displayWithType` and `display_with_type` can be called with ANY arguments\nwhose types overload `&lt;&lt;` or implement `Display`.\n&quot;],&quot;prompt&quot;:&quot;The following Rust program is an approximate translation of the C++ program.\nWhich statements are true about them?\n\nC++:\n\n```cpp\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid displayWithType(T t) {\n  std::cout &lt;&lt; \&quot;Unknown: \&quot; &lt;&lt; t &lt;&lt; std::endl;\n}\n\ntemplate &lt;&gt;\nvoid displayWithType&lt;int&gt;(int t) {\n  std::cout &lt;&lt; \&quot;int: \&quot; &lt;&lt; t &lt;&lt; std::endl;\n}\n```\n\nRust:\n\n```rust\ntrait TypeDisplayName {\n    fn type_display_name() -&gt; &amp;'static str {\n        \&quot;Unknown\&quot;\n    }\n}\n\nimpl TypeDisplayName for i32 {\n    fn type_display_name() -&gt; &amp;'static str {\n        \&quot;i32\&quot;\n    }\n}\n\nuse std::fmt::Display;\n\nfn display_with_type&lt;T: TypeDisplayName + Display&gt;(x: T) {\n    println!(\&quot;{}: {}\&quot;, T::type_display_name(), x);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;`Option&lt;NonZero&lt;u32&gt;&gt;` makes use of the niche optimization.\n&quot;,&quot;id&quot;:&quot;5523ba5a-2772-4700-946e-2028471ead73&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;They are all the same size.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nOption&lt;NonZero&lt;u32&gt;&gt;\n```\n&quot;,&quot;```rust\nNonZero&lt;u32&gt;\n```\n&quot;,&quot;```rust\nu32\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following types is the largest?\n&quot;}},{&quot;id&quot;:&quot;2f5fbeda-ab4a-48cc-92be-509d8191da0a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nOption&lt;u32&gt;\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nNonZero&lt;u32&gt;\n```\n&quot;,&quot;```rust\nu32\n```\n&quot;,&quot;They are all the same size.&quot;],&quot;prompt&quot;:&quot;Which of the following types is the largest?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="null-nullptr"><a class="header" href="#null-nullptr">Null (nullptr)</a></h1>
<p>This section covers idiomatic uses of <code>nullptr</code> in C++ and how to achieve the
same results in Rust.</p>
<p>Some uses of <code>nullptr</code> in C++ don't arise in the first place in Rust because of
other language differences. For example, <a href="idioms/./null/moved_members.html">moved objects don't leave anything
behind that needs to be destroyed</a>. Therefore
there is no need to use <code>nullptr</code> as a placeholder for a moved pointer that can
have <code>delete</code> or <code>free</code> called on it.</p>
<p>Other uses are replaced by <code>Option</code>, which in safe Rust requires checking for
the empty case before accessing the contained value. This use is common enough
that <a href="https://doc.rust-lang.org/std/option/index.html#representation">Rust has an
optimization</a>
for when <code>Option</code> is used with a reference (<code>&amp;</code> or <code>&amp;mut ref</code>), <code>Box</code>
(equivalent of <code>unique_ptr</code>), and <code>NonNull</code> (a non-null raw pointer).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentinel-values"><a class="header" href="#sentinel-values">Sentinel values</a></h1>
<p>Sentinel values are in-band value that indicates a special situation, such as
having reached the end of valid data in an iterator.</p>
<h2 id="nullptr"><a class="header" href="#nullptr"><code>nullptr</code></a></h2>
<p>Many designs in C++ borrow the convention from C of using a null pointer as a
sentinel value for a method that returns owned pointers. For example, a method
that parses a large structure may produce <code>nullptr</code> in the case of failure.</p>
<p>A similar situation in Rust would make use of the type
<code>Option&lt;Box&lt;LargeStructure&gt;&gt;</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;memory&gt;

class LargeStructure {
  int field;
  // many fields ...
};

std::unique_ptr&lt;LargeStructure&gt;
parse(char *data, size_t len) {
  // ...

  // on failure
  return nullptr;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LargeStructure {
    field: i32,
    // many fields ...
}

fn parse(
    data: &amp;[u8],
) -&gt; Option&lt;Box&lt;LargeStructure&gt;&gt; {
    // ...

    // on failure
    None
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The <code>Box&lt;T&gt;</code> type has the same meaning as <code>std::unique_ptr&lt;T&gt;</code> in terms of being
a uniquely owned pointer to some <code>T</code> on the heap, but unlike <code>std::unique_ptr</code>,
it cannot be null. Rust's <code>Option&lt;T&gt;</code> (which is similar to <code>std::optional&lt;T&gt;</code> in
C++) can represent optional pointers when used in conjunction with <code>Box&lt;T&gt;</code>, as
in <code>Optional&lt;Box&lt;T&gt;&gt;</code>. In <a href="idioms/null/../data_modeling/template_specialization.html#niche-optimization">those cases (and in some other
cases)</a> the
compiler optimizes the representation to be the same size as <code>Box&lt;T&gt;</code> by
leveraging the fact that <code>Box</code> cannot be null.</p>
<p>In Rust it is also common to pay the cost for the extra byte to use a return
type of <code>Result&lt;T, E&gt;</code> (which is akin to <code>std::expected</code> in C++23) in order to
make the reason for the failure available at runtime.</p>
<h2 id="integer-sentinels"><a class="header" href="#integer-sentinels">Integer sentinels</a></h2>
<p>When a possibly-failing function produces an integer, it is also common to use
an otherwise unused or unlikely integer value as a sentinel value, such as <code>0</code>
or <code>INT_MAX</code>.</p>
<p>In Rust, the <code>Option</code> type is used for this purpose. In cases where the zero
value really is not possible to produce, as with the GCD algorithm below, the
type <code>NonZero&lt;T&gt;</code> can be used to indicate that fact. As with <code>Option&lt;Box&lt;T&gt;&gt;</code>,
the compiler optimizes the representation to make use of the unused value (in
this case <code>0</code>) to represent the <code>None</code> case to ensure that the representation of
<code>Option&lt;NonZero&lt;T&gt;&gt;</code> is the same as the representation of <code>Option&lt;T&gt;</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;algorithm&gt;

int gcd(int a, int b) {
  if (b == 0 || a == 0) {
    // returns 0 to indicate invalid input
    return 0;
  }

  while (b != 0) {
    int temp = b;
    b = a % b;
    a = temp;
  }
  return std::abs(a);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::num::NonZero;

fn gcd(
    mut a: i32,
    mut b: i32,
) -&gt; Option&lt;NonZero&lt;i32&gt;&gt; {
    if a == 0 || b == 0 {
        return None;
    }

    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    // At this point, a is guaranteed to not be
    // zero. The `Some` case from `NonZero::new`
    // has a different meaning than the `Some`
    // returned from this function, but here it
    // happens to coincide.
    NonZero::new(a.abs())
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert!(gcd(5, 0) == None);
</span><span class="boring">    assert!(gcd(0, 5) == None);
</span><span class="boring">    assert!(gcd(5, 1) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(1, 5) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(2 * 2 * 3 * 5 * 7, 2 * 2 * 7 * 11) == NonZero::new(2 * 2 * 7));
</span><span class="boring">    assert!(gcd(2 * 2 * 7 * 11, 2 * 2 * 3 * 5 * 7) == NonZero::new(2 * 2 * 7));
</span><span class="boring">}</span></code></pre></pre>
</div>
<p>As an aside, it is also possible to avoid the redundant check for zero at the end, and
without using unsafe Rust, by preserving the non-zeroness property throughout
the algorithm.</p>
<pre><pre class="playground"><code class="language-rust">use std::num::NonZero;

fn gcd(x: i32, mut b: i32) -&gt; Option&lt;NonZero&lt;i32&gt;&gt; {
    if b == 0 {
        return None;
    }

    // a is guaranteed to be non-zero, so we record the fact in the type of a.
    let mut a = NonZero::new(x)?;

    while let Some(temp) = NonZero::new(b) {
        b = a.get() % b;
        a = temp;
    }
    Some(a.abs())
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert!(gcd(5, 0) == None);
</span><span class="boring">    assert!(gcd(0, 5) == None);
</span><span class="boring">    assert!(gcd(5, 1) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(1, 5) == NonZero::new(1));
</span><span class="boring">    assert!(gcd(2 * 2 * 3 * 5 * 7, 2 * 2 * 7 * 11) == NonZero::new(2 * 2 * 7));
</span><span class="boring">    assert!(gcd(2 * 2 * 7 * 11, 2 * 2 * 3 * 5 * 7) == NonZero::new(2 * 2 * 7));
</span><span class="boring">}</span></code></pre></pre>
<h2 id="stdoptional"><a class="header" href="#stdoptional"><code>std::optional</code></a></h2>
<p>In situations where <code>std::optional</code> would be used as a sentinel value in C++,
<code>Option</code> can be used for the same purpose in Rust. The main difference between
the two is that safe Rust requires either explicitly checking whether the value is
<code>None</code>, while in C++ one can attempt to access the value without checking (at
the risk of undefined behavior).</p>
<div class="quiz-placeholder" data-quiz-name="&quot;sentinel_values&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The idiomatic Rust program to find the maximum value in a slice would just\ninvolve calling the `Iterator::max` method on the iterator for the slice.\n\n```rust\nfn find_max(arr: &amp;[i32]) -&gt; Option&lt;i32&gt; {\n    arr.into_iter().max().copied()\n}\n```\n&quot;,&quot;id&quot;:&quot;917b2f68-b4ea-486c-beab-5aa07101ea83&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nfn find_max(arr: &amp;[i32]) -&gt; Option&lt;i32&gt; {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut max = arr[0];\n    for &amp;num in &amp;arr[1..] {\n        if num &gt; max {\n            max = num;\n        }\n    }\n    Some(max)\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn find_max(arr: &amp;[i32]) -&gt; i32 {\n    if arr.is_empty() {\n        return i32::MIN;\n    }\n\n    let mut max = arr[0];\n    for &amp;num in &amp;arr[1..] {\n        if num &gt; max {\n            max = num;\n        }\n    }\n    max\n}\n```\n&quot;,&quot;```rust\nuse std::num::NonZero;\n\nfn find_max(arr: &amp;[i32]) -&gt; Option&lt;NonZero&lt;i32&gt;&gt; {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut max = arr[0];\n    for &amp;num in &amp;arr[1..] {\n        if num &gt; max {\n            max = num;\n        }\n    }\n    NonZero::new(max)\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\n#include &lt;limits&gt;\n\nint findMax(int arr[], int size) {\n  if (size &lt;= 0) {\n    return std::numeric_limits&lt;int&gt;::min();\n  }\n\n  int max = arr[0];\n  for (int i = 1; i &lt; size; ++i) {\n    if (arr[i] &gt; max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="moved-members"><a class="header" href="#moved-members">Moved members</a></h1>
<p>Moving values out of variables or fields in Rust is more explicit than it is in
C++. A value that might be moved with nothing left behind needs to be
represented using an <code>Option&lt;Box&lt;T&gt;&gt;</code> type in Rust, while in C++ it would just
be a <code>std::unique_ptr&lt;T&gt;</code>.</p>
<div class="comparison">
<pre><code class="language-c++">#include &lt;memory&gt;

void readMailbox(std::unique_ptr&lt;int&gt; &amp;mailbox,
                 std::mutex mailboxMutex) {
  std::lock_guard&lt;std::mutex&gt; guard(mailboxMutex);

  if (!mailbox) {
    return;
  }
  int x = *mailbox;
  mailbox = nullptr;
  // use x
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use std::sync::Mutex;

fn read(mailbox: Arc&lt;Mutex&lt;Option&lt;i32&gt;&gt;&gt;) {
    let Ok(mut x) = mailbox.lock() else {
        return;
    };
    let x = x.take();
    // use x
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Additionally, when taking ownership of a value from within a mutable reference,
something has to be left in its place. This can be done using
<a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>std::mem::swap</code></a>, and many
container-like types have methods for making common ownership-swapping more
ergonomic, like
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.take"><code>Option::take</code></a>
as seen in the earlier example,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>Option::replace</code></a>
or
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.swap_remove"><code>Vec::swap</code></a>.</p>
<h2 id="deleting-moved-objects"><a class="header" href="#deleting-moved-objects">Deleting moved objects</a></h2>
<p>Another common use of null pointers in modern C++ is as values for the members
of moved objects so that the destructor can still safely be called. E.g.,</p>
<pre><code class="language-cpp"><span class="boring">#include &lt;cstdlib&gt;
</span><span class="boring">#include &lt;cstring&gt;
</span><span class="boring">
</span>// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t*);
void copy_widget(widget_t* dst, widget_t* src);

// widget.cc
class Widget {
    widget_t* widget;
public:
<span class="boring">    Widget() : widget(alloc_widget()) {}
</span><span class="boring">
</span><span class="boring">    Widget(const Widget &amp;other) : widget(alloc_widget()) {
</span><span class="boring">        copy_widget(widget, other.widget);
</span><span class="boring">    }
</span><span class="boring">
</span>    Widget(Widget &amp;&amp;other) : widget(other.widget) {
        other.widget = nullptr;
    }

    ~Widget() {
        free_widget(widget);
    }
};
</code></pre>
<p>Rust's notion of moving objects does not involve leaving behind an object on
which a destructor will be called, and so this use of null does not have a
corresponding idiom. See the chapter on <a href="idioms/null/../constructors/copy_and_move_constructors.html">copy and move
constructors</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-length-arrays"><a class="header" href="#zero-length-arrays">Zero-length arrays</a></h1>
<p>In C++ codebases that are written in a C style or that make use of C libraries,
null pointers may be used to represent empty arrays.</p>
<p>In Rust, arrays of arbitrary size are represented as
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html">slices</a>. These slices can
have zero length. Since <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Deref-for-Vec%3CT,+A%3E">Rust vectors are convertible to
slices</a>,
defining functions that work with slices enables them to be used with vectors as
well.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;cassert&gt;

int c_style_sum(std::size_t len, int arr[]) {
    int sum = 0;
    for (size_t i = 0; i &lt; len; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int sum = c_style_sum(0, nullptr);
    assert(sum == 0);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn sum_slice(arr: &amp;[i32]) -&gt; i32 {
    let mut sum = 0;
    for x in arr {
        sum += x;
    }
    sum
}

fn main() {
    let sum = sum_slice(&amp;[]);
    assert!(sum == 0);

    let sum2 = sum_slice(&amp;vec![]);
    assert!(sum2 == 0);
}</code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;zero_length_arrays&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;b1f64fba-b6d1-445e-85fb-08a1dfd29fc2&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nfn fill_from(arr: &amp;mut [i32], mut val: i32) {\n    for x in arr {\n        *x = val;\n        val += 1;\n    }\n}\n\nfn main() {\n    let mut x = [];\n    fill_from(&amp;mut x, 5);\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn fill_from(size: usize, arr: &amp;mut [i32], mut val: i32) {\n    for i in 0..size {\n        arr[i] = val;\n        val += 1;\n    }\n}\n\nfn main() {\n    let mut x = [];\n    fill_from(0, &amp;mut x, 5);\n}\n```\n&quot;,&quot;```rust\nfn fill_from(size: usize, opt_arr: Option&lt;&amp;mut [i32]&gt;, mut val: i32) {\n    if let Some(arr) = opt_arr {\n        for i in 0..size {\n            arr[i] = val;\n            val += 1;\n        }\n    }\n}\n\nfn main() {\n    fill_from(0, None, 5);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\n#include &lt;cstddef&gt;\n\nvoid fillFrom(std::size_t len, int arr[], int val) {\n  for (std::size_t i; i &lt; len; i++) {\n    arr[i] = val;\n    val++;\n  }\n}\n\nint main() {\n  fill(0, nullptr, 5);\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h1>
<p>In C++ the encapsulation boundary is the class. In Rust the encapsulation
boundary is the module, which may contain several types along with standalone
functions. In larger projects, the crate may also act as an encapsulation
boundary.</p>
<p>This difference means that in Rust one is more likely to have multiple, tightly
coupled types that work together which are defined in one module and
encapsulated as a whole.</p>
<p>This section provides ways to translate between C++ and Rust's notions of
encapsulation both mechanically and conceptually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-files"><a class="header" href="#header-files">Header files</a></h1>
<p>One use of header files in C++ is to expose declarations that are defined in one
translation units to other translation units without requiring the duplication
of the declarations in multiple files. By convention, declarations that are not
included in the header are considered to be private to the defining translation
unit (though, to enforce this convention other mechanisms, such as <a href="idioms/encapsulation/./anonymous_namespaces.html">anonymous
namespaces</a>, are required).</p>
<p>In contrast, Rust uses neither textually-included header files nor forward
declarations. Instead, Rust modules control visibility and linkage
simultaneously and expose public definitions for use by other modules.</p>
<div class="comparison">
<pre><code class="language-cpp">// person.h
class Person {
  std::string name;

public:
  Person(std::string name) : name(name) {}
  const std::string &amp;getName();
};

// person.cc
#include &lt;string&gt;
#include "person.h"

const std::string &amp;Person::getName() {
  return this-&gt;name;
}

// client.cc
#include &lt;string&gt;
#include "person.h"

int main() {
  Person p("Alice");
  const std::string &amp;name = p.getName();

  // ...
}
</code></pre>
<pre><code class="language-rust ignore">// person.rs
pub struct Person {
    name: String,
}

impl Person {
    pub fn new(name: String) -&gt; Person {
        Person { name }
    }

    pub fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

// client.rs
mod person;

use person::*;

fn main() {
    let p = Person::new("Alice".to_string());
    // doesn't compile, private field
    // let name = p.name;
    let name = p.name();

    //...
}</code></pre>
</div>
<p>In <code>person.rs</code>, the <code>Person</code> type is public but the <code>name</code> field is not. This
prevents both direct construction of values of the type (similar to private
members preventing aggregate initialization in C++) and prevents field access.
The static method <code>Person::new(String)</code> and method <code>Person::name()</code> are exposed
to clients of the module by the <code>pub</code> visibility declarations.</p>
<p>In the <code>client</code> module, the <code>mod</code> declaration defines the content of <code>person.rs</code>
as a submodule named <code>person</code>. The <code>use</code> declaration brings the contents of the
<code>person</code> module into scope.</p>
<h2 id="the-essence-of-the-difference"><a class="header" href="#the-essence-of-the-difference">The essence of the difference</a></h2>
<p>A C++ program is a collection of translation units. Header files are required to
make providing forward declarations of definitions from other translation units
manageable.</p>
<p>A Rust program is a tree of modules. Definitions in one module may access items
from other modules based on visibility declarations given in the definitions of
the module themselves.</p>
<h2 id="submodules-and-additional-visibility-features"><a class="header" href="#submodules-and-additional-visibility-features">Submodules and additional visibility features</a></h2>
<p>Modules and visibility declarations are more powerful than shown in the above
example. More details on how to use modules, <code>pub</code>, and <code>use</code> to achieve
encapsulation goals are described in the chapter on <a href="idioms/encapsulation/./private_and_friends.html">private members and
friends</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;headers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Even if in C++ you wouldn't use namespaces to structure the program, in Rust\nsplitting programs into separate files also means splitting them into separate\nmodules.\n&quot;,&quot;id&quot;:&quot;4665b8ad-511f-4e0b-9dff-bf53e2a8f931&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n// square.rs\npub struct Square {\n    pub width: f64,\n}\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// square.rsi\npub struct Square {\n    pub width: f64;\n}\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64;\n}\n\n// square.rs\nmod square;\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;,&quot;```rust\n// square.rs\npub struct Square {\n    pub width: f64,\n}\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;,&quot;```rust\n// square.rs\nmod square {\n    pub struct Square {\n        pub width: f64,\n    }\n\n    impl Square {\n        pub fn area(&amp;self) -&gt; f64 {\n            self.width * self.width\n        }\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the idiomatic equivalent to the following C++ program?\n\n```cpp\n// square.h\nstruct Square {\n  double width;\n\n  double area() const;\n};\n\n// square.cc\n#include \&quot;square.h\&quot;\n\ndouble Square::area() const {\n  return this-&gt;width * this.width;\n}\n\n// main.cc\n#include \&quot;square.h\&quot;\n#include &lt;iostream&gt;\n\nint main() {\n  Square square(3.0);\n\n  std::cout &lt;&lt; square.area() &lt;&lt; std::endl;\n}\n```\n&quot;}},{&quot;id&quot;:&quot;e3948224-44d7-47d1-bf37-d5667fd8c9bb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `mod` defines a module and `greeting.rs` is not a\nvalid module body.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile and prints `Hello!` to standard out.\n&quot;,&quot;It does not compile because the `main.rs` file must include an explicit `use\ngreetings;` statement.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n// greetings.rs\nprintln!(\&quot;Hello!\&quot;);\n```\n\n```rust\n// main.rs\nfn main() {\n    #[path = \&quot;greetings.rs\&quot;]\n    mod greetings;\n}\n```\n&quot;}},{&quot;context&quot;:&quot;In Rust, `mod` defines a module whose body happens to be given in another file.\nThe whole program is compiled from the root file (in this case `main.rs`) as a\ntree of modules.\n&quot;,&quot;id&quot;:&quot;68d431c0-8d39-4f4f-804c-bb6e7baa8d2b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nmod greetings {\n    pub fn print_greeting() {\n        print_hello();\n        print_goodbye();\n    }\n\n    fn print_hello() {\n        println!(\&quot;Hello!\&quot;);\n    }\n\n    fn print_goodbye() {\n        println!(\&quot;Goodbye!\&quot;);\n    }\n}\n\nuse greetings::*;\n\nfn main() {\n    print_greeting();\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn print_greeting() {\n   print_hello();\n   print_goodbye();\n}\n\nfn print_hello() {\n    println!(\&quot;Hello!\&quot;);\n}\n\nfn print_goodbye() {\n    println!(\&quot;Goodbye!\&quot;);\n}\n\nfn main() {\n    print_hello();\n}\n```\n&quot;,&quot;```rust\nmod greetings {\n    pub fn print_greeting() {\n        print_hello();\n        print_goodbye();\n    }\n\n    fn print_hello() {\n        println!(\&quot;Hello!\&quot;);\n    }\n\n    fn print_goodbye() {\n        println!(\&quot;Goodbye!\&quot;);\n    }\n}\n\nmod main {\n    use greetings::*;\n\n    fn main() {\n        print_greeting();\n    }\n}\n```\n&quot;,&quot;```rust\nmod main {\n    mod greetings {\n        pub fn print_greeting() {\n            print_hello();\n            print_goodbye();\n        }\n\n        fn print_hello() {\n            println!(\&quot;Hello!\&quot;);\n        }\n\n        fn print_goodbye() {\n            println!(\&quot;Goodbye!\&quot;);\n        }\n    }\n\n    use greetings::*;\n\n    fn main() {\n        print_greeting();\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which single-file Rust program is equivalent to this program which is split\nacross multiple files?\n\n```rust\n// greetings.rs\npub fn print_greeting() {\n   print_hello();\n   print_goodbye();\n}\n\nfn print_hello() {\n    println!(\&quot;Hello!\&quot;);\n}\n\nfn print_goodbye() {\n    println!(\&quot;Goodbye!\&quot;);\n}\n\n// main.rs\nmod greetings;\n\nuse greetings::*;\n\nfn main() {\n    print_greeting();\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Since neither `mod` nor `use` performs textual inclusion, it is possible to have\nrecurisve modules within a single crate.\n&quot;,&quot;id&quot;:&quot;b2d00b6a-8efa-40e5-98c7-f9c54f48d09a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program does compile and prints `true`.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because the files have a cyclical dependency.\n&quot;,&quot;It does not compile because `even.rs` and `odd.rs` don't have `mod`\ndeclarations for each other.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n// even.rs\nuse crate::odd::*;\n\npub fn is_even(n: u64) -&gt; bool {\n    if n == 0 {\n        true\n    } else {\n        is_odd(n - 1)\n    }\n}\n\n// odd.rs\nuse crate::even::*;\n\npub fn is_odd(n: u64) -&gt; bool {\n    if n == 1 {\n        true\n    } else {\n        is_even(n - 1)\n    }\n}\n\n// main.rs\nmod even;\nmod odd;\n\nuse even::*;\n\nfn main() {\n    println!(\&quot;{}\&quot;, is_even(4));\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-namespaces-and-static"><a class="header" href="#anonymous-namespaces-and-static">Anonymous namespaces and <code>static</code></a></h1>
<p>Anonymous namespaces in C++ are used to avoid symbol collisions between
different translation units. Such collisions violate <a href="https://timsong-cpp.github.io/cppwp/n4950/basic.def.odr#14">the one definition
rule</a> and result in
undefined behavior (which at best manifests as linking errors).</p>
<p>For example, without the use of anonymous namespaces, the following would result
in undefined behavior (and no linking error, due to the use of <code>inline</code> producing
weak symbols in the object files).</p>
<pre><code class="language-cpp">/// a.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}

/// b.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}
</code></pre>
<p>C++ static declarations are also used to achieve the same goal by making it so that
a declaration has internal linkage (and so is not visible outside of the
translation unit).</p>
<p>Rust avoids the linkage problem by controlling linkage and visibility
simultaneously, with declarations always also being definitions. Instead of
translation units, programs are structured in terms of
<a href="idioms/encapsulation/./headers.html">modules</a>, which provide both namespaces and
visibility controls over definitions, enabling the Rust compiler to guarantee
that symbol collision issues cannot happen.</p>
<p>The following Rust program achieves the same goal as the C++ program above, in
terms of avoiding the collision of the two functions while making them available
for use within the defining files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.rs
<span class="boring">mod a {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span>
// b.rs
<span class="boring">mod b {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Additionally,</p>
<ol>
<li>Unlike C++ namespaces, Rust modules (which provide namespacing as well as
visibility controls) can only be defined once, and this is checked by the
compiler.</li>
<li>Each file <a href="https://doc.rust-lang.org/stable/book/ch07-05-separating-modules-into-different-files.html">defines a module which has to be explicitly included in the module
hierarchy</a>.</li>
<li>Modules from Rust crates (libraries) are always qualified with some root
module name, so they cannot conflict. If they would conflict, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">the root
module name must be replaced with some user-chosen
name</a>.</li>
</ol>
<h2 id="caveats-about-c-interoperability"><a class="header" href="#caveats-about-c-interoperability">Caveats about C interoperability</a></h2>
<p>When using libraries not managed by Rust, the usual problems can occur if there are symbol collisions in the
object files. This can arise when using C or C++ static or dynamic libraries.
It can also arise when using Rust static or dynamic libraries built for use in C or
C++ programs.</p>
<p>Rust provides <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a> to bypass name mangling
in order to produce functions that can be easily
referred to from C or C++. This can also cause undefined behavior due to name collision.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;anonymous_namespaces&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4ed5c1ed-81e3-448d-b20a-8f0eac301489&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n// colors.rs\npub fn red() {}\nfn blue() {}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// colors.rs\nmod colors {\n    pub fn red() {}\n    fn blue() {}\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;,&quot;```rust\n// colors.rs\nmod colors {\n    fn red() {}\n\n    mod {\n        fn blue() {}\n    }\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is an idiomatic translation of the following C++ program?\n\n```cpp\n// colors.h\nnamespace colors {\n  void red();\n}\n\n// colors.cc\n#include \&quot;colors.h\&quot;\n\nnamespace colors {\n  void red() {}\n\n  namespace {\n    void blue() {}\n  }\n}\n\n// main.cc\n#include \&quot;colors.h\&quot;\n\nusing namespace colors;\n\nint main() {}\n```\n&quot;}},{&quot;context&quot;:&quot;Even if in C++ you wouldn't use namespaces to structure the program, in Rust\nsplitting programs into separate files also means splitting them into separate\nmodules.\n&quot;,&quot;id&quot;:&quot;eb1bde49-9ca5-4e8d-b6f3-d49c95393dfb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;red&quot;,&quot;a::red&quot;,&quot;violet&quot;,&quot;b::violet&quot;,&quot;other_colors::green&quot;,&quot;a::other_colors::green&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;orange&quot;,&quot;green&quot;,&quot;indigo&quot;,&quot;a::green&quot;],&quot;prompt&quot;:&quot;In the following Rust program, which items would be visible within the `main`\nfunction?\n\n```rust\n// a.rs\npub fn red() {}\nfn orange() {}\n\npub mod other_colors {\n    pub fn green() {}\n    fn blue() {}\n}\n\n// b.rs\npub fn indigo() {}\npub fn violet() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::violet;\n\nfn main() {\n   // What is visible here?\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Lack of `pub` is like putting it in an anonymous namespace in terms of\nvisibility outside of the defining module.\n\n`mod` is not `#include`. `mod` defines a module, and using items from the module\nrequires either importing or qualification.\n\nResolving ambiguous items works the same as it does with C++ namespaces.\nAmbiguous use is the error, not having conflicting names in scope.\n&quot;,&quot;id&quot;:&quot;b3c2c70b-26b7-4396-8f8a-0e21541896cf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\nfn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs compile?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="private-members-and-friends"><a class="header" href="#private-members-and-friends">Private members and friends</a></h1>
<h2 id="private-members"><a class="header" href="#private-members">Private members</a></h2>
<p>In C++ the unit of encapsulation is the class. Access specifiers (<code>private</code>,
<code>protected</code>, and <code>public</code>) that control access to members are enforced at the
class boundary.</p>
<p>In Rust the module is the unit of encapsulation. Item visibility (Rust's analog
to access specifiers) controls access to items at the module boundary.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
  int age;

public:
  std::string name;

  // Because age is private, a public constructor
  // method is needed to create instances.
  Person(std::string name, int age)
      : name(name), age(age) {}

  // Free functions cannot access private members,
  // so this has to be a member function.
  static void example() {
    Person alice{"Alice", 42};
    std::cout &lt;&lt; alice.name &lt;&lt; std::endl;
    // The private field is visible here, within
    // the class.
    std::cout &lt;&lt; alice.age &lt;&lt; std::endl;
  }
};

int main() {
  Person alice("Alice", 42);
  std::cout &lt;&lt; alice.name &lt;&lt; std::endl;
  // compilation error
  // std::cout &lt;&lt; alice.age &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        // this field is private
        age: i32,
    }

    impl Person {
        // Because age is private, a public
        // constructor method is needed to create
        // values outside of the person module.
        pub fn new(
            name: String,
            age: i32,
        ) -&gt; Person {
            Person { name, age }
        }
    }

    // Free functions in the same module can
    // access private fields because the unit of
    // encapsulation is the module, not the
    // struct.
    fn example() {
        let alice =
            Person::new("Alice".to_string(), 42);
        println!("{}", alice.name);
        // The private field is visible here,
        // within the module.
        println!("{}", alice.age);
    }
}

use person::Person;

fn main() {
    let alice =
        Person::new("Alice".to_string(), 42);
    println!("{}", alice.name);
    // compilation error
    // println!("{}", alice.age);
}</code></pre></pre>
</div>
<p>In the Rust example, the <a href="idioms/encapsulation/./private_constructors.html">constructor for <code>Person</code> is
private</a> because one of the
fields is private.</p>
<h2 id="friends"><a class="header" href="#friends">Friends</a></h2>
<p>Because encapsulation is at the module level in Rust, associated methods for
types can access internals of other types defined in the same module. This
subsumes most uses of the C++ <code>friend</code> declaration.</p>
<p>For example, defining a binary tree in C++ requires that the class representing
the nodes of the tree declare the main binary tree class as a friend in order
for it to access internal methods while keeping them private from other uses.
This would be required even if the <code>TreeNode</code> class were defined as an inner
class of <code>BinaryTree</code>.</p>
<p>In Rust, however, both types can be defined in the same module, and so have
access to each other's private fields and methods. The module as a whole
provides a collection of types, methods, and functions that together define a
encapsulated concept.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;memory&gt;

class BinaryTree {
  // This needs to be an inner class in order for
  // it to be private.
  class TreeNode {
    friend class BinaryTree;

    int value;
    std::unique_ptr&lt;TreeNode&gt; left;
    std::unique_ptr&lt;TreeNode&gt; right;

  public:
    TreeNode(int value)
        : value(value), left(nullptr),
          right(nullptr) {}

  private:
    static void
    insert(std::unique_ptr&lt;TreeNode&gt; &amp;node,
           int value) {
      if (node) {
        node-&gt;insert(value);
      } else {
        node = std::make_unique&lt;TreeNode&gt;(value);
      }
    }

    void insert(int value) {
      if (value &lt; this-&gt;value) {
        insert(this-&gt;left, value);
      } else {
        insert(this-&gt;right, value);
      }
    }
  };

  std::unique_ptr&lt;TreeNode&gt; root;

public:
  BinaryTree() : root(nullptr) {}

  void insert(int value) {
    TreeNode::insert(root, value);
  }
};

int main() {
  BinaryTree b;
  b.insert(42);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod binary_tree {
    pub struct BinaryTree {
        // This field is not visible outside of
        // the module.
        root: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl BinaryTree {
        pub fn new() -&gt; BinaryTree {
            BinaryTree { root: None }
        }

        pub fn insert(&amp;mut self, value: i32) {
            insert(&amp;mut self.root, value);
        }
    }

    // This struct and all its fields are not
    // visible outside of the module.
    struct TreeNode {
        value: i32,
        left: Option&lt;Box&lt;TreeNode&gt;&gt;,
        right: Option&lt;Box&lt;TreeNode&gt;&gt;,
    }

    impl TreeNode {
        fn new(value: i32) -&gt; TreeNode {
            TreeNode {
                value,
                left: None,
                right: None,
            }
        }

        fn insert(&amp;mut self, value: i32) {
            if value &lt; self.value {
                insert(&amp;mut self.left, value);
            } else {
                insert(&amp;mut self.right, value);
            }
        }
    }

    // This free function is not visible outside
    // of the module.
    fn insert(
        node: &amp;mut Option&lt;Box&lt;TreeNode&gt;&gt;,
        value: i32,
    ) {
        match node {
            None =&gt; {
                *node = Some(Box::new(
                    TreeNode::new(value),
                ));
            }
            Some(ref mut left) =&gt; {
                left.insert(value);
            }
        }
    }
}

// This brings the (public) type into scope.
use binary_tree::BinaryTree;

fn main() {
    let mut b = BinaryTree::new();
    b.insert(42);
}</code></pre></pre>
</div>
<h2 id="passkey-idiom"><a class="header" href="#passkey-idiom">Passkey idiom</a></h2>
<p>In the previous C++ example, the <code>TreeNode</code> constructor has to be public in
order to be used with <code>make_unique</code>. Fortunately, the constructor is still
inaccessible outside of the containing class, but it is not always the case that
such helper classes can be inner classes.</p>
<p>To make the constructor effectively private when it is not possible, one might
need to use a programming pattern like <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/patterns/passkey.md">the passkey
idiom</a>.</p>
<p>The passkey idiom is also sometimes used to provide finer-grained control over
access to members than is possible with friend declarations. In either case, the
effect is achieved by modeling a capability-like system.</p>
<p>In Rust, it is possible to express the same idiom in order to achieve the same
effect.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

class Person {
  int age;

  class Passkey {};

public:
  std::string name;

  Person(Passkey, std::string name, int age)
      : name(name), age(age) {}

  static std::unique_ptr&lt;Person&gt;
  createPerson(std::string name, int age) {
    // Other uses of make_unique are not possible
    // because the Passkey type cannot be
    // constructed.
    return std::make_unique&lt;Person&gt;(Passkey(),
                                    name, age);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust">pub trait Maker&lt;K, B&gt; {
    fn make(passkey: K, args: B) -&gt; Self;
}

// Generic helper that we want to be able to call
// an otherwise private function or method.
fn alloc_thing&lt;K, B, T: Maker&lt;K, B&gt;&gt;(
    passkey: K,
    args: B,
) -&gt; Box&lt;T&gt; {
    Box::new(Maker::&lt;K, B&gt;::make(passkey, args))
}

mod person {
    use super::*;
    use std::marker::PhantomData;

    pub struct Person {
        pub name: String,
        age: u32,
    }

    // A zero-sized type to act as the passkey.
    pub struct Passkey {
        // This field is zero-sized. It is also
        // private, which prevents construction
        // of Passkey outside of the person
        // module.
        _phantom: PhantomData&lt;()&gt;,
    }

    impl Person {
        // Private method that will be exposed
        // with a passkey wrapper.
        fn new(name: String, age: u32) -&gt; Person {
            Person { name, age }
        }

        // Method that uses external helper that
        // requires access to another
        // otherwise-private method.
        fn alloc(
            name: String,
            age: u32,
        ) -&gt; Box&lt;Person&gt; {
            alloc_thing(
                Passkey {
                    _phantom: PhantomData {},
                },
                MakePersonArgs { name, age },
            )
        }
    }

    // Helper structure needed to make the trait
    // providing the interface generic.
    pub struct MakePersonArgs {
        pub name: String,
        pub age: u32,
    }

    // Implementation of the trait that exposes
    // the method requiring a passkey.
    impl Maker&lt;Passkey, MakePersonArgs&gt; for Person {
        fn make(
            _passkey: Passkey,
            args: MakePersonArgs,
        ) -&gt; Person {
            Person::new(args.name, args.age)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</div>
<p>However the Passkey idiom is unlikely to be used in Rust because</p>
<ul>
<li>coupled types are usually defined in the same module (or a <code>pub (in path)</code>
declaration can be used), making it unnecessary, and</li>
<li>it requires cooperation from the interface by which the calling function will
use a type.</li>
</ul>
<p>The second point contrasts with the use above involving <code>std::make_unique</code> which
is able to forward to the underlying constructor without knowing about it at the
point of the definition of <code>std::make_unique</code>. While the example below is not
useful (because <code>alloc_thing</code> is not a useful helper), it does demonstrate what
types would have to be defined in order to achieve the same effect as when using
the idiom in C++.</p>
<h2 id="friends-and-testing"><a class="header" href="#friends-and-testing">Friends and testing</a></h2>
<p>Another common use of friend declarations is to make the internals of a class
available for unit testing. Though this practice is often discouraged in C++, it
is sometimes necessary in order to test other-wise private helper inner classes
or helper methods.</p>
<p>In Rust, tests are usually defined in the same module as the code being tested.
Because the content of modules is visible to submodules, this makes it so that
all of the content of the module is available for testing.</p>
<div class="comparison">
<pre><code class="language-cpp">// Using Boost.Test
// https://www.boost.org/doc/libs/1_84_0/libs/test/doc/html/index.html
#include &lt;string&gt;

class Person {
public:
  std::string name;

private:
  int age;

  friend class PersonTest;

public:
  Person(std::string name, int age)
      : name(name), age(age) {}

  void have_birthday() {
    this-&gt;age = this-&gt;age + 1;
  }
};

#define BOOST_TEST_MODULE PersonTestModule
#include &lt;boost/test/included/unit_test.hpp&gt;

class PersonTest {
public:
  static void test_have_birthday() {
    Person alice("Alice", 42);
    BOOST_CHECK_EQUAL(alice.age, 42);

    alice.have_birthday();
    BOOST_CHECK_EQUAL(alice.age, 43);
  }
};

BOOST_AUTO_TEST_CASE(have_birthday_test) {
  PersonTest::test_have_birthday();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
    pub name: String,
    age: u32,
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Person {
        Person { name, age }
    }

    pub fn have_birthday(&amp;mut self) {
        self.age = self.age + 1;
    }
}

#[cfg(test)]
mod test {
    use super::Person;

    #[test]
    fn test_have_birthday() {
        let mut alice =
            Person::new("alice".to_string(), 42);

        assert_eq!(alice.age, 42);
        alice.have_birthday();
        assert_eq!(alice.age, 43);
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<!-- Testing in Rust is described in more detail in the [chapter on unit
testing](/etc/unit_tests.md). -->
<h2 id="visibility-of-methods-on-rust-traits"><a class="header" href="#visibility-of-methods-on-rust-traits">Visibility of methods on Rust traits</a></h2>
<p>Because traits in Rust are intended for the definition of interfaces, the
methods for some type that are declared by a trait are visible whenever both the
trait and the type are visible. In other words, it is not possible to have
private trait methods.</p>
<p>The default visibility for trait methods differs from Rust structs where the
default visibility is private to the defining module.</p>
<h2 id="private-constructors-and-friends"><a class="header" href="#private-constructors-and-friends">Private constructors and friends</a></h2>
<p>In C++ one can control which classes can derive from a specific class by making
all of the constructors private and then declaring classes which may derive from
it as friends.</p>
<p>In Rust, one can achieve the similar goal of controlling which types can
implement a trait by using the <a href="https://predr.ag/blog/definitive-guide-to-sealed-traits-in-rust/">sealed trait
pattern</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;private_and_friends&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Methods for trait implementations are visible wherever both the type and the\ntrait are visible.\n&quot;,&quot;id&quot;:&quot;0cf46fc5-2456-44b1-bb4e-f5adac2ffaf3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It does not compile because the triangle module is not visible from `main`.\n&quot;,&quot;It does not compile because the `area` method of the `Shape` implementation for\nTriangle isn't visible from `main`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because the shapes module is not visible from the location\nof `use`.\n&quot;,&quot;It does not compile because the `area` method of the `Shapes` trait is not\nvisible from `main`.\n&quot;,&quot;It does not compile because the `area` method of the `Shape` trait is not\nvisible from the implementation of the `Shape` trait for `Triangle`.\n&quot;],&quot;prompt&quot;:&quot;Which of the following are reasons why this program does not compile?\n\n```rust\nmod shapes {\n    pub trait Shape {\n        fn area(&amp;self) -&gt; f64;\n    }\n\n    mod triangle {\n        use super::*;\n\n        pub struct Triangle {\n            pub base: f64,\n            pub height: f64,\n        }\n\n        impl Shape for Triangle {\n            fn area(&amp;self) -&gt; f64 {\n                0.5 * self.base * self.height\n            }\n        }\n    }\n}\n\nuse shapes::*;\n\nfn main() {\n    let t = triangle::Triangle {\n        base: 1.0,\n        height: 2.0,\n    };\n    println!(\&quot;{}\&quot;, t.area());\n}\n```\n&quot;}},{&quot;id&quot;:&quot;86a2afdc-85f8-4662-aa1b-b219cb99c457&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Change `mod triangle` to `pub mod triangle`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Change `impl Shape for Triangle` to `pub impl Shape for Triangle`.\n&quot;,&quot;Change `fn area(&amp;self) -&gt; f64` to `pub fn area(&amp;self) -&gt; f64` in the\nimplementation of `Shape` for `Triangle`.\n&quot;,&quot;Change `fn area(&amp;self) -&gt; f64` to `pub fn area(&amp;self) -&gt; f64` in the\ndefinition of the `Shape` trait.\n&quot;],&quot;prompt&quot;:&quot;What changes are required to make this program compile?\n\n```rust\nmod shapes {\n    pub trait Shape {\n        fn area(&amp;self) -&gt; f64;\n    }\n\n    mod triangle {\n        use super::*;\n\n        pub struct Triangle {\n            pub base: f64,\n            pub height: f64,\n        }\n\n        impl Shape for Triangle {\n            fn area(&amp;self) -&gt; f64 {\n                0.5 * self.base * self.height\n            }\n        }\n    }\n}\n\nuse shapes::*;\n\nfn main() {\n    let t = triangle::Triangle {\n        base: 1.0,\n        height: 2.0,\n    };\n    println!(\&quot;{}\&quot;, t.area());\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="private-constructors"><a class="header" href="#private-constructors">Private constructors</a></h1>
<p>In C++ constructors for classes can be made private by declaring them private,
or by defining a class using <code>class</code> and using the default private visibility.</p>
<p>In Rust, constructors (the actual constructors, not <a href="idioms/encapsulation/../constructors.html">"constructor
methods"</a>) for structs are visible from wherever the
type and all fields are visible. To achieve similar visibility restrictions as
in the C++ example, an additional private field needs to be added to the struct
in Rust. Because Rust supports zero-sized types, the additional field can have
no performance cost. The <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit
type</a> has zero size and can
be used for this purpose.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

struct Person {
  std::string name;
  int age;

private:
  Person() = default;
};

int main() {
  // fails to compile, Person::Person() private
  // Person nobody;

  // fails to compile since C++20
  // Person alice{"Alice", 42};
  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        pub age: i32,
        _private: (),
    }

    impl Person {
        pub fn new(
            name: String,
            age: i32,
        ) -&gt; Person {
            Person {
                name,
                age,
                _private: (),
            }
        }
    }
}

use person::*;

fn main() {
    // field `_private` of struct `person::Person`
    // is private
    // let alice = Person {
    //     name: "Alice".to_string(),
    //     age: 42,
    //     _private: (),
    // };

    // cannot construct `person::Person` with
    // struct literal syntax due to private fields
    // let bob = Person {
    //     name: "Bob".to_string(),
    //     age: 55,
    // };

    let carol =
        Person::new("Carol".to_string(), 20);
    // Can match on the public fields, and then
    // use .. to ignore the remaning ones.
    let Person { name, age, .. } = carol;
}</code></pre></pre>
</div>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>Unlike C++ unions, but like <code>std::variant</code>, Rust enums do not have direct
control over the visibility of their variants or the fields of their variants.
In the following example, the <code>circle</code> variant of the <code>Shape</code> union is not
public, so it can only be accessed from within the definition of <code>Shape</code>, as it
is by the <code>make_circle</code> static method.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;
};

struct Circle {
  double radius;
};

union Shape {
  Triangle triangle;

private:
  Circle circle;

public:
  static Shape make_circle(double radius) {
    Shape s;
    s.circle = Circle(radius);
    return s;
  };
};

int main() {
  Shape triangle;
  triangle.triangle = Triangle{1.0, 2.0};
  Shape circle = Shape::make_circle(1.0);

  // fails to compile
  // circle.circle = Circle{1.0};

  // fails to compile
  // std::cout &lt;&lt; shape.circle.radius;
}
</code></pre>
<p>In Rust visibility modifiers cannot be applied to individual enum variants or
their fields.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum Shape {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }
}

use shape::*;

fn main() {
    // Variant constructor is accesssible despite not being marked pub.
    let triangle = Shape::Triangle {
        base: 1.0,
        height: 2.0,
    };

    let circle = Shape::Circle { radius: 1.0 };

    // Fields accessbile despite not being marked pub.
    match circle {
        Shape::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle { radius } =&gt; {
            println!("Circle {}", radius);
        }
    }
}</code></pre></pre>
<p>Instead, to control construction of and pattern matching on the enum
implementation, one of two approaches can be taken. The first controls
construction of and access to the fields, but not inspection of which variant is
active.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub struct Triangle {
        pub base: f64,
        pub height: f64,
        _private: (),
    }
    pub struct Circle {
        pub radius: f64,
        _private: (),
    }

    pub enum Shape {
        Triangle(Triangle),
        Circle(Circle),
    }

    impl Shape {
        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape::Triangle(Triangle {
                base,
                height,
                _private: (),
            })
        }

        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape::Circle(Circle {
                radius,
                _private: (),
            })
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    match circle {
        Shape::Triangle(Triangle { base, height, .. }) =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle(Circle { radius, .. }) =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The second places the enum in a struct with a private field, preventing both
construction and inspection from outside of the module.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape(ShapeKind::Circle { radius })
        }

        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape(ShapeKind::Triangle { base, height })
        }

        pub fn print(&amp;self) {
            match self.0 {
                ShapeKind::Triangle { base, height } =&gt; {
                    println!("Triangle: {}, {}", base, height);
                }
                ShapeKind::Circle { radius } =&gt; {
                    println!("Circle: {}", radius);
                }
            }
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(_) -&gt; {}
    // }

    circle.print();
}</code></pre></pre>
<p>If the purpose of making the variants private is to ensure that invariants are
met, then it can be useful to expose the implementing enum (<code>ShapeKind</code>) but not
the field of the wrapping struct (<code>Shape</code>), with the invariants only being
guaranteed when the wrapping struct is used. In this case, it is necessary to
make the field private and define a getter function, since otherwise the field
would be modifiable, possibly violating the invariant that the wrapping struct
represents.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    // The field of Shape is private.
    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new(kind: ShapeKind) -&gt; Option&lt;Shape&gt; {
            // ... check invariants ...
            Some(Shape(kind))
        }

        pub fn get_kind(&amp;self) -&gt; &amp;ShapeKind {
            &amp;self.0
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new(ShapeKind::Triangle {
        base: 1.0,
        height: 2.0,
    });
    let Some(circle) = Shape::new(ShapeKind::Circle { radius: 1.0 }) else {
        return;
    };

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(c) =&gt; {}
    // };

    match circle.get_kind() {
        ShapeKind::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        ShapeKind::Circle { radius } =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The situation in Rust resembles the situation in C++ when using <code>std::variant</code>,
for which it is not possible to make the variants themselves private. Instead
either the constructors for the types that form the variants can be made private
or the variant can be wrapped in a class with appropriate visibility controls.</p>
<h2 id="rusts-non_exhaustive-annotation"><a class="header" href="#rusts-non_exhaustive-annotation">Rust's <code>#[non_exhaustive]</code> annotation</a></h2>
<p>If a struct or enum is intended to be public within a
<a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crate</a>, but
should not be constructed outside of the crate, then the <code>#[non_exhaustive]</code>
attribute can be used to constrain construction. The attribute can be applied to
both structs and to individual enum variants with the same effect as adding a
private field.</p>
<p>However, the attribute applies the constraint at the level of the crate, not at
the level of a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Person {
    pub name: String,
    pub age: i32,
}

pub enum Shape {
    #[non_exhaustive]
    Triangle { base: f64, height: f64 },
    #[non_exhaustive]
    Circle { radius: f64 },
}
<span class="boring">}</span></code></pre></pre>
<p>The attribute is more typically used to force clients of a library to include
the wildcard when matching on the struct fields, making it so that adding
additional fields to a struct is not breaking change (i.e., that it does not
<a href="https://doc.rust-lang.org/cargo/reference/semver.html">require the increase of the major version component when using semantic
versioning</a>).</p>
<p>Applying the <code>#[non_exhaustive]</code> attribute to the enum itself makes it as if one
of the variants were private, requiring a wildcard when matching on the variant
itself. This has the same effect in terms of versioning as when used on a struct
but is less advantageous. In most cases, code failing to compile when a new enum
variant is added is desirable, since that indicates a new case that requires
handling logic.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;private_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;62d1037a-740b-4f66-a195-741fa73f59fc&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`Person` can be constructed in `test_method`.\n&quot;,&quot;`_private` can be accessed in `test_method`.\n&quot;,&quot;`name` can be accessed in `test_method`.\n&quot;,&quot;`name` can be accessed in `main`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Person` can be constructed in `main`.\n&quot;,&quot;`_private` can be accessed in `main`.\n&quot;,&quot;Values of type `Person` are larger than values of type `Pet`.\n&quot;],&quot;prompt&quot;:&quot;Which statements are true about the following Rust program?\n\n```rust\nmod people {\n    pub struct Person {\n        pub name: String,\n        pub age: i32,\n        _private: (),\n    }\n\n    pub struct Pet {\n        pub name: String,\n        pub age: i32,\n    }\n\n    fn test_method() {\n      // ...\n    }\n}\n\nuse people::*;\n\nfn main() {\n    // ...\n}\n```\n&quot;}},{&quot;id&quot;:&quot;df42cbcd-d5c0-486d-9509-371d05bc2145&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nmod vec {\n    pub struct Vec2 {\n        x: f64,\n        y: f64,\n    }\n\n    impl Vec2 {\n        pub fn new() -&gt; Vec2 {\n            Vec2 { x: 0.0, y: 0.0 }\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct Vec2 {\n    x: f64,\n    y: f64,\n}\n\nimpl Vec2 {\n    pub fn new() -&gt; Vec2 {\n        Vec2 { x: 0.0 , y: 0.0 }\n    }\n}\n```\n&quot;,&quot;```rust\nmod vec {\n    pub struct Vec2 {\n        x: f64,\n        y: f64,\n        _private: (),\n    }\n\n    impl Vec2 {\n        fn new() -&gt; Vec2 {\n            Vec2 { x: 0.0, y: 0.0 }\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nclass Vec2 {\n  double x;\n  double y;\n\npublic:\n  Vec2() : x(0.0), y(0.0) {}\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="setter-and-getter-methods"><a class="header" href="#setter-and-getter-methods">Setter and getter methods</a></h1>
<p>Setters and getters work similarly in C++ and Rust, but are used less frequently
in Rust.</p>
<p>It would not be unusual to see the following representation of a two-dimensional
vector in C++, which hides its implementation and provides setters and getters
to access the fields. This choice would typically be made in case a
representation change (such as using polar instead of rectangular coordinates)
needed to be made later without breaking clients.</p>
<p>On the other hand, in Rust such a type would almost always be defined with
public fields.</p>
<div class="comparison">
<pre><code class="language-cpp">class Vec2 {
  double x;
  double y;

public:
  Vec2(double x, double y) : x(x), y(y) {}
  double getX() { return x; }
  double getY() { return y; }

  // ... vector operations ...
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec2 {
    // public fields instead of getters
    pub x: f64,
    pub y: f64,
}

impl Vec2 {
    // ... vector operations ...
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>One major reason for the difference is a limitation of the borrow checker. With
a getter function the entire structure is borrowed, preventing mutable use of
other fields of the structure.</p>
<p>The following program will not compile because <code>get_name()</code> borrows all of
<code>alice</code>.</p>
<pre><code class="language-rust ignore">struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn get_name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

fn main() {
    let mut alice = Person { name: "Alice".to_string(), age: 42 };
    let name = alice.get_name();

    alice.age = 43;

    println!("{}", name);
}</code></pre>
<pre><code class="language-text">error[E0506]: cannot assign to `alice.age` because it is borrowed
  --&gt; example.rs:16:5
   |
14 |     let name = alice.get_name();
   |                ----- `alice.age` is borrowed here
15 |
16 |     alice.age = 43;
   |     ^^^^^^^^^^^^^^ `alice.age` is assigned to here but it was already borrowed
17 |
18 |     println!("{}", name);
   |                    ---- borrow later used here

error: aborting due to 1 previous error
</code></pre>
<p>Some additional reasons for the difference in approach are:</p>
<ul>
<li>Ergonomics: Public members make it possible to use pattern matching.</li>
<li>Transparency of performance: A change in representation would dramatically
change the costs involved with the getters. Exposing the representation makes
the cost change visible.</li>
<li>Control over mutability: Static lifetime checking of mutable references
removes concerns of unintended mutation of the value through Rust's equivalent
of observation pointers.</li>
</ul>
<h2 id="types-with-invariants-and-newtypes"><a class="header" href="#types-with-invariants-and-newtypes">Types with invariants and newtypes</a></h2>
<p>When types need to preserve invariants but the benefits of exposing fields are
desired, a newtype pattern can be used. A wrapping "newtype" struct that
represents the data with an invariant is defined and access to the fields of the
underlying struct is provided by via a non-<code>mut</code> reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec2 {
    pub x: f64,
    pub y: f64,
}

/// Represents a 2-vector that has magnitude 1.
pub struct Normalized(Vec2); // note the private field

fn sqrt_approx_zero(x: f64) -&gt; bool {
    x &lt; 0.001
}

impl Normalized {
    pub fn from_vec2(v: Vec2) -&gt; Option&lt;Self&gt; {
        if sqrt_approx_zero(v.x * v.x + v.y * v.x - 1.0) {
            Some(Self(v))
        } else {
            None
        }
    }

    // The getter provides a reference to the underlying Vec2 value
    // without permitting mutation.
    pub fn get(&amp;self) -&gt; &amp;Vec2 {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="borrowing-from-indexed-structures"><a class="header" href="#borrowing-from-indexed-structures">Borrowing from indexed structures</a></h2>
<p>A significant limitation that arises from the way that getter methods interact
with the borrow checker is that it isn't possible to mutably borrow multiple
elements from an indexed structure like a vector using a methods like
<code>Vec::get_mut</code>.</p>
<p>The built-in indexed types have several methods for creating split views onto a
structure. These can be used to create helper functions that match the
requirements of a specific application.</p>
<p>The Rustonomicon has <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html">examples of implementing this
pattern</a>, using both
safe and unsafe Rust.</p>
<h2 id="setter-methods"><a class="header" href="#setter-methods">Setter methods</a></h2>
<p>Setter methods also borrow the entire value, which causes the same problems as
getters that return mutable references. As with getter methods, setter methods
are mainly used when needed to preserve invariants.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;setters_and_getters&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Making the fields public does not accomplish the goal of hiding the\nimplementation.\n\nCombining the `sensor` and `calibration` modules and passing the whole `Sensor`\nto `calibrate` couples calibration to the specific `Sensor` type.\n&quot;,&quot;id&quot;:&quot;3040ed69-72e3-4c56-a5f6-be1269dfdabc&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Define a view type with public fields exposing only the relevant parts of `Sensor`.\n\n&lt;details&gt;\n&lt;summary&gt;View diff&lt;/summary&gt;\n\n```diff\n@@ -7,6 +7,11 @@ mod calibration {\n\n     pub struct Calibration;\n\n+    pub struct CalibrationView&lt;'a&gt; {\n+        pub calibration: &amp;'a mut Calibration,\n+        pub data: &amp;'a Data,\n+    }\n+\n     pub fn calibrate(\n         calibration: &amp;mut Calibration,\n         data: &amp;Data,\n@@ -39,8 +44,11 @@ mod sensors {\n             &amp;self.data\n         }\n\n-        pub fn calibration(&amp;mut self) -&gt; &amp;mut Calibration {\n-            &amp;mut self.calibration\n+        pub fn calibration(&amp;mut self) -&gt; CalibrationView {\n+            CalibrationView {\n+                calibration: &amp;mut self.calibration,\n+                data: &amp;self.data,\n+            }\n         }\n     }\n }\n@@ -51,5 +59,10 @@ use sensors::*;\n fn main() {\n     let mut sensor = Sensor::new();\n     let reference_sensor = Sensor::new();\n-    calibrate(sensor.calibration(), sensor.data(), reference_sensor.data());\n+    let calibration = sensor.calibration();\n+    calibrate(\n+        calibration.calibration,\n+        calibration.data,\n+        reference_sensor.data(),\n+    );\n }\n```\n&lt;/details&gt;\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Make the needed fields of `Sensor` public.\n\n&lt;details&gt;\n&lt;summary&gt;View diff&lt;/summary&gt;\n\n```diff\n@@ -21,8 +21,8 @@ mod sensors {\n     use data::*;\n\n     pub struct Sensor {\n-        data: Data,\n-        calibration: Calibration,\n+        pub data: Data,\n+        pub calibration: Calibration,\n         // ... other fields ...\n     }\n\n@@ -34,14 +34,6 @@ mod sensors {\n                 // ... other fields ...\n             }\n         }\n-\n-        pub fn data(&amp;self) -&gt; &amp;Data {\n-            &amp;self.data\n-        }\n-\n-        pub fn calibration(&amp;mut self) -&gt; &amp;mut Calibration {\n-            &amp;mut self.calibration\n-        }\n     }\n }\n\n@@ -51,5 +43,9 @@ use sensors::*;\n fn main() {\n     let mut sensor = Sensor::new();\n     let reference_sensor = Sensor::new();\n-    calibrate(sensor.calibration(), sensor.data(), reference_sensor.data());\n+    calibrate(\n+        &amp;mut sensor.calibration,\n+        &amp;sensor.data,\n+        &amp;reference_sensor.data,\n+    );\n }\n```\n&lt;/details&gt;\n&quot;,&quot;Combine the sensors and calibration modules and pass the whole `Sensor` to\n`calibrate`.\n\n&lt;details&gt;\n&lt;summary&gt;View diff&lt;/summary&gt;\n\n```diff\n@@ -2,23 +2,14 @@ mod data {\n     pub struct Data;\n }\n\n-mod calibration {\n+mod sensors {\n     use data::*;\n\n     pub struct Calibration;\n\n-    pub fn calibrate(\n-        calibration: &amp;mut Calibration,\n-        data: &amp;Data,\n-        reference_data: &amp;Data,\n-    ) {\n+    pub fn calibrate(sensor: &amp;mut Sensor, reference_data: &amp;Data) {\n         // ... update the calibration ...\n     }\n-}\n-\n-mod sensors {\n-    use calibration::*;\n-    use data::*;\n\n     pub struct Sensor {\n         data: Data,\n@@ -38,18 +29,13 @@ mod sensors {\n         pub fn data(&amp;self) -&gt; &amp;Data {\n             &amp;self.data\n         }\n-\n-        pub fn calibration(&amp;mut self) -&gt; &amp;mut Calibration {\n-            &amp;mut self.calibration\n-        }\n     }\n }\n\n-use calibration::*;\n use sensors::*;\n\n fn main() {\n     let mut sensor = Sensor::new();\n     let reference_sensor = Sensor::new();\n-    calibrate(sensor.calibration(), sensor.data(), reference_sensor.data());\n+    calibrate(&amp;mut sensor, reference_sensor.data());\n }\n```\n&lt;/details&gt;\n&quot;],&quot;prompt&quot;:&quot;The following Rust program attempts to use getter functions in the style of a\nC++ program in order to hide the representation of `Sensor`.\n\n```rust\nmod data {\n    pub struct Data;\n}\n\nmod calibration {\n    use data::*;\n\n    pub struct Calibration;\n\n    pub fn calibrate(\n        calibration: &amp;mut Calibration,\n        data: &amp;Data,\n        reference_data: &amp;Data,\n    ) {\n        // ... update the calibration ...\n    }\n}\n\nmod sensors {\n    use calibration::*;\n    use data::*;\n\n    pub struct Sensor {\n        data: Data,\n        calibration: Calibration,\n        // ... other fields ...\n    }\n\n    impl Sensor {\n        pub fn new() -&gt; Sensor {\n            Sensor {\n                data: Data,\n                calibration: Calibration,\n                // ... other fields ...\n            }\n        }\n\n        pub fn data(&amp;self) -&gt; &amp;Data {\n            &amp;self.data\n        }\n\n        pub fn calibration(&amp;mut self) -&gt; &amp;mut Calibration {\n            &amp;mut self.calibration\n        }\n    }\n}\n\nuse calibration::*;\nuse sensors::*;\n\nfn main() {\n    let mut sensor = Sensor::new();\n    let reference_sensor = Sensor::new();\n    calibrate(sensor.calibration(), sensor.data(), reference_sensor.data());\n}\n```\n\nHowever, it fails to compile with the following error message.\n\n```text\nerror[E0502]: cannot borrow `sensor` as immutable because it is also borrowed as mutable\n  --&gt; example.rs:42:37\n   |\n42 |     calibrate(sensor.calibration(), sensor.data(), reference_sensor.data());\n   |     --------- ------                ^^^^^^ immutable borrow occurs here\n   |     |         |\n   |     |         mutable borrow occurs here\n   |     mutable borrow later used by call\n```\n\nWhich is the most idiom change to make the program work while still hiding the\nimplementation of `Sensor`?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions-and-error-handling"><a class="header" href="#exceptions-and-error-handling">Exceptions and error handling</a></h1>
<p>In C++ errors that are to be handled by the caller are sometimes indicated by
sentinel values (e.g., <code>std::map::find</code> producing an empty iterator), sometimes
indicated by exceptions (e.g., <code>std::vector::at</code> throwing <code>std::out_of_range</code>),
and sometimes indicated by setting an error bit (e.g., <code>std::fstream::fail</code>).
Errors that are not intended to be handled by the caller are usually indicated
by exceptions (e.g., <code>std::bad_cast</code>). Errors that are due to programming bugs
often just result in undefined behavior (e.g., <code>std::vector::operator[]</code> when
the index is out-of-bounds).</p>
<p>In contrast, safe Rust has two mechanisms for indicating errors. When the error
is expected to be handled by the caller (because it is due to, e.g., user
input), the function returns a
<a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> or
<a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>. When the error is
due to a programming bug, the function panics. Undefined behavior can only occur
if unchecked variants of functions are used with unsafe Rust.</p>
<p>Some libraries in Rust will offer two versions of an API, one which returns a
<code>Result</code> or <code>Option</code> type and one of which panics, so that the interpretation of
the error (expected exceptional case or programmer bug) can be chosen by the
caller.</p>
<p>The major differences between using <code>Result</code> or <code>Option</code> and using exceptions
are that</p>
<ol>
<li><code>Result</code> and <code>Option</code> force explicit handling of the error case in order to
access the contained value. This also differs from <code>std::expected</code> in C++23.</li>
<li>When propagating errors with <code>Result</code>, the types of the errors must match.
There are libraries for making this easier to handle.</li>
</ol>
<h2 id="result-vs-option"><a class="header" href="#result-vs-option"><code>Result</code> vs <code>Option</code></a></h2>
<p>The approaches demonstrated in the Rust examples in this chapter apply to both
<code>Result</code> and <code>Option</code>. When the type is <code>Option</code> it indicates that there is no
additional information to provide in the error case: <code>Option::None</code> does not
contain a value, but <code>Result::Err</code> does. When there is no additional
information, is usually because there is exactly one circumstance which can
cause the error case.</p>
<p>It is possible to convert between the two types.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r: Result&lt;i32, &amp;'static str&gt; =
        None.ok_or("my error message");
    let r2: Result&lt;i32, &amp;'static str&gt; =
        None.ok_or_else(|| "expensive error message");
    let o: Option&lt;i32&gt; = r.ok();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expected-errors"><a class="header" href="#expected-errors">Expected errors</a></h1>
<p>In C++, <code>throw</code> both produces an error (the thrown exception) and initiates
non-local control flow (unwinding to the nearest <code>catch</code> block). In Rust, error
values (<code>Option::None</code> or <code>Result::Err</code>) are returned as normal values from a
function. Rust's <code>return</code> statement can be used to return early from a function.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

double divide(double dividend, double divisor) {
  if (divisor == 0.0) {
    throw std::domain_error("zero divisor");
  }

  return dividend / divisor;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(
    dividend: f64,
    divisor: f64,
) -&gt; Option&lt;f64&gt; {
    if divisor == 0.0 {
        return None;
    }

    Some(dividend / divisor)
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The requirement to have the return type indicate that an error is possible means
that callbacks that are permitted to have errors need to be given an <code>Option</code> or
<code>Result</code> return type. Omitting that is like requiring callbacks to be <code>noexcept</code>
in C++. Functions that do not need to indicate errors but that will be used as
callbacks where errors are permitted will need to wrap their results in
<code>Option::Some</code> or <code>Result::Ok</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

int produce_42() {
  return 42;
}

int fail() {
  throw std::runtime_error("oops");
}

int useCallback(int (*func)(void)) {
  return func();
}

int main() {
  try {
    int x = useCallback(produce_42);
    int y = useCallback(fail);

    // use x and y
  } catch (std::runtime_error &amp;e) {
    // handle error
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn produce_42() -&gt; i32 {
    42
}

fn fail() -&gt; Option&lt;i32&gt; {
    None
}

fn use_callback(
    f: impl Fn() -&gt; Option&lt;i32&gt;,
) -&gt; Option&lt;i32&gt; {
    f()
}

fn main() {
    // need to wrap produce_42 to match the
    // expected type
    let Some(x) =
        use_callback(|| Some(produce_42()))
    else {
        // handle error
        return;
    };
    let Some(y) = use_callback(fail) else {
        // handle error
        return;
    };
    // use x and y
}</code></pre></pre>
</div>
<h2 id="handling-errors"><a class="header" href="#handling-errors">Handling errors</a></h2>
<p>In C++, the only way to handle exceptions is <code>catch</code>. In Rust, all of the
features for dealing with <a href="idioms/exceptions/../data_modeling/tagged_unions.html">tagged
unions</a> can be used with <code>Result</code> and
<code>Option</code>. The most approach depends on the intention of the program.</p>
<p>The basic way of handling an error indicated by a <code>Result</code> in Rust is by using
<code>match</code>.</p>
<p>Using <code>match</code> is the most general approach, because it enables handling
additional cases explicitly and can be used as an expression. <code>match</code> connotes
equal importance of all branches.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;stdexcept&gt;

int main() {
    std::vector&lt;int&gt; v;
    // ... populate v ...
    try {
        auto x = v.at(0);
        // use x
    } catch (std::out_of_range &amp;e) {
        // handle error
    }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    match v.get(0) {
        Some(x) =&gt; {
            // use x
        }
        None =&gt; {
            // handle error
        }
    }
}</code></pre></pre>
</div>
<p>Because handling only a single variant of a Rust enum is so common, the <code>if let</code>
syntax support that use case. The syntax both makes it clear that only the one
case is important and reduces the levels of indentation.</p>
<p><code>if let</code> is less general than <code>match</code>. It can also be used as an expression, but
can only distinguish one case from the rest. <code>if let</code> connotes that the <code>else</code>
case is not the normal case, but that some default handling will occur or some
default value will be produced.</p>
<p>Note that with <code>Result</code>, <code>if let</code> does not enable accessing the error value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    if let Some(x) = v.get(0) {
        // use x
    } else {
        // handle error
    }
}</code></pre></pre>
<p>When the error handling involves some kind of control flow operation, like
<code>break</code> or <code>return</code>, the <code>let else</code> syntax is even more concise.</p>
<p>Much like normal <code>let</code> statements, <code>let else</code> statements can only be used where
statements are expected. <code>let else</code> statements also connote that the else case
is not the normal case, and that no further (normal) processing will occur.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    let Some(x) = v.get(0) else {
        // handle error
        return;
    };
    // use x
}</code></pre></pre>
<p><code>Result</code> and <code>Option</code> also have some helper methods for handling errors.
These methods resemble the methods on <code>std::expected</code> in C++.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;expected&gt;
#include &lt;string&gt;

int main() {
  std::expected&lt;int, std::string&gt; res(42);
  auto x(res.transform([](int n) { return n * 2; }));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let res: Result&lt;i32, String&gt; = Ok(42);
    let x = res.map(|n| n * 2);
}</code></pre></pre>
</div>
<p>These helper methods and others are described in detail in the documentation for
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a>
and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#implementations"><code>Result</code></a>.</p>
<h2 id="borrowed-results"><a class="header" href="#borrowed-results">Borrowed results</a></h2>
<p>In the above examples, the successful results are borrowed from the vector. It
common to need to clone or copy the result into an owned copy, and to want to do
so without having to match on and reconstruct the value. <code>Result</code> and <code>Option</code>
have helper methods for these purposes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    v.push(42);
    let x: Option&lt;&amp;i32&gt; = v.get(0);
    let y: Option&lt;i32&gt; = v.get(0).copied();

    let mut w = Vec::&lt;String&gt;::new();
    w.push("hello".to_string());
    let s: Option&lt;&amp;String&gt; = w.get(0);
    let r: Option&lt;String&gt; = w.get(0).cloned();
}</code></pre></pre>
<h2 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating errors</a></h2>
<p>In C++, exceptions propagate automatically. In Rust, errors indicated by
<code>Result</code> or <code>Option</code> must be explicitly propagated. The <code>?</code> operator is a
convenience for this. There are also several methods for manipulating <code>Result</code>
and <code>Option</code> that have a similar effect to propagating the error.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;vector&gt;

int accessValue(std::vector&lt;std::size_t&gt; indices,
                 std::vector&lt;int&gt; values,
                 std::size_t i) {
  // vector::at throws
  size_t idx(indices.at(i));
  // vector::at throws
  return values.at(idx);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // * dereferences the &amp;i32 to copy it
    // ? propagates the None
    let idx = *indices.get(i)?;
    // returns the Option directly
    values.get(idx).copied()
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The above Rust example is equivalent to the following, which does not use the
<code>?</code> operator. The version using <code>?</code> is more idiomatic.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // matching through the &amp; makes a copy of the i32
    let Some(&amp;idx) = indices.get(i) else {
        return None;
    };
    // still returns the Option directly
    values.get(idx).copied()
}
<span class="boring">}</span></code></pre></pre>
<p>The following example is also equivalent. It is not idiomatic (using <code>?</code> here is
more readable), but does demonstrate one of the helper methods.
<code>Option::and_then</code> is similar to <a href="https://en.cppreference.com/w/cpp/utility/optional/and_then"><code>std::optional::and_then</code> in
C++23</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // matching through the &amp; makes a copy of the i32
    indices
        .get(i)
        .and_then(|idx| values.get(*idx))
        .copied()
}
<span class="boring">}</span></code></pre></pre>
<p>These helper methods and others are described in detail in the documentation for
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a>
and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#implementations"><code>Result</code></a>.</p>
<h2 id="uncaught-exceptions-in-main"><a class="header" href="#uncaught-exceptions-in-main">Uncaught exceptions in <code>main</code></a></h2>
<p>In C++ when an exception is uncaught, it terminates the program with a non-zero
exit code and an error message. To achieve a similar result using <code>Result</code> in
Rust, <code>main</code> can be given a return type of <code>Result</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

int main() {
  throw std::runtime_error("oops");
}
</code></pre>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    Err("oops")
}</code></pre>
</div>
<p>In Rust, the <code>main</code> function can return any type that implements the <a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>Termination</code>
trait</a>, such as
<code>()</code>, <code>Result</code>, and <a href="https://doc.rust-lang.org/std/process/struct.ExitCode.html"><code>ExitCode</code></a>.
For example, <code>main</code> can return a result whose error type implements the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code>
trait</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run">#[derive(Debug)]
struct InterestingError {
    message: &amp;'static str,
    other_interesting_value: i32,
}

fn main() -&gt; Result&lt;(), InterestingError&gt; {
    Err(InterestingError {
        message: "oops",
        other_interesting_value: 9001,
    })
}</code></pre></pre>
<p>Running this program produces the output <code>Error: InterestingError { message: "oops", other_interesting_value: 9001 }</code> with an exit code of <code>1</code>.</p>
<h2 id="limitations-to-forcing-error-handling-with-result"><a class="header" href="#limitations-to-forcing-error-handling-with-result">Limitations to forcing error handling with <code>Result</code></a></h2>
<p>Returning <code>Result</code> or <code>Option</code> does not give the usual benefits when used with
APIs that pass pre-allocated buffers by mutable reference. This is because the
buffer is accessible outside of the <code>Result</code> or <code>Option</code>, and so the compiler
cannot force handling of the error case.</p>
<p>For example, in the following example the result of <code>read_line</code> can be ignored,
resulting in logic errors in the program. However, since the buffer is required
to be initialized, it will not result in memory safety violations or undefined
behavior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut buffer = String::with_capacity(1024);
    std::io::stdin().read_line(&amp;mut buffer);
    // use buffer
}</code></pre></pre>
<p>Rust will produce a warning in this case, because of the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>#[must_use]</code>
attribute</a>
on <code>Result</code>.</p>
<pre><code class="language-text">warning: unused `Result` that must be used
 --&gt; example.rs:3:5
  |
3 |     std::io::stdin().read_line(&amp;mut buffer);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this `Result` may be an `Err` variant, which should be handled
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
3 |     let _ = std::io::stdin().read_line(&amp;mut buffer);
  |     +++++++
</code></pre>
<p><code>Option</code> does not have a <code>#[must_use]</code> attribute, so functions that return an
<code>Option</code> that must be handled (due to the <code>None</code> case indicating an error)
should be annotated with the <code>#[must_use]</code> attribute. For example, the <code>get</code>
method on slices returns <code>Option</code> and is <a href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#592-595">annotated as
<code>#[must_use]</code></a>.</p>
<h2 id="designing-and-implementing-error-types"><a class="header" href="#designing-and-implementing-error-types">Designing and implementing error types</a></h2>
<p>One challenge to handling errors in Rust compared to C++ is that because error
propagation in Rust is explicit, error values from different subsystems need to
be combined into a single type in order to be propagated further up the stack.
With C++ exceptions, this requires no special effort.</p>
<p>The following example shows how such an error type is implemented manually.
Later examples show how the
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> and
<a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a> crates can be used to reduce the
verbosity of the implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::fmt::Display;
use std::fmt::Formatter;

#[derive(Debug)]
struct ErrorA;

impl Display for ErrorA {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        write!(fmt, "ErrorA produced")
    }
}

impl Error for ErrorA {}

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug)]
struct ErrorB;

impl Display for ErrorB {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        write!(fmt, "ErrorB produced")
    }
}

impl Error for ErrorB {}

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

// This extra structure is needed to combine the errors
#[derive(Debug)]
enum ErrorAOrB {
    ErrorA(ErrorA),
    ErrorB(ErrorB),
}

impl Display for ErrorAOrB {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        match self {
            Self::ErrorA(err) =&gt; err.fmt(fmt),
            Self::ErrorB(err) =&gt; err.fmt(fmt),
        }
    }
}

impl Error for ErrorAOrB {}

impl From&lt;ErrorA&gt; for ErrorAOrB {
    fn from(err: ErrorA) -&gt; Self {
        Self::ErrorA(err)
    }
}

impl From&lt;ErrorB&gt; for ErrorAOrB {
    fn from(err: ErrorB) -&gt; Self {
        Self::ErrorB(err)
    }
}

fn process() -&gt; Result&lt;(), ErrorAOrB&gt; {
    // the ? operator uses the From instance
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The following example uses the
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> crate to implement the
same thing as in the above example. The C++ version shown for comparison is the
same as in the previous example.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}
</code></pre>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Debug, Error)]
#[error("ErrorA was produced")]
struct ErrorA;

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug, Error)]
#[error("ErrorB was produced")]
struct ErrorB;

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

#[derive(Debug, Error)]
enum ErrorAOrB {
    #[error("error from source A")]
    ErrorA(#[from] ErrorA),
    #[error("error from source B")]
    ErrorB(#[from] ErrorB),
}

fn process() -&gt; Result&lt;(), ErrorAOrB&gt; {
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}</code></pre>
</div>
<h2 id="error-types-for-applications"><a class="header" href="#error-types-for-applications">Error types for applications</a></h2>
<p>When implementing an application (as opposed to a library), it is often the case
that the specific type of error isn't as significant as the ability to easily
propagate them without the verbosity of the above example. For those cases, the
<a href="https://crates.io/crates/anyhow">anyhow</a> crate provides mechanisms for
combining errors into a single error type, as well as the ability to produce
one-off errors. Since the errors types used in conjunction with anyhow still
need to implement the <code>std::error::Error</code> trait, anyhow is often used in
conjunction with thiserror.</p>
<p>Discriminating based on the type of the error, as one would do with <code>catch</code> in
C++, can be done with one of the <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast"><code>downcast</code>
methods</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}

int main() {
  try {
    process();
  } catch (ErrorA &amp;err) {
    // handle ErrorA
  } catch (ErrorB &amp;err) {
    // handle ErrorB
  }
}
</code></pre>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Debug, Error)]
#[error("ErrorA was produced")]
struct ErrorA;

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug, Error)]
#[error("ErrorB was produced")]
struct ErrorB;

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

fn process() -&gt; anyhow::Result&lt;()&gt; {
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}

fn main() {
    if let Err(err) = process() {
        if let Some(errA) =
            err.downcast_ref::&lt;ErrorA&gt;()
        {
            // handle ErrorA
        } else if let Some(errB) =
            err.downcast_ref::&lt;ErrorB&gt;()
        {
            // handle ErrorB
        }
    }
}</code></pre>
</div>
<h2 id="backtraces"><a class="header" href="#backtraces">Backtraces</a></h2>
<p>Backtraces can be manually included with errors by defining a field with the
type <a href="https://doc.rust-lang.org/std/backtrace/index.html"><code>Backtrace</code></a>. The
backtrace can be captured using the <a href="https://doc.rust-lang.org/std/backtrace/struct.Backtrace.html#method.capture"><code>Backtrace::capture</code>
method</a>.
The <a href="https://doc.rust-lang.org/std/backtrace/index.html">module documentation</a>
describes the configuration required to enable backtraces.</p>
<p>Both <a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> and
<a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a> have support for conveniently
adding backtrace information to errors. Instructions for including backtraces
are given on the main documentation page for each crate.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;expected_errors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Errors that are expected (such as might arise from handling user input) should\nbe represented with `Result` or `Option`, rather than panics, so that they can\nbe handled.\n\nSince there are multiple kinds of errors that might be produced, `Result` should\nbe used instead of `Option` so that the errors can be distinguished, in order\nto, e.g., provide different error messages for the user.\n&quot;,&quot;id&quot;:&quot;5654c1c0-b526-4248-8684-64e55b26e715&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse thiserror::Error;\n\n#[derive(Clone, Copy, Debug, Error)]\nenum ProcessError {\n    #[error(\&quot;the vector is empty\&quot;)]\n    EmptyVec,\n    #[error(\&quot;the vector is too big\&quot;)]\n    TooBigVec,\n}\n\n/// Returns `Err(EmptyVec)` if the given vector is empty,\n/// or `Err(TooBigVec)` if the given vector is too big.\nfn process(userInput: Vec&lt;i32&gt;) -&gt; Result&lt;(), ProcessError&gt;;\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n/// # Panics\n///\n/// Panics if the given vector is empty or too big.\nfn process(userInput: Vec&lt;i32&gt;);\n```\n&quot;,&quot;```rust\n/// Returns `None` if the given vector is empty or too big.\nfn process(userInput: Vec&lt;i32&gt;) -&gt; Option&lt;int&gt;;\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust signature the most idiomatic to use for a translation of the\nfollowing C++ function?\n\n```cpp\n#include &lt;stdexcept&gt;\n#include &lt;vector&gt;\n\n/**\n * @exception bad_domain If the given vector is\n * empty.\n */\nvoid process(std::vector&lt;int&gt; userInput) {\n  if (userInput.empty()) {\n    throw std::domain_error(\&quot;Non-empty vector required\&quot;);\n  }\n  if (userInput.size() &gt; 100) {\n    throw std::domain_error(\&quot;Vector is too big\&quot;);\n  }\n\n  // process elements of v\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The `?` operator returns early, so that the rest of the function is not\nexecuted.\n\nThe program using `match` call `f` on both `0` and `1`, while the others return\nearly and so do not call `f` on `1`.\n&quot;,&quot;id&quot;:&quot;08e6862a-31a2-4554-bfbf-bdf13cd4d8c0&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    if let Some(x) = f(0)\n        &amp;&amp; let Some(y) = f(1)\n    {\n        return Some((x, y));\n    }\n    None\n}\n```\n&quot;,&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    let Some(x) = f(0) else {\n        return None;\n    };\n    let Some(y) = f(1) else {\n        return None;\n    };\n    Some((x, y))\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    match (f(0), f(1)) {\n        (Some(x), Some(y)) =&gt; Some((x, y)),\n        _ =&gt; None,\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Assume `f` is some function\n\n```rust\nfn f(i32) -&gt; Option&lt;i32&gt; {\n   // ...\n}\n```\n\nWhich programs have equivalent behavior to the following program?\n\n```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    let x = f(0)?;\n    let y = f(1)?;\n    Some((x, y))\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="errors-indicating-bugs"><a class="header" href="#errors-indicating-bugs">Errors indicating bugs</a></h1>
<p>In C++, exceptions are sometimes used to indicate an error that is due to a
programming bug. In many situations no exception is produced, and instead the
invalid use of an API is simply undefined behavior.</p>
<p>In Rust, <code>panic!</code> is used for these kinds of errors, often via an
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a>
or
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a>
method on <code>Result</code> or <code>Option</code> or via <a href="idioms/exceptions/bugs.html#assertions">assertions like <code>assert!</code></a>.
While a panic in Rust may unwind the stack or abort a program, it is never
undefined behavior.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v{1, 2, 3};
  // undefined behavior!
  int x(v[4]);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let v = vec![1,2,3];
    // panics!
    let x = v[4];
}</code></pre></pre>
</div>
<h2 id="converting-result-or-option-to-panic"><a class="header" href="#converting-result-or-option-to-panic">Converting <code>Result</code> or <code>Option</code> to <code>panic!</code></a></h2>
<p>It is easier to convert from a <code>Result</code> or <code>Option</code> to a panic than to go the
other way around. Therefore, many libraries in Rust are written to return
<code>Result</code> or <code>Option</code> and allow the caller to determine whether a <code>None</code> result
indicates a bug by using <code>unwrap</code> or <code>expect</code> to extract the value, panicking if
there isn't one.</p>
<pre><pre class="playground"><code class="language-rust should_panic">/// Returns `None` if the number cannot be divided evenly.
fn divide_exact(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    let quotient = dividend / divisor;
    if quotient * divisor == dividend {
        Some(quotient)
    } else {
        None
    }
}

// Returns `None` if the number cannot be divided by 2
fn divide_by_two_exact(dividend: i32) -&gt; Option&lt;i32&gt; {
    // divide_exact returning None here isn't a bug
    divide_exact(dividend, 2)
}

fn main() {
    let res = divide_exact(10, 3); // Oops, a bug!
    let x = res.unwrap();
    // ...
}</code></pre></pre>
<p>When designing an API, if only one of a <code>Result</code>-based (or <code>Option</code>-based) or
panicking interface is going to be offered, it is generally better to offer the
<code>Result</code>-based interface. That way that the caller can choose to omit the
pre-condition checks and handle the error instead or to panic because
pre-conditions should have been met.</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>In Rust, panics are also generated by assertions. Unlike <code>assert</code> in C++, The
<a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a> family of macros in
Rust cannot be disabled. They are therefore appropriate for asserting invariants
when creating safe wrappers for unsafe code, in addition to checking for logical
invariants.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;cstddef&gt;

template &lt;typename T&gt;
class Widget {
  T *parts;
  std::size_t partCount;

public:
  // ... constructors ...

  /**
   * @pre n must be smaller than partCount
   */
  T getPart(std::size_t n) {
    // Unlike in Rust, this can be disabled,
    // e.g., with -DNDEBUG.
    assert(n &lt; partCount);
    return *(parts + n);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;

pub struct Widget&lt;T&gt; {
    parts: *const T,
    part_count: usize,
}

impl&lt;T: Copy&gt; Widget&lt;T&gt; {
    // ... constructor methods ...

    /// Panics if n is greater than the number of
    /// parts.
    pub fn get_part(&amp;self, n: usize) -&gt; T {
        // SAFETY: Widget maintians invariant of
        // at least part_count parts, so if n is
        // less than the part count then we can
        // use it access a part.
        assert!(
            n &lt; self.part_count,
            "index {} exceeds part count {}",
            n,
            self.part_count
        );
        let idx = isize::try_from(n).expect(
            "can't convert index to offset"
        );
        unsafe { self.parts.offset(idx).read() }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The Rust <a href="https://doc.rust-lang.org/std/macro.debug_assert.html"><code>debug_assert!</code>
macro</a> is more like
<code>assert!</code> in C++, in that it can be turned off by a compilation configuration
option, and so is useful for encoding logical invariants that should be
checked during development and testing, but are too expensive to check
in production.</p>
<h3 id="other-assertion-macros"><a class="header" href="#other-assertion-macros">Other assertion macros</a></h3>
<p>Rust has several other convenience assertion macros. The macros
<a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a> and
<a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a> will print
their arguments on assertion failure using the <code>Debug</code> trait implementation.</p>
<p>The <a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code></a> macro
is for asserting that when matching on an enum certain cases are expected to not
be possible. It is essentially <code>panic!</code> with a fixed error message, but better
communicates intent.</p>
<h3 id="static-assertions"><a class="header" href="#static-assertions">Static assertions</a></h3>
<p>C++ also has <code>static_assert</code>, which is guaranteed to be evaluated at compile
time, other than when used in templates. When used in templates, it is
guaranteed to be evaluated at compile time if the template is instantiated. In
Rust the same thing can achieved by calling <code>assert!</code> in a const block or some
other <a href="https://doc.rust-lang.org/reference/const_eval.html#const-context">constant
context</a>. The
convenience macros <code>assert_eq!</code> and <code>assert_ne!</code> cannot (yet) be used in const
contexts.</p>
<p>The following example fails to compile in both Rust and C++ with the message
from the static assertion.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;

int main() {
  static_assert(false, "static requirement");
}
</code></pre>
<pre><pre class="playground"><code class="language-rust ignore mdbook-runnable">fn main() {
    const {
        assert!(false, "static requirement");
    }
}</code></pre></pre>
</div>
<p>Like with C++ <code>static_assert</code>, a Rust assertion in a const block in a generic
definition is only evaluated when the generic arguments are known. Both the C++
and the Rust versions of the following example only fail to compile if the
<code>first</code> function is called on an array with a size less than 1.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;

template &lt;const std::size_t n&gt;
int &amp;first(std::array&lt;int, n&gt; arr) {
  static_assert(
      n &gt;= 1,
      "array needs to have at last size 1!");
  return arr[0];
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first&lt;const N: usize&gt;(arr: [i32; N]) -&gt; i32 {
    const {
        assert!(
            N &gt;= 1,
            "array needs to have at last size 1!"
        )
    }
    arr[0]
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In C++, <code>static_assert</code> can also be used at namespace scope. To achieve an
equivalent thing in Rust requires defining an unnamed constant.</p>
<div class="comparison">
<pre><code class="language-cpp">static_assert(true,  "top-level assert true");
static_assert(false,  "top-level assert false");

int main() {}
</code></pre>
<pre><pre class="playground"><code class="language-rust ignore mdbook-runnable">const _: () = assert!(true, "top-level assert true");
const _: () = assert!(false, "top-level assert false");

fn main() {}</code></pre></pre>
</div>
<h3 id="assertions-and-the-optimizer"><a class="header" href="#assertions-and-the-optimizer">Assertions and the optimizer</a></h3>
<p>Assertions do affect how the Rust compiler optimizes code (e.g., by enabling the
optimizer to eliminate subsequent redundant checks) but the specific effects are
not guaranteed.</p>
<h2 id="panics-in-embedded-systems"><a class="header" href="#panics-in-embedded-systems">Panics in embedded systems</a></h2>
<p>When programming in Rust for embedded systems using <code>#![no_std]</code>, there is no
default panic handler. Instead one must be specified using the
<code>#[panic_handler]</code> annotation.</p>
<p>The Embedded Rust Book <a href="https://docs.rust-embedded.org/book/start/panicking.html">chapter on handling
panics</a> has more
details on implementing panic handlers for in <code>no_std</code> programs.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;bugs&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Unlike `assert` in C++, the `assert!` macro in Rust cannot be disabled. For\nexpensive-to-check invariants that should be disabled in release builds, use\n`debug_assert!` instead.\n&quot;,&quot;id&quot;:&quot;42c3ea1a-4cf3-4e6c-869b-ae71dd0db493&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It can, because the assertions are guaranteed to be checked.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It cannot because the assertions might be disabled at runtime.\n&quot;],&quot;prompt&quot;:&quot;Can unafe Rust code rely on the `assert! macro to check invariants that, if\nviolated, would lead to undefined behavior?\n&quot;}},{&quot;context&quot;:&quot;Unlike `assert` in C++ which calls `std::abort()` when the assertion is false,\nin Rust, when the condition for an `assert!` is false, `panic!` is called. How\nthe program handles a panic depends on the panic strategy, the panic handler,\nwhether the panic was on the main thread, and whether `catch_unwind` was used.\nIn any case, the program will not resume from where the panic occurred.\n&quot;,&quot;id&quot;:&quot;91c357c8-786c-4f09-b164-3ffa7a68f180&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;False\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;True\n&quot;],&quot;prompt&quot;:&quot;True or false: a failed `assert!` will always halt the program.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="type-equivalents"><a class="header" href="#type-equivalents">Type equivalents</a></h1>
<p>The type equivalents listed in this document are equivalent for the purposes of
programming in Rust as one would program in C++. They are not necessarily
equivalent in terms of being useful for interacting with C or C++ programs via
an FFI. For types that are useful for interoperability with C or C++, see the
<a href="https://doc.rust-lang.org/std/ffi/index.html">Rust <code>std::ffi</code> module
documentation</a> and the <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI
documentation in the Rustonomicon</a>.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer types</a></h3>
<p>In C++, many of the integer types (like <code>int</code> and <code>long</code>) have implementation
defined widths. In Rust, integer types are always specified with their widths,
much like the types in <code>&lt;cstdint&gt;</code> in C++. When it isn't clear what integer type
to use, <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">it is common to default to <code>i32</code>, which is the type that Rust defaults
to for integer
literals</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>uint8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>uint16_t</code></td><td><code>u16</code></td></tr>
<tr><td><code>uint32_t</code></td><td><code>u32</code></td></tr>
<tr><td><code>uint64_t</code></td><td><code>u64</code></td></tr>
<tr><td><code>int8_t</code></td><td><code>i8</code></td></tr>
<tr><td><code>int16_t</code></td><td><code>i16</code></td></tr>
<tr><td><code>int32_t</code></td><td><code>i32</code></td></tr>
<tr><td><code>int64_t</code></td><td><code>i64</code></td></tr>
<tr><td><code>size_t</code></td><td><code>usize</code></td></tr>
<tr><td><code>ptrdiff_t</code></td><td><code>isize</code></td></tr>
</tbody></table>
</div>
<p>In C++ <code>size_t</code> is conventionally used only indexing, sizes, and offsets. The
same is true in Rust for <code>usize</code>, which is the pointer-sized unsigned integer
type. The pointer-sized signed integer type <code>isize</code> follows similar conventions.</p>
<p>Some primitive C++ and POSIX types (such as <code>ssize_t</code> and <code>off_t</code> as return
types) do not map to <code>isize</code> because the failure case is representing using
<code>std::io::Result</code> instead of using a negative number as a <a href="idioms/./null/sentinel_values.html">sentinel
value</a>. Others (such as <code>fpos_t</code> or <code>off_t</code> as
a parameter type) are represented as a plain <code>u64</code> or have a more explicit
representation in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>POSIX <code>ssize_t</code></td><td><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>std::io::Result&lt;u64&gt;</code></a></td></tr>
<tr><td>POSIX <code>off_t</code> (as argument)</td><td><code>u64</code></td></tr>
<tr><td>POSIX <code>off_t</code>(as return value)</td><td><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>std::io::Result&lt;u64&gt;</code></a></td></tr>
<tr><td><code>fpos_t</code></td><td><a href="https://doc.rust-lang.org/std/io/enum.SeekFrom.html"><code>std::io::SeekFrom</code></a></td></tr>
</tbody></table>
</div>
<h3 id="floating-point-types"><a class="header" href="#floating-point-types">Floating point types</a></h3>
<p>As with integer types in C++, the floating point types <code>float</code>, <code>double</code>, and
<code>long double</code> have implementation defined widths. C++23 introduced types
guaranteed to be IEEE 754 floats of specific widths. Of those, <code>float32_t</code> and
<code>float64_t</code> correspond to what is usually expected from <code>float</code> and <code>double</code>.
Rust's floating point types are analogous to these.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>float16_t</code></td><td></td></tr>
<tr><td><code>float32_t</code></td><td><code>f32</code></td></tr>
<tr><td><code>float64_t</code></td><td><code>f64</code></td></tr>
<tr><td><code>float128_t</code></td><td></td></tr>
</tbody></table>
</div>
<p>The Rust types analogous to <code>float16_t</code> and <code>float128_t</code> (<code>f16</code> and <code>f128</code>) are
<a href="https://github.com/rust-lang/rust/issues/116909">not yet available in stable
Rust</a>.</p>
<h3 id="raw-memory-types"><a class="header" href="#raw-memory-types">Raw memory types</a></h3>
<p>In C++ pointers to or arrays of <code>char</code>, <code>unsigned char</code>, or <code>byte</code> are used to
represent raw memory. In Rust, arrays (<code>[u8; N]</code>), vectors (<code>Vec&lt;u8&gt;</code>), or
slices (<code>&amp;[u8]</code>) of <code>u8</code> are used to accomplish the same goal. However,
accessing the underlying memory of another Rust value in that way requires
unsafe Rust. There are <a href="idioms/../etc/libraries.html">libraries</a> for creating safe wrappers
around that kind of access for purposes such as serialization or interacting
with hardware.</p>
<h3 id="character-and-string-types"><a class="header" href="#character-and-string-types">Character and string types</a></h3>
<p>The C++ <code>char</code> or <code>wchar_t</code> types have implementation defined widths. Rust does
not have an equivalent to these types. When working with string encodings in
Rust one would use unsigned integer types where one would use the fixed width
character types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>char8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u16</code></td></tr>
</tbody></table>
</div>
<p>The Rust <code>char</code> type represents a Unicode scalar value. Thus, a Rust <code>char</code> is
the same size as a <code>u32</code>. For working with characters in Rust strings (which are
guaranteed to be valid UTF-8), the <code>char</code> type is appropriate. For representing
a byte, one should instead use <code>u8</code>.</p>
<p>The Rust standard library includes a type for UTF-8 strings and string slices:
<code>String</code> and <code>&amp;str</code>, respectively. Both types guarantee that represented strings
are valid UTF-8. The Rust <code>char</code> type is appropriate for representing elements
of a <code>String</code>.</p>
<p>Because <code>str</code> (without the reference) is a slice, it is unsized and therefore
must be used behind a pointer-like construct, such as a reference or box. For
this reason, string slices are often described as <code>&amp;str</code> instead of <code>str</code> in
documentation, even though they can also be used as <code>Box&lt;str&gt;</code>, <code>Rc&lt;str&gt;</code>, etc.</p>
<p>Rust also includes types for platform-specific string representations and slices
of those strings:
<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a>
and <code>&amp;std::ffi::OsStr</code>. While these strings use the OS-specific representation,
to use one with the Rust FFI, it must still be converted to a
<a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a>.</p>
<p>Unlike C++ which has <code>std::u16string</code>, Rust has no specific representation for
UTF-16 strings. Something like <code>Vec&lt;u16&gt;</code> can be used, but the type will not
guarantee that its contents are a valid UTF-16 string. Rust does provide a
mechanisms for converting <code>String</code> to and from a UTF-16 encoding
(<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.encode_utf16"><code>String::encode_utf16</code></a>
and
<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a>,
among others) as well as similar mechanisms for accessing the underlying UTF-8
encoding
(https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8).</p>
<div class="table-wrapper"><table><thead><tr><th>Purpose</th><th>Rust type</th></tr></thead><tbody>
<tr><td>representing text</td><td><code>String</code> and <code>&amp;str</code></td></tr>
<tr><td>representing bytes</td><td>vectors, arrays, or slices of <code>u8</code></td></tr>
<tr><td>interacting with OS</td><td><code>OsString</code> and <code>&amp;OsStr</code></td></tr>
<tr><td>representing UTF-8</td><td><code>String</code></td></tr>
<tr><td>representing UTF-16</td><td>use <a href="idioms/../etc/libraries.html">a library</a></td></tr>
</tbody></table>
</div>
<h3 id="boolean-types"><a class="header" href="#boolean-types">Boolean types</a></h3>
<p>The <code>bool</code> type in Rust is analogous to the <code>bool</code> type in C++. Unlike C++, Rust
makes <a href="https://doc.rust-lang.org/reference/types/boolean.html">guarantees about the size, alignment, and bit pattern used to represent
values of the <code>bool</code>
type</a>.</p>
<h3 id="void"><a class="header" href="#void"><code>void</code></a></h3>
<p>In C++ <code>void</code> indicates that a function does not return a value. Because Rust is
expression-oriented, all functions return values. In the place of <code>void</code>, Rust
uses the unit type <code>()</code>. When a function does not have a return type declared,
<code>()</code> is the return type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

void process() {
    std::cout
        &lt;&lt; "Does something, but returns nothing."
        &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process() {
    println!("Does something but returns nothing.");
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Since the unit type has only one value (also written <code>()</code>), values of the type
provide no information. This also means that the return value can be left
implicit, as in the above example. The following example makes the unit type
usage explicit.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process() -&gt; () {
    let () = println!("Does something but returns nothing.");
    ()
}
<span class="boring">}</span></code></pre></pre>
<p>The syntax of the unit type and syntax of the unit value resemble that of an
empty tuple. Essentially, that is what the type is. The following example shows
some equivalent types, though without the special syntax or language
integration.</p>
<pre><pre class="playground"><code class="language-rust">struct Pair&lt;T1, T2&gt;(T1, T2); // the same as (T1, T2)
struct Single&lt;T&gt;(T); // a tuple with just one value (T1)
struct Unit; // the same as ()
// can also be written as
// struct Unit();

fn main() {
    let pair = Pair(1,2.0);
    let single = Single(1);
    let unit = Unit;
    // can also be written as
    // let unit = Unit();
}</code></pre></pre>
<p>Using a unit type instead of <code>void</code> enables expressions with unit type (such as
function calls that would return <code>void</code> in C++) to be used in contexts that
expect a value. This is especially helpful with defining and using generic
functions, instead of needing something like <code>std::is_void</code> to special-case the
handling when a type is <code>void</code>.</p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<p>The following table maps the ownership-managing classes from C++ to equivalents
types in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Use</th><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>Owned</td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td>Single owner, dynamic storage</td><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>Box&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::sync::Arc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><code>std::rc::Rc&lt;std::cell::RefCell&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code> with a <code>std::mutex</code></td><td><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html"><code>std::sync::Arc&lt;std::mutex::Mutex&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Const reference</td><td><code>const &amp;T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable reference</td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr>
<tr><td>Const observer pointer</td><td><code>const *T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable observer pointer</td><td><code>*T</code></td><td><code>&amp;mut T</code></td></tr>
</tbody></table>
</div>
<p>In C++, the thread safety of <code>std::shared_ptr</code> is more nuanced than it appears
in this table (e.g., some uses may require <code>std::atomic</code>). However, in safe Rust
the compiler will prevent the incorrect use of the shared owner types.</p>
<p>Unlike with C++ references, Rust can have references-to-references. Rust
references are more like observer pointers than they are like C++ references.</p>
<h3 id="void-1"><a class="header" href="#void-1"><code>void*</code></a></h3>
<p>Rust does not have anything directly analogous to <code>void*</code> in C++. The upcoming chapter
on <code>RTTI</code><!--LINKME--> will cover some use cases where the goal is dynamic
typing. The <a href="https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs">FFI chapter of the
Rustonomicon</a>
covers some use cases where the goal is interoperability with C programs that
use <code>void*</code>.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>Both C++ and Rust containers own their elements. However, in both the element
type may be a non-owning type, such as a pointer in C++ or a reference in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>std::vector&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::array&lt;T, N&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.array.html"><code>[T; N]</code></a></td></tr>
<tr><td><code>std::list&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>std::collections::LinkedList&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::deque&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::stack&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>std::collections::BTreeMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::unordered_map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>std::collections::HashMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>std::collections::BTreeSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::unordered_set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>std::collections::HashSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::priority_queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html"><code>std::collections::BinaryHeap&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::span&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>&amp;[T]</code></a></td></tr>
</tbody></table>
</div>
<p>For maps and sets instead of the container being parameterized over the hash or
comparison function used, the types require that the key types implement the
<code>std::hash::Hash</code> (unordered) or <code>std::cmp::Ord</code> (ordered) traits. To use the containers
with different hash or comparison functions, one must use a wrapper type with a
different implementation of the required trait.</p>
<p>Some C++ container types provided by the STL have no equivalent in Rust. Many of
those have equivalents available in third-party <a href="idioms/../etc/libraries.html">libraries</a>.</p>
<p>One significant different in the use of these types between C++ in Rust is with
the <code>Vec&lt;T&gt;</code> and array <code>[T; N]</code> types, from which slice references <code>&amp;[T]</code> or
<code>&amp;mut [T]</code> to part or all of the data can be cheaply created. For this reason,
when defining a function that does not modify the length of a vector and does
not need to statically know the number of elements in an array, it is more
idiomatic to take a parameter as <code>&amp;[T]</code> or <code>&amp;mut [T]</code> than as a reference to the
owned type.</p>
<p>In C++ it is better to take begin and end iterators or a range than a <code>span</code>
when possible, since iterators are more general. The same is true with Rust and
taking a generic type that implements <code>IntoIter&lt;&amp;T&gt;</code> or <code>IntoIter&lt;&amp;mut T&gt;</code>
instead of <code>&amp;[T]</code>.</p>
<div class="comparison">
<pre><code class="language-c++">#include &lt;iterator&gt;
#include &lt;vector&gt;

template &lt;typename InputIter&gt;
void go(InputIter first, InputIter last) {
  for (auto it = first; it != last; ++it) {
    // ...
  }
}

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3};
  go(v.begin(), v.end());
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::iter::IntoIterator;

fn go&lt;'a&gt;(iter: impl IntoIterator&lt;Item = &amp;'a mut i32&gt;) {
    for x in iter {
        // ...
    }
}

fn main() {
    let mut v = vec![1, 2, 3];
    go(&amp;mut v);
}</code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;type_equivalents&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4fb18334-8405-438d-8d3e-859a8823bccf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It is guaranteed in safe Rust to represent a valid Unicode scalar value.\n&quot;,&quot;It is 32 bits wide.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It is equivalent to the C++ `wchar` type.\n&quot;,&quot;It is equivalent to the C++ `char` type.\n&quot;,&quot;It is equivalent to the C++ `char8_t` type.\n&quot;,&quot;It is equivalent to the C++ `int32_t` type.\n&quot;,&quot;It is 8 bits wide.\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about the Rust `char` type.\n&quot;}},{&quot;id&quot;:&quot;5586766c-b5ce-4bea-b995-da0b3c548b0d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It provides thread-safe read access to a value of type `T`.\n&quot;,&quot;It represents shared ownership of a value of type `T`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It provides thread-safe write access to a value of type `T`.\n&quot;,&quot;It can be empty (i.e., not own some value of type `T`).\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about `std::sync::Arc&lt;T&gt;`.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="type-promotions-and-conversions"><a class="header" href="#type-promotions-and-conversions">Type promotions and conversions</a></h1>
<h2 id="lvalue-to-rvalue"><a class="header" href="#lvalue-to-rvalue">lvalue to rvalue</a></h2>
<p>In C++ lvalues are automatically converted to rvalues when needed.</p>
<p>In Rust the equivalent of lvalues are "place expressions" (expressions that
represent memory locations) and the equivalent of rvalues are "value
expressions". Place expressions are automatically converted to value expressions
when needed.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  // Local variables are lvalues,
  int x(0);
  // and therefore may be assigned to.
  x = 42;

  // x is converted to an rvalue when needed.
  int y = x + 1;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Local variables are place expressions,
    let mut x = 0;
    // and therefore may be assigned to.
    x = 42;

    // x is converted to a value expression when
    // needed.
    let y = x + 1;
}</code></pre></pre>
</div>
<h2 id="array-to-pointer"><a class="header" href="#array-to-pointer">Array to pointer</a></h2>
<p>In C++, arrays are automatically converted to pointers as required.</p>
<p>The equivalent to this in Rust is the automatic conversion of vector and array
references to slice references.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstring&gt;

int main() {
  char example[6] = "hello";
  char other[6];

  // strncpy takes arguments of type char*
  strncpy(other, example, 6);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn third(ts: &amp;[char]) -&gt; Option&lt;&amp;char&gt; {
    ts.get(2)
}

fn main() {
    let vec: Vec&lt;char&gt; = vec!['a', 'b', 'c'];
    let arr: [char; 3] = ['a', 'b', 'c'];

    third(&amp;vec);
    third(&amp;arr);
}</code></pre></pre>
</div>
<p>Because slice references can be easily used in a memory-safe way, it is
generally recommended in Rust to define functions in terms of slice references
instead of in terms of references to vectors or arrays, unless vector-specific
or array-specific functionality is needed.</p>
<p>Unlike in C++ where the conversion from arrays to pointers is built into the
language, this is actually a general mechanism provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a>, which provides one
kind of <a href="idioms/./user-defined_conversions.html">user-defined conversion</a>.</p>
<h2 id="function-to-pointer"><a class="header" href="#function-to-pointer">Function to pointer</a></h2>
<p>In C++ functions and static member functions are automatically converted to
function pointers.</p>
<p>Rust performs the same conversion. In addition to functions and members that do
not take <code>self</code> as an argument, constructors (proper constructors) also have
function type and can be converted to function pointers. Non-capturing closures
do not have function type, but can also be converted to function pointers.</p>
<div class="comparison">
<pre><code class="language-cpp">int twice(int n) {
  return n * n;
}

struct MyPair {
  int x;
  int y;

  MyPair(int x, int y) : x(x), y(y) {}

  static MyPair make() {
    return MyPair{0, 0};
  }
};

int main() {
  // convert a function to a function pointer
  int (*twicePtr)(int) = twice;
  int result = twicePtr(5);

  // Per C++23 11.4.5.1.6, can't take the address
  // of a constructor.
  // MyPair (*ctor)(int, int) = MyPair::MyPair;
  // MyPair pair = ctor(10, 20);

  // convert a static method to a function
  // pointer
  MyPair (*methodPtr)() = MyPair::make;
  MyPair pair2 = methodPtr();

  // convert a non-capturing closure to a
  // function pointer
  int (*closure)(int) = [](int x) -&gt; int {
    return x * 5;
  };
  int closureRes = closure(2);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn twice(x: i32) -&gt; i32 {
    x * x
}

struct MyPair(i32, i32);

impl MyPair {
    fn new() -&gt; MyPair {
        MyPair(0, 0)
    }
}

fn main() {
    // convert a function to a function pointer
    let twicePtr: fn(i32) -&gt; i32 = twice;
    let res = twicePtr(5);

    // convert a constructor to a function pointer
    let ctorPtr: fn(i32, i32) -&gt; MyPair = MyPair;
    let pair = ctorPtr(10, 20);

    // convert a static method to a function
    // pointer
    let methodPtr: fn() -&gt; MyPair = MyPair::new;
    let pair2 = methodPtr();

    // convert a non-capturing closure to a
    // function pointer
    let closure: fn(i32) -&gt; i32 = |x: i32| x * 5;
    let closureRes = closure(2);
}</code></pre></pre>
</div>
<h2 id="numeric-promotion-and-numeric-conversion"><a class="header" href="#numeric-promotion-and-numeric-conversion">Numeric promotion and numeric conversion</a></h2>
<p>In C++ there are several kinds of implicit conversions that occur between
numeric types. The most commonly encountered are numeric promotions, which
convert numeric types to larger types.</p>
<p>These lossless conversions are not implicit in Rust. Instead, they must be
performed explicitly using the <code>Into::into()</code> method. These conversions are
provided by implementations of the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits. The list
of conversions provided by the Rust standard library is <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors">listed on the
documentation
page</a> for
the trait.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  int x(42);
  long y = x;

  float a(1.0);
  double b = a;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let y: i64 = x.into();

    let a: f32 = 1.0;
    let b: f64 = a.into();
}</code></pre></pre>
</div>
<p>There are several implicit conversions that occur in C++ that are not lossless.
For example, integers can be implicitly converted to unsigned integers in C++.</p>
<p>In Rust, these conversions are also required to be explicit and are provided by
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> traits
which require handling the cases where the value does not map to the other type.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  int x(42);
  unsigned int y(x);

  float a(1.0);
  double b(a);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;

fn main() {
    let x: i32 = 42;
    let y: u32 = match x.try_into() {
        Ok(x) =&gt; x,
        Err(err) =&gt; {
            panic!("Can't convert! {:?}", err);
        }
    };
}</code></pre></pre>
</div>
<p>Some conversions that occur in C++ are supported by neither <code>From</code> nor <code>TryFrom</code>
because there is not a clear choice of conversion or because they are not
value-preserving. For example, in C++ <code>int32_t</code> can implicitly be converted to
<code>float</code> despite <code>float</code> not being able to represent all 32 bit integers
precisely, but in Rust there is no <code>TryFrom&lt;i32&gt;</code> implementation for <code>f32</code>.</p>
<p>In Rust the only way to convert from an <code>i32</code> to an <code>f32</code> is with the <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#r-expr.as.coercions"><code>as</code>
operator</a>.
The operator can actually be used to convert between other primitive types as
well and does not panic or produce undefined behavior, but may not convert in
the desired way (e.g., it may use a different rounding mode than desired or it
may truncate rather than saturate as desired).</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  int32_t x(42);
  float a = x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let a: f32 = x as f32;
}</code></pre></pre>
</div>
<h3 id="isize-and-usize"><a class="header" href="#isize-and-usize"><code>isize</code> and <code>usize</code></a></h3>
<p>In the Rust standard library the <code>isize</code> and <code>usize</code> types are used for values
intended to used be indices (much like <code>size_t</code> in C++). However, their use for
other purposes is usually discouraged in favor of using explicitly sized types
such as <code>u32</code>. This results a situation where values of type <code>u32</code> have to be
converted to <code>usize</code> for use in indexing, but <code>Into&lt;usize&gt;</code> is not implemented
for <code>u32</code>.</p>
<p>In these cases, best practice is to use <code>TryInto</code>, and if further error handling
of the failure cause is not desired, to call <code>unwrap</code>, creating a panic at the
point of conversion.</p>
<p>This is preferred because it prevents the possibility of moving forward with an
incorrect value. E.g., consider converting a <code>u64</code> to a <code>usize</code> that has a
32-bit representation with <code>as</code>, which truncates the result. A value that is one
greater than the <code>u32::MAX</code> will truncate to <code>0</code>, which would probably result in
successfully retrieving the wrong value from a data structure, thus masking a
bug and producing unexpected behavior.</p>
<h3 id="enums-2"><a class="header" href="#enums-2">Enums</a></h3>
<p>In C++ enums can be implicitly converted to integer types.</p>
<p>In Rust the conversion requires the use of the <code>as</code> operator, and providing
<code>From</code> and <code>TryFrom</code> implementations to move back and forth between the enum and
its representation type is recommended. Examples and additional details are
given in the <a href="idioms/./data_modeling/enums.html">chapter on enums</a>.</p>
<h2 id="qualification-conversion"><a class="header" href="#qualification-conversion">Qualification conversion</a></h2>
<p>In C++ qualification conversions enable the use of const (or volatile) values
where the const (or volatile) qualifier is not expected.</p>
<p>In Rust the equivalent enables the use of <code>mut</code> variables and <code>mut</code> references
to be used where non-<code>mut</code> variables or references are expected.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

void display(const std::string &amp;msg) {
  std::cout &lt;&lt; "Displaying: " &lt;&lt; msg &lt;&lt; std::endl;
}

int main() {
  // no const qualifier
  std::string message("hello world");

  // used where const expected
  display(message);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn display(msg: &amp;str) {
    println!("{}", msg);
}

fn main() {
    let mut s: String = "hello world".to_string();
    let message: &amp;mut str = s.as_mut();
    display(message);
}</code></pre></pre>
</div>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer literals</a></h2>
<p>In C++ integer literals with no suffix indicating type have the smallest type in
which they can fit from <code>int</code>, <code>long int</code>, or <code>long long int</code>. When the literal
is then assigned to a variable of a different type, an implicit conversion is
performed.</p>
<p>In Rust, integer literals have their type inferred depending on context. When
there is insufficient information to infer a type either <code>i32</code> is assumed or may
require some type annotation to be given.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  // Compiles without error (but with a warning).
  uint32_t x = 4294967296;

  // assumes int
  auto y = 1;

  // literal is given a larger type, so it prints
  // correctly
  std::cout &lt;&lt; 4294967296 &lt;&lt; std::endl;

  // these work as expected
  std::cout &lt;&lt; INT64_C(4294967296) &lt;&lt; std::endl;

  uint64_t z = INT64_C(4294967296);
  std::cout &lt;&lt; z &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // error: literal out of range for `u32`
    // let x: u32 = 4294967296;

    // assumes i32
    let y = 1;

    // fails to compile because it is inferred as i32
    // print!("{}", 4294967296);

    // These work, though.
    println!("{}", 4294967296u64);

    let z: u64 = 4294967296;
    println!("{}", z);
}</code></pre></pre>
</div>
<h2 id="safe-bools"><a class="header" href="#safe-bools">Safe bools</a></h2>
<p>The safe bool idiom exists to make it possible to use types as conditions. Since
C++11 this idiom is straightforward to implement.</p>
<p>In Rust instead of converting the value to a boolean, the normal idiom matches
on the value instead. Depending on the situation, the mechanism used for
matching might be <code>match</code>, <code>if let</code>, or <code>let else</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Wire {
  bool ready;
  unsigned int value;

  explicit operator bool() const { return ready; }
};

int main() {
  Wire w{false, 0};
  // ...

  if (w) {
    // use w.value
  } else {
    // do something else
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">enum Wire {
    Ready(u32),
    NotReady,
}

fn main() {
    let wire = Wire::NotReady;
    // ...

    // match
    match wire {
        Wire::Ready(v) =&gt; {
            // use value v
        }
        Wire::NotReady =&gt; {
            // do something else
        }
    }

    // if let
    if let Wire::Ready(v) = wire {
        // use value v
    }

    // let else
    let Wire::Ready(v) = wire else {
        // do something that doesn't continue,
        // like early return
        return;
    };
}</code></pre></pre>
</div>
<h2 id="user-defined-conversions"><a class="header" href="#user-defined-conversions">User-defined conversions</a></h2>
<p>User-defined conversions are covered in a <a href="idioms/./user-defined_conversions.html">separate
chapter</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;promotions_and_conversions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;98badbec-d894-490a-929b-327021cda0c3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::convert::TryInto;\n\nfn main() {\n    let x = 4294967296i64;\n\n    match TryInto::&lt;i32&gt;::try_into(x) {\n        Ok(y) =&gt; {\n            // ...\n        }\n        Err(err) =&gt; {\n            // ...\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn main() {\n    let x = 4294967296i64;\n    if Into::&lt;i64&gt;::into(i32::MIN) &lt; x\n        &amp;&amp; x &lt; Into::&lt;i64&gt;::into(i32::MAX)\n    {\n        let y = x as i32;\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n&quot;,&quot;```rust\nfn main() {\n    let x = 4294967296i64;\n    let y = x as i32;\n    if y as i64 == x {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n\nint main() {\n  int64_t x(4294967296);\n\n  if (std::numeric_limits&lt;int32_t&gt;::min() &lt; x &amp;&amp;\n      x &lt; std::numeric_limits&lt;int32_t&gt;::max()) {\n    int32_t y(x);\n    // ...\n  } else {\n    // ...\n  }\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-conversions-1"><a class="header" href="#user-defined-conversions-1">User-defined conversions</a></h1>
<p>In C++ user-defined conversions are created using <a href="https://en.cppreference.com/w/cpp/language/converting_constructor">converting
constructors</a>
or <a href="https://en.cppreference.com/w/cpp/language/cast_operator">conversion
functions</a>. Because
converting constructors are opt-out (via the <code>explicit</code> specifier), implicit
conversions occur with regularity in C++ code. In the following example both the
assignments and the function calls make use of implicit conversions as provided
by a converting constructor.</p>
<p>Rust makes significantly less use of implicit conversions. Instead most
conversions are explicit. The
<a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code></a> module
provides several traits for working with user-defined conversions. In Rust, the
below example makes use of explicit conversions by implementing the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code>
trait</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Widget {
  Widget(int) {}
  Widget(int, int) {}
};

void process(Widget w) {}

int main() {
  Widget w1 = 1;
  Widget w2 = {4, 5};
  process(1);
  process({4, 5});

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(_x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;(i32, i32)&gt; for Widget {
    fn from(_x: (i32, i32)) -&gt; Widget {
        Widget
    }
}

fn process(w: Widget) {}

fn main() {
    let w1: Widget = 1.into();
    // For construction this is more idiomatic:
    let w1b = Widget::from(1);

    let w2: Widget = (4, 5).into();
    // For construction this is more idiomatic:
    let w2b = Widget::from((4, 5));

    process(1.into());
    process((4, 5).into());
}</code></pre></pre>
</div>
<p>The <code>into</code> method used above is provided via a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">blanket
implementations</a>
for the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into trait</code></a>
for types that implement the <code>From</code> trait. Because of the existence of the
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html#impl-Into%3CU%3E-for-T">blanket
implementation</a>,
it is generally preferred to implement the <code>From</code> trait instead of the <code>Into</code>
trait, and let the <code>Into</code> trait be provided by that blanket implementation.</p>
<h2 id="conversion-functions"><a class="header" href="#conversion-functions">Conversion functions</a></h2>
<p>C++ conversion functions enable conversions in the other direction, from the
defined class to another type.</p>
<p>To achieve the same in Rust, the <code>From</code> trait can be implemented in the other
direction. At least one of the source type or the target type must be defined in
the same crate as the trait implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;utility&gt;

struct Point {
  int x;
  int y;

  operator std::pair&lt;int, int&gt;() const {
    return std::pair(x, y);
  }
};

void process(std::pair&lt;int, int&gt;) {}

int main() {
  Point p1{1, 2};
  Point p2{3, 4};

  std::pair&lt;int, int&gt; xy = p1;
  process(p2);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(p: Point) -&gt; (i32, i32) {
        (p.x, p.y)
    }
}

fn process(x: (i32, i32)) {}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };

    let xy: (i32, i32) = p1.into();
    process(p2.into());
}</code></pre></pre>
</div>
<p>Conversion functions are is often used to implement the safe bool pattern in
C++, <a href="idioms/./promotions_and_conversions.html#safe-bools">which is addressed in a different way in
Rust</a>.</p>
<h2 id="borrowing-conversions"><a class="header" href="#borrowing-conversions">Borrowing conversions</a></h2>
<p>The methods in the <code>From</code> and <code>Into</code> traits take ownership of the values to be
converted. When this is not desired in C++, the conversion function can just
take and return references.</p>
<p>To achieve the same in Rust the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code>
trait</a> or <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code>
trait</a> are used.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

struct Person {
  std::string name;

  operator std::string &amp;() {
    return this-&gt;name;
  }
};

void process(const std::string &amp;name) {
  std::cout &lt;&lt; name &lt;&lt; std::endl;
}

int main() {
  Person alice{"Alice"};

  process(alice);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Person {
    name: String,
}

impl AsRef&lt;str&gt; for Person {
    fn as_ref(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}

fn process(name: &amp;str) {
    println!("{}", name);
}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice.as_ref());
}</code></pre></pre>
</div>
<p>It is common to use <code>AsRef</code> or <code>AsMut</code> as a trait bound in function definitions.
Using generics with an <code>AsRef</code> or <code>AsMut</code> bound allows clients to call the
functions with anything that can be cheaply viewed as the type that the function
wants to work with. Using this technique, the above definition of <code>process</code>
would be defined as in the following example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsRef&lt;str&gt; for Person {
</span><span class="boring">    fn as_ref(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn process&lt;T: AsRef&lt;str&gt;&gt;(name: T) {
    println!("{}", name.as_ref());
}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice);
}</code></pre></pre>
<p>This technique is often used with functions that take file system paths, so that
literal strings can more easily be used as paths.</p>
<h2 id="fallible-conversions"><a class="header" href="#fallible-conversions">Fallible conversions</a></h2>
<p>In C++ when conversions might fail it is possible (though usually discouraged)
to throw an exception from the converting constructor or converting function.</p>
<p>Error handling in Rust <a href="idioms/./exceptions.html">does not use exceptions</a>. Instead
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code> trait</a>
and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code> trait</a>
are used for fallible conversions. These traits differ from <code>From</code> and <code>Into</code> in
that they return a <code>Result</code>, which may indicate a failing case. When a
conversion may fail one should implement <code>TryFrom</code> and rely on the client to
call <code>unwrap</code> on the result, rather than panic in a <code>From</code> implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;string&gt;

class NonEmpty {
  std::string s;

public:
  NonEmpty(std::string s) : s(s) {
    if (this-&gt;s.empty()) {
      throw std::domain_error("empty string");
    }
  }
};

int main() {
  std::string s("");
  NonEmpty x = s; // throws

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::convert::TryInto;

struct NonEmpty {
    s: String,
}

#[derive(Clone, Copy, Debug)]
struct NonEmptyStringError;

impl TryFrom&lt;String&gt; for NonEmpty {
    type Error = NonEmptyStringError;

    fn try_from(
        s: String,
    ) -&gt; Result&lt;NonEmpty, NonEmptyStringError&gt;
    {
        if s.is_empty() {
            Err(NonEmptyStringError)
        } else {
            Ok(NonEmpty { s })
        }
    }
}

fn main() {
    let res: Result&lt;
        NonEmpty,
        NonEmptyStringError,
    &gt; = "".to_string().try_into();
    match res {
        Ok(ne) =&gt; {
            println!("Converted!");
        }
        Err(err) =&gt; {
            println!("Couldn't convert");
        }
    }
}</code></pre></pre>
</div>
<p>Just like with <code>From</code> and <code>Into</code>, there is a <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#impl-TryInto%3CU%3E-for-T">blanket
implementation</a>
for <code>TryInto</code> for everything that implements <code>TryFrom</code>.</p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Rust does have one kind of user-defined implicit conversion, called <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion">deref
coercions</a>,
provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a> and
<a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code>trait</a>. These
coercions exist for making pointer-like types more ergonomic to use.</p>
<p>An <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">example</a> of implementing
the traits for a custom pointer-like type is given in the Rust book.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>A summary of when to use which kind of conversion interface is given in the
documentation for the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code>
module</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;user-defined_conversions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;There is a blanket implementation for `TryInto` for every type that implements\n`TryFrom`, so it is better to implement `TryFrom` and rely on the blanket\nimplementation for `TryInto`.\n&quot;,&quot;id&quot;:&quot;d6790d33-5130-47ba-ba96-c6718978131f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::convert::TryFrom;\n\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct IsNaN;\n\nimpl TryFrom&lt;f64&gt; for NotNaN {\n    type Error = IsNaN;\n    fn try_from(\n        x: f64,\n    ) -&gt; Result&lt;Self, Self::Error&gt; {\n        if x.is_nan() {\n            Err(IsNaN)\n        } else {\n            Ok(Self { value: x })\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\nimpl From&lt;f64&gt; for NotNaN {\n    fn from(x: f64) -&gt; Self {\n        if x.is_nan() {\n            panic!(\&quot;Is NaN!\&quot;);\n        }\n        Self { value: x }\n    }\n}\n```\n&quot;,&quot;```rust\nuse std::convert::TryInto;\n\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct IsNaN;\n\nimpl TryInto&lt;NotNaN&gt; for f64 {\n    type Error = IsNaN;\n\n    fn try_into(\n        self,\n    ) -&gt; Result&lt;NotNaN, Self::Error&gt; {\n        if self.is_nan() {\n            Err(IsNaN)\n        } else {\n            Ok(NotNaN { value: self })\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n\nclass NotNaN {\n  double value;\n\npublic:\n  NotNaN(double x) : value(x) {\n    if (std::isnan(value)) {\n      throw std::domain_error(\&quot;NaN\&quot;);\n    }\n  }\n\n  double getValue() {\n    return value;\n  }\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>C++ supports overloading of functions, so long as the invocations of the
functions can be distinguished by the number or types of their arguments.</p>
<p>Rust does not support this kind of function overloading. Instead, Rust has a few
different mechanisms (some of which C++ also has) for achieving the effects of
overloading in a way that interacts better with type inference. The mechanisms
usually involve making the commonalities between the overloaded functions
apparent in the code.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

double twice(double x) {
  return x + x;
}

int twice(int x) {
  return x + x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice(x: f64) -&gt; f64 {
    x + x
}

// error[E0428]: the name `twice` is defined multiple times
// fn twice(x: i32) -&gt; i32 {
//     x + x
// }
<span class="boring">}</span></code></pre></pre>
</div>
<p>In practice, an example like the above would also likely be implemented in a
more structured way even in C++, using templates.</p>
<p>When phrased this way, the example can be translated to Rust, with the notable
addition of <a href="idioms/./data_modeling/concepts.html">requiring a trait bound on the
type</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;typename T&gt;
T twice(T x) {
  return x + x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice&lt;T&gt;(x: T) -&gt; T::Output
where
    T: std::ops::Add&lt;T&gt;,
    T: Copy,
{
    x + x
}
<span class="boring">}</span></code></pre></pre>
</div>
<h2 id="overloaded-methods"><a class="header" href="#overloaded-methods">Overloaded methods</a></h2>
<p>In C++ it is possible to have methods with the same name but different
signatures on the same type. In Rust there can be at most one method with the
same name for each trait implementation and at most one inherent method with the
same name for a type.</p>
<p>In cases where there are multiple methods with the same names because the method
is defined for multiple traits, the desired method must be distinguished at the
call site by specifying the trait.</p>
<pre><pre class="playground"><code class="language-rust">trait TraitA {
    fn go(&amp;self) -&gt; String;
}

trait TraitB {
    fn go(&amp;self) -&gt; String;
}

struct MyStruct;

impl MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called inherent method".to_string()
    }
}

impl TraitA for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait A method".to_string()
    }
}

impl TraitB for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait B method".to_string()
    }
}

fn main() {
    let my_struct = MyStruct;

    // Calling the inherent method
    println!("{}", my_struct.go());

    // Calling the method from TraitA
    println!("{}", TraitA::go(&amp;my_struct));

    // Calling the method from TraitB
    println!("{}", TraitB::go(&amp;my_struct));
}</code></pre></pre>
<p>One exception to this is when the methods are all from the same generic trait
with with different type parameters for the implementations. In that case, if
the signature is sufficient to determine which implementation to use, the trait
does not need to be specified to resolve the method. This is common when using
the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code> trait</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;f32&gt; for Widget {
    fn from(x: f32) -&gt; Widget {
        Widget
    }
}

fn main() {
    // Calls &lt;Widget as From&lt;i32&gt;&gt;::from
    let w1 = Widget::from(5);
    // Calls &lt;Widget as From&lt;f32&gt;&gt;::from
    let w2 = Widget::from(1.0);
}</code></pre></pre>
<h2 id="overloaded-operators"><a class="header" href="#overloaded-operators">Overloaded operators</a></h2>
<p>In C++ most operators can either be overloaded either with a free-standing
function or by providing a method defining the operator on a class.</p>
<p>Rust provides operator via implementation of specific traits. Implementing a
method of the same name as required by the trait will not make a type usable
with the operator if the trait is not implemented.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Vec2 {
  double x;
  double y;

  Vec2 operator+(const Vec2 &amp;other) const {
    return Vec2{x + other.x, y + other.y};
  }
};

int main() {
  Vec2 a{1.0, 2.0};
  Vec2 b{3.0, 4.0};
  Vec2 c = a + b;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add for &amp;Vec2 {
    type Output = Vec2;

    // Note that the type of self here is &amp;Vec2.
    fn add(self, other: Self) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = &amp;a + &amp;b;
}</code></pre></pre>
</div>
<p>Additionally, sometimes it is best to provide trait implementations for various
combinations of reference types, especially for types that implement the <a href="idioms/./constructors/copy_and_move_constructors.html"><code>Copy trait</code></a>, since they are
likely to want to be used either with or without taking a reference. For the
example above, that involve defining four implementations.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add&lt;&amp;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// If Vec2 weren't so small, it might be desireable to re-use space in the below
// implementations, since they take ownership.

impl std::ops::Add&lt;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;&amp;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<p>The repetition can be addressed by defining a macro.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

macro_rules! impl_add_vec2 {
    ($lhs:ty, $rhs:ty) =&gt; {
        impl std::ops::Add&lt;$rhs&gt; for $lhs {
            type Output = Vec2;

            fn add(self, other: $rhs) -&gt; Vec2 {
                Vec2 {
                    x: self.x + other.x,
                    y: self.y + other.y,
                }
            }
        }
    };
}

impl_add_vec2!(&amp;Vec2, &amp;Vec2);
impl_add_vec2!(&amp;Vec2, Vec2);
impl_add_vec2!(Vec2, &amp;Vec2);
impl_add_vec2!(Vec2, Vec2);

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h2>
<p>Default arguments in C++ are sometimes implemented in terms of function
overloading.</p>
<p>Rust does not have default arguments. Instead, arguments with <code>Option</code> type can
be used to provide a similar effect.</p>
<div class="comparison">
<pre><code class="language-cpp">unsigned int shift(unsigned int x,
                   unsigned int shiftAmount) {
  return x &lt;&lt; shiftAmount;
}

unsigned int shift(unsigned int x) {
  return shift(x, 2);
}

int main() {
  unsigned int a = shift(7); // shifts by 2
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::ops::Shl;

fn shift(
    x: u32,
    shift_amount: Option&lt;u32&gt;,
) -&gt; u32 {
    let a = shift_amount.unwrap_or(2);
    x.shl(a)
}

fn main() {
    let res = shift(7, None); // shifts by 2
}</code></pre></pre>
</div>
<h2 id="unrelated-overloads"><a class="header" href="#unrelated-overloads">Unrelated overloads</a></h2>
<p>The lack of completely ad hoc overloading in Rust encourages the definition of
traits that capture essential commonalities between types, so that functions can
be implemented in terms of those interfaces and used generally. However, it also
sometime encourages the anti-pattern of defining of traits that only capture
incidental commonalities (such as having methods of the same name).</p>
<p>It is better programming practice in those cases to simply define separate
functions, rather than to shoehorn in a trait where no real commonality exists.</p>
<p>This is commonly seen in Rust in the naming conventions for constructor static
methods. Instead of them all being named <code>new</code> with different arguments, they
are <a href="https://rust-lang.github.io/api-guidelines/naming.html">usually given names of the form
<code>from_something</code></a>, where
the <code>something</code> varies based on from what the value is being constructed, or a
more specific name if appropriate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

impl Vec3 {
    fn from_x(x: f64) -&gt; Vec3 {
        Vec3 { x, y: 0.0, z: 0.0 }
    }

    fn from_y(y: f64) -&gt; Vec3 {
        Vec3 { x: 0.0, y, z: 0.0 }
    }

    fn diagonal(d: f64) -&gt; Vec3 {
        Vec3 { x: d, y: d, z: d }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This differs from the conversion methods supported by the <code>From</code> and <code>Into</code>
traits, which have the additional purpose of supporting trait bounds on generic
functions which should take any type convertible to a specific type.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;overloading&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;8cebf373-6026-43ed-9364-9fda8ca7fdcd&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It compiles.&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because `Pigeon` cannot have both an inherent method called\n`height` and implement a trait with a method called `height`.\n&quot;,&quot;It does not compile because `Pigeon` cannot implement two traits that both have\na method called `height`.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\ntrait Jump {\n    // Height above ground in meters\n    fn height(&amp;self) -&gt; f64;\n}\n\ntrait Fly {\n    // Height above ground in meters\n    fn height(&amp;self) -&gt; f64;\n}\n\nstruct Pigeon {}\n\nimpl Pigeon {\n    // Head to tail in meters\n    fn height(&amp;self) -&gt; f64 {\n        0.3\n    }\n}\n\nimpl Jump for Pigeon {\n    fn height(&amp;self) -&gt; f64 {\n        0.0\n    }\n}\n\nimpl Fly for Pigeon {\n    fn height(&amp;self) -&gt; f64 {\n        5.0\n    }\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="rtti-and-dynamic_cast"><a class="header" href="#rtti-and-dynamic_cast">RTTI and <code>dynamic_cast</code></a></h1>
<p>Rust does not have built-in support for generalized RTTI, nor does Rust have a direct analog to
<code>dynamic_cast</code>.</p>
<p>The only language primitive provided by Rust in this vein is <a href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a>,
which is a globally unique identifier for a type. Rust's standard library builds on <code>TypeId</code> to provide an <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code>
trait</a> that supports similar
uses to <code>std::any</code> in C++. However, <code>Any</code> does not enable testing for
implementation of, or converting to, another trait. It only enables testing for
and converting to a specific type.</p>
<p>Every type with a <code>'static</code> lifetime bound (i.e., that does not contain
references with a non-static lifetime) implements <code>Any</code> via a blanket implementation in
the standard library.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;any&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void print_if_string(const std::any &amp;x) {
  try {
    const std::string &amp;s =
        any_cast&lt;std::string const &amp;&gt;(x);
    std::cout &lt;&lt; s &lt;&lt; std::endl;
  } catch (std::bad_any_cast &amp;e) {
    std::cout &lt;&lt; "Not a string!" &lt;&lt; std::endl;
  }
}

int main() {
  print_if_string(std::string("hello world"));
  print_if_string(5);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

fn print_if_string(x: &amp;dyn Any) {
    match x.downcast_ref::&lt;String&gt;() {
        Some(s) =&gt; println!("{}", s),
        None    =&gt; println!("Not a string!")
    }
}

fn main() {
    print_if_string(&amp;String::from("hello world"));
    print_if_string(&amp;5);
}</code></pre></pre>
</div>
<h2 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h2>
<p>One practical use of RTTI and <code>dynamic_cast</code> in C++ is for event handling in
situations where both the subsystem generating events and the events themselves
need to be decoupled from the handling logic. This is usually because the events
are generated by a framework, such as a GUI or game framework, while the
response to the events is application-specific.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Event {
  virtual ~Event() = default;
};

struct ClickEvent : public Event {
  int x;
  int y;
};

struct ResizeEvent : public Event {
  int old_height;
  int old_width;
  int new_height;
  int new_width;
};

void handle_event(Event *e) {
  if (auto click_event =
          dynamic_cast&lt;ClickEvent *&gt;(e)) {
    // ...
  } else if (auto resize_event =
                 dynamic_cast&lt;ResizeEvent *&gt;(e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}

// register event handler in main
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event {
    ClickEvent {
        x: i32,
        y: i32,
    },
    ResizeEvent {
        old_height: i32,
        old_width: i32,
        new_height: i32,
        new_width: i32,
    },
}

fn handle_event(e: Event) {
    match e {
        Event::ClickEvent { x, y } =&gt; {
            // ...
        }
        Event::ResizeEvent {
            old_height,
            old_width,
            new_height,
            new_width,
        } =&gt; {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Even when the a client of the library is needs to be able to define custom
events, it is usually possible to make use of an event enum. This is the
approach taken by the <a href="https://docs.rs/winit/latest/winit/event/enum.Event.html">winit
crate</a>, which does
cross-platform window and event loop management.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">struct Event {
</span><span class="boring">  virtual ~Event() = default;
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ClickEvent : public Event {
</span><span class="boring">  int x;
</span><span class="boring">  int y;
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ResizeEvent : public Event {
</span><span class="boring">  int old_height;
</span><span class="boring">  int old_width;
</span><span class="boring">  int new_height;
</span><span class="boring">  int new_width;
</span><span class="boring">};
</span><span class="boring">
</span>struct DoSomething : public Event {
  double how_much;
}

struct DoSomethingElse : public Event {
  double how_many;
}

void handle_event(Event *e) {
<span class="boring">  if (auto click_event =
</span><span class="boring">          dynamic_cast&lt;ClickEvent *&gt;(e)) {
</span><span class="boring">    // ...
</span><span class="boring">  } else if (auto resize_event =
</span><span class="boring">                 dynamic_cast&lt;ResizeEvent *&gt;(e)) {
</span><span class="boring">    // ...
</span>  // ...
  } else if (auto user_event =
                 dynamic_cast&lt;DoSomething *&gt;(e)) {
    // ...
  } else if (auto user_event =
                 dynamic_cast&lt;DoSomethingElse *&gt;(
                     e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event&lt;T&gt; {
<span class="boring">    ClickEvent {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    },
</span><span class="boring">    ResizeEvent {
</span><span class="boring">        old_height: i32,
</span><span class="boring">        old_width: i32,
</span><span class="boring">        new_height: i32,
</span><span class="boring">        new_width: i32,
</span><span class="boring">    },
</span>    // ...
    UserEvent(T),
}

enum UserEvent {
    DoSomething { how_much: f64 },
    DoSomethingElse { how_many: i32 },
}

fn handle_event(e: Event&lt;UserEvent&gt;) {
    match e {
<span class="boring">        Event::ClickEvent { x, y } =&gt; {
</span><span class="boring">            // ...
</span><span class="boring">        }
</span><span class="boring">        Event::ResizeEvent {
</span><span class="boring">            old_height,
</span><span class="boring">            old_width,
</span><span class="boring">            new_height,
</span><span class="boring">            new_width,
</span><span class="boring">        } =&gt; {
</span><span class="boring">            // ...
</span><span class="boring">        }
</span>        // ...
        Event::UserEvent(
            UserEvent::DoSomething { how_much },
        ) =&gt; {
            // ...
        }
        Event::UserEvent(
            UserEvent::DoSomethingElse {
                how_many,
            },
        ) =&gt; {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>When representing events as an enum truly isn't feasible, sometimes double
dispatch <!-- TODO: link to visitor --> can be used instead. Otherwise it may be
necessary to use the <code>Any</code> trait or to define an <code>Event</code> trait that exposes a
type identifier that an be used for safe downcasting (via <code>Any</code>) or unsafe
downcasting behind a safe interface.<sup class="footnote-reference" id="fr-safe-event-handler-1"><a href="#footnote-safe-event-handler">1</a></sup></p>
<h2 id="library-support-for-reflection-via-macros"><a class="header" href="#library-support-for-reflection-via-macros">Library support for reflection via macros</a></h2>
<p>Some of the use cases of RTTI can be achieved in Rust by using one of the third-party
reflection libraries. These libraries implement reflection by providing macros
for deriving traits to support common reflection operations. Rust reflection libraries include
<a href="https://docs.rs/bevy_reflect/latest/bevy_reflect/">bevy_reflect</a>, <a href="https://facet.rs/">facet</a>, and
<a href="https://docs.rs/mirror-mirror/latest/mirror_mirror/">mirror-mirror</a>.</p>
<p>The derive-macro approach to reflection essentially makes it opt-in, so that software that
does not use reflection does not have to pay a price for it (performance costs or binary size). However,
due to Rust's <a href="https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules">orphan rule</a>,
this approach makes it more difficult to integrate third-party types that lack the derived trait.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-safe-event-handler">
<p>Such an interface usually involves providing individual
event handling functions for specific types, rather than a single large
event handling function, so that the underlying implementation can managing
the enforcement of the invariants required to make the casting safe. <a href="#fr-safe-event-handler-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-ranges"><a class="header" href="#iterators-and-ranges">Iterators and ranges</a></h1>
<p>Rust iterators resemble C++
<a href="https://en.cppreference.com/w/cpp/ranges.html">ranges</a> in that they represent
iterable sequence and can be manipulated similarly to using
range views. Since C++ ranges are defined using iterators and ranges were only
introduced in C++20, this chapter compares Rust iterators with both C++
iterators and with C++ ranges.</p>
<p>Rust iterators are forward iterators, not <a href="idioms/iterators.html#bidirectional-and-random-access-iterators">bidirectional or random
access</a>. The definition of the
<code>Iterator</code> trait reflects this: all of its methods are based on a <code>next</code> method
which returns either an <code>Option::Some</code> containing the next item in the iteration
or <code>Option::None</code>.</p>
<p>A Rust iterator also does not represent an index into a structure the way that a
C++ iterator does when used with functions from the C++ STL algorithms library,
such as <code>std::sort</code>.</p>
<p>Whether Rust iterators are input iterators or input/output iterators depends on
whether the iterated items are owned values (input), references (input), or
mutable references (input/output). The type of the iterated values typically
reflects whether the structure being iterated over is an owned value, reference,
or mutable reference. Rust iterators cannot be output iterators only because the
iterated values must always be initialized.</p>
<p>In a sense, Rust's iterators are much more like C++23 generators (except that
Rust <a href="https://github.com/rust-lang/rust/issues/43122">does not yet support
coroutines</a>).</p>
<h2 id="iterators-ranges-and-for-loops"><a class="header" href="#iterators-ranges-and-for-loops">Iterators, ranges, and <code>for</code> loops</a></h2>
<p>In C++, anything that has <code>begin()</code> and <code>end()</code> methods to return iterators
(i.e., anything that models the C++20 <code>range</code> concept) can be used with a for
loop. In Rust, anything that implements the
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
trait can be used with a for loop. This includes iterators themselves, which
implement the trait via a <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">blanket
implementation</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v{1, 2, 3};

  // prints 1, 2, 3
  for (auto &amp;x : v) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    x = x + 1;
  }

  // prints 2, 3, 4
  for (const auto &amp;x : v) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3];

    // prints 1, 2, 3
    for x in &amp;mut v {
        println!("{}", x);
        *x = *x + 1;
    }

    // prints 2, 3, 4
    for x in &amp;v {
        println!("{}", x);
    }
}</code></pre></pre>
</div>
<p>In both C++ and Rust, iterators can be used for reading, writing, or both. In
Rust, the use of an iterator for writing depends on the type of the elements
returned. In the case of <code>Vec&lt;i32&gt;</code> above, the <code>IntoIterator</code> trait implemented for
<code>&amp;mut Vec&lt;i32&gt;</code> produces an iterator over mutable references <code>&amp;mut i32</code>, which
enables modifying the values in the vector.<sup class="footnote-reference" id="fr-mut-iterator-safety-1"><a href="#footnote-mut-iterator-safety">1</a></sup></p>
<h2 id="ranges-and-views"><a class="header" href="#ranges-and-views">Ranges and views</a></h2>
<p>Just as the <a href="https://en.cppreference.com/w/cpp/ranges.html">C++ ranges library</a>
provides many utility functions for defining pipelines to transform ranges, the
Rust standard library defines many <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter">iterator
methods</a>
transforming Rust iterators, including turning them back into collections like
vectors.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

using namespace std::views;
using namespace std::ranges::views;

int main() {
<span class="boring">  // clang-format off
</span>  // This example requires C++23
  auto v =
    iota(1)
      | filter([](int n) { return n % 2 == 1; })
      | transform([](int n) { return n + 3; })
      | take(10)
      | std::ranges::to&lt;std::vector&gt;();
<span class="boring">  // clang-format on
</span>
  // use v...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = (1..)
        .filter(|i| i % 2 == 1)
        .map(|i| i + 3)
        .take(10)
        .collect::&lt;Vec&lt;i32&gt;&gt;();

    // use v...
}</code></pre></pre>
</div>
<p>The Rust <code>collect</code> iterator method can convert the iterator into anything that
implements <code>FromIterator</code>. If the type of <code>v</code> can be inferred from its later
use, the type does not need to be specified in the call to <code>collect</code>.</p>
<p>In both C++ and in Rust, the view or iterator could be used directly as the
value to loop over, without first converting to something like
a vector. Similarly, in both languages the construction of the values is done
lazily.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;iostream&gt;

using namespace std::views;
using namespace std::ranges::views;

int main() {
<span class="boring">  // clang-format off
</span>    for (auto x :
        iota(1)
          | filter([](int n) { return n % 2 == 1; })
          | transform([](int n) { return n + 3; })
          | take(10)) {
      std::cout&lt;&lt; x &lt;&lt; std::endl;
    }
<span class="boring">  // clang-format on
</span>}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for x in (1..)
        .filter(|i| i % 2 == 1)
        .map(|i| i + 3)
        .take(10)
    {
        println!("{}", x);
    }
}</code></pre></pre>
</div>
<p>Additional useful methods on iterators are provided by the third-party
<a href="https://docs.rs/itertools/latest/itertools/">itertools crate</a>
via <a href="idioms/../patterns/adapter.html#extension-traits">extension traits</a>.</p>
<h2 id="intoiterator-and-ownership"><a class="header" href="#intoiterator-and-ownership"><code>IntoIterator</code> and ownership</a></h2>
<p>The <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code>
trait</a> can be
implemented for a type <code>T</code> itself, a reference <code>&amp;T</code>, or a mutable reference
<code>&amp;mut T</code>. The possible types of the iterated items depend on what type the trait
is implemented for. If it is implemented for <code>&amp;mut T</code>, for example, typically
the items will be mutable references to items still owned by the original
structure. If the type is <code>T</code>, then the items will be the owned items that were
in the original structure.<sup class="footnote-reference" id="fr-owned-items-references-1"><a href="#footnote-owned-items-references">2</a></sup></p>
<p>Since the behavior depends on the type of the structure used in the for loop,
which may be inferred and therefore not visible, this can lead to surprising
compilation errors. In particular, iterating over a vector <code>v</code> instead of a
reference to the vector <code>&amp;v</code> will consume the original vector, making it
inaccessible.</p>
<p>Iterating over a structure in C++ is most similar to calling <code>into_iter</code> on a
mutable reference in Rust.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = vec![
        String::from("a"),
        String::from("b"),
        String::from("c"),
    ];

    for x in &amp;v {
        // x: &amp;String
        println!("{}", x);
    }

    // since v was borrowed, not moved, it is still accessiable here.
    println!("{:?}", v);

    for x in &amp;mut v {
        // x: &amp;mut String
        x.push('!');
    }

    // since v was borrowed, not moved, it is still accessiable here.
    // however, the content of v has been modified
    println!("{:?}", v);

    for x in v {
        // x: String
        // drops x at the end of each iteration
    }

    // v is no longer accessible, so this wouldn't compile
    // println!("{:?}", v);
}</code></pre></pre>
<p>Most iterable types will also provide methods specifically for accessing the
reference or mutable reference iterators. Conventionally, these are called
<code>iter</code> and <code>iter_mut</code>. They are useful in situations where the iteration is not
being immediately used with a for loop, but instead is used with other iterator
methods, because of the relative precedence of the reference operator and of
method invocation.</p>
<h2 id="identifying-ranges-for-algorithms-to-operate-on"><a class="header" href="#identifying-ranges-for-algorithms-to-operate-on">Identifying ranges for algorithms to operate on</a></h2>
<p>C++ uses iterators to identify regions of structures on which functions from the
STL algorithms library should operate. Rust iterators do not serve that purpose.
Instead, there are two common alternatives.</p>
<p>The first is that operations which operate strictly on forward iterators just
operate directly on the iterator. Identifying specific parts of an iterator for
this purpose can be done using the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods">iterator
methods</a>,
such as
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take"><code>take</code></a> or
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter</code></a>.
Alternatively, for some types <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">slices can be taken by indexing with a
range</a> before converting to
an iterator.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
  std::vector v{1, 2, 3, 4, 5, 6, 7, 8, 9};
  auto begin = v.begin() + 2;
  auto end = begin + 5;
  bool b(std::any_of(begin, end, [](int n) {
    return n % 2 == 0;
  }));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v: Vec&lt;i32&gt; = (1..10).collect();
    let b = v
        .iter()
        .skip(2)
        .take(5)
        .any(|n| n % 2 == 0);

    // or

    let b2 = v[3..7].iter().any(|n| n % 2 == 0);

    // ...
}</code></pre></pre>
</div>
<p>The second is that some of the algorithms operate on slices. For example, the
<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.sort">sort method</a> in
the Rust standard library operates on slices. This is similar to if in C++, a
function were to operate on a <code>std::span</code> instead of on an iterator. Many of the
methods available on <code>Vec&lt;T&gt;</code> are actually defined on <code>&amp;[T]</code> and are made
available on <code>Vec&lt;T&gt;</code> via <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">deref
coercion</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector v{9, 8, 7, 6, 5, 4, 3, 2, 1};

  for (auto n : v) {
    std::cout &lt;&lt; n &lt;&lt; ",";
  }
  std::cout &lt;&lt; std::endl;

  std::sort(v.begin(), v.end());

  for (auto n : v) {
    std::cout &lt;&lt; n &lt;&lt; ",";
  }
  std::cout &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v: Vec&lt;i32&gt; = (1..10).rev().collect();
    println!("{:?}", v);

    v.sort();

    println!("{:?}", v);
}</code></pre></pre>
</div>
<h2 id="iterator-invalidation"><a class="header" href="#iterator-invalidation">Iterator invalidation</a></h2>
<p>In C++, operations sometimes only invalidate some iterators on a value, such as
the <code>erase</code> method on <code>std::vector</code> only invaliding iterators to the erased
element and those after it, but not the ones before it.</p>
<p>In Rust, the fact that iterators borrow the whole iterated value means that no
operations modifying the value itself (such as erasing values from a vector) can
be performed while iterating. Thus, there are no iterator invalidation rules to
keep in mind while using Rust iterators.</p>
<p>However, this also means that there are things that can be done with iterators
in C++ that cannot be done with iterators in Rust, such as removing elements
from a vector while iterating over it. Instead in Rust there are two possible
approaches: use indices or use helper methods.</p>
<p>Using indices instead of iterators comes with the same challenges as it does in
C++, with the exception that the program will panic instead of performing
undefined behavior if an index is out of bounds in safe Rust.</p>
<p>Using the helper methods resembles the recommendations commonly given for
writing against newer C++ standards. For example, to remove all elements of a
particular value in Rust, one would use the
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.retain"><code>Vec::retain</code></a>
method, which is like <code>remove_if</code> or <code>erase_if</code> on <code>std::vector</code>, but with a
negative predicate.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v{1, 2, 3};

  auto newEnd = remove(v.begin(), v.end(), 2);
  v.erase(newEnd, v.end());

  // Or since C++20
  // std::erase(v, 2);

  for (auto x : v) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3];
    v.retain(|i| *i != 2);

    for x in &amp;v {
        println!("{}", x);
    }
}</code></pre></pre>
</div>
<p>When using iterators, one would use the methods described in the section on
<a href="idioms/iterators.html#ranges-and-views">ranges and views</a>.</p>
<h2 id="implementing-rust-iterators"><a class="header" href="#implementing-rust-iterators">Implementing Rust iterators</a></h2>
<p>This extended example defines a binary tree and preorder const iterator over the
tree. The module structure is included in this example because defining private
items will be an important part of later patterns used to simplify the
implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;memory&gt;

template &lt;typename V&gt;
class Tree {
public:
    V value;
    std::unique_ptr&lt;Tree&lt;V&gt;&gt; left;
    std::unique_ptr&lt;Tree&lt;V&gt;&gt; right;
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod tree {
    /// Binary tree with values at every node.
    /// Not necessarily balanced.
    pub struct Tree&lt;V&gt; {
        pub value: V,
        pub left: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
        pub right: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Much like how in C++ an iterator and a const iterator are distinct things, in
Rust there are different iterators for owned values, references, and mutable
references.</p>
<p>For example, for tree type <code>Tree&lt;V&gt;</code> would likely provide the following methods
to support preorder iteration. For the methods that provide iteration over
references, the references are borrowed from the original structure, and so the
lifetime parameter <code>'a</code> relates the reference to the item to <code>self</code>.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>method</th><th>item type</th></tr></thead><tbody>
<tr><td>reference</td><td><code>fn preorder&lt;'a&gt;(&amp;'a self) -&gt; IterPreorder&lt;'a, V&gt;</code></td><td><code>&amp;'a V</code></td></tr>
<tr><td>mutable reference</td><td><code>fn preorder_mut&lt;'a&gt;(&amp;'a mut self) -&gt; IterMutPreorder&lt;'a, V&gt;</code></td><td><code>&amp;'a mut V</code></td></tr>
<tr><td>owned</td><td><code>fn into_preorder(self) -&gt; IntoIterPreorder&lt;V&gt;</code></td><td><code>V</code></td></tr>
</tbody></table>
</div>
<p>Just like with C++ iterators, the essential complexity of defining the iterator
amounts to determining how to capture the suspended state of traversing the
structure. In this case the suspended state consists of a stack of the rest of
the trees to iterate.</p>
<p>The implementations diverge in the interface provided. C++ requires several
types and methods to be defined in order for the type to model a forward
iterator. Rust requires only the definition of the element type that will be
iterated and a <code>next</code> method.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">#include &lt;vector&gt;
</span><span class="boring">
</span>template &lt;typename V&gt;
class Tree {
public:
  class iterator {
    std::vector&lt;const Tree&lt;V&gt; *&gt; rest;

  public:
    using difference_type = long;
    using value_type = V;
    using pointer = const V *;
    using reference = const V &amp;;
    using iterator_category =
        std::forward_iterator_tag;

    iterator() {}
    iterator(const Tree&lt;V&gt; *start) {
      rest.push_back(start);
    }

    reference operator*() const {
      return rest.back()-&gt;value;
    }

    iterator &amp;operator++() {
      const Tree&lt;V&gt; *t = rest.back();
      rest.pop_back();
      if (t-&gt;right) {
        rest.push_back(t-&gt;right.get());
      }
      if (t-&gt;left) {
        rest.push_back(t-&gt;left.get());
      }
      return *this;
    }

    iterator operator++(int) {
      iterator retval = *this;
      const Tree&lt;V&gt; *t = rest.back();
      rest.pop_back();
      if (t-&gt;right) {
        rest.push_back(t-&gt;right.get());
      }
      if (t-&gt;left) {
        rest.push_back(t-&gt;left.get());
      }
      return retval;
    }

    bool operator==(const iterator &amp;other) const {
      return rest == other.rest;
    }

    bool operator!=(const iterator &amp;other) const {
      return !(*this == other);
    }
  };
<span class="boring">
</span><span class="boring">  V value;
</span><span class="boring">  std::unique_ptr&lt;Tree&lt;V&gt;&gt; left;
</span><span class="boring">  std::unique_ptr&lt;Tree&lt;V&gt;&gt; right;
</span>};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod tree {
<span class="boring">    /// Binary tree with values at every node.
</span><span class="boring">    /// Not necessarily balanced.
</span><span class="boring">    pub struct Tree&lt;V&gt; {
</span><span class="boring">        pub value: V,
</span><span class="boring">        pub left: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
</span><span class="boring">        pub right: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span>    pub struct IterPreorder&lt;'a, V&gt;(Vec&lt;&amp;'a Tree&lt;V&gt;&gt;);

    impl&lt;'a, V&gt; Iterator for IterPreorder&lt;'a, V&gt; {
        type Item = &amp;'a V;

        // This is like a combination of
        // operator++ and operator*
        fn next(&amp;mut self) -&gt; Option&lt;&amp;'a V&gt; {
            let Tree { value, left, right } = self.0.pop()?;
            if let Some(right) = right {
                self.0.push(right.as_ref());
            }
            if let Some(left) = left {
                self.0.push(left.as_ref());
            }
            Some(value)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The remaining step is to make the original type iterable. In C++, this involves
defining <code>begin</code> and <code>end</code> methods. In Rust, this involves either implementing a
method that explicitly produces the iterator, or implementing the <code>IntoIterator</code>
trait.</p>
<p>When there are multiple possible iterations for a type and none of them are
canonical, it is idiomatic to omit the <code>IntoIterator</code> trait implementation.
Omitting the implementation requires users to intentionally choose the kind of
iteration to use. The trait is implemented below to provide an example, but an
unsorted binary tree is a case where it would be typical to omit the trait
implementation, to force a user to pick between pre-, post-, and in-order
iteration.</p>
<p>Because the implemented iterator is one for references, the trait actually is
implemented for references to trees <code>&amp;Tree&lt;V&gt;</code>, rather than <code>Tree&lt;V&gt;</code> directly.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
<span class="boring">#include &lt;memory&gt;
</span><span class="boring">#include &lt;vector&gt;
</span>
template &lt;typename V&gt;
class Tree {
public:
<span class="boring">  class iterator {
</span><span class="boring">    std::vector&lt;const Tree&lt;V&gt; *&gt; rest;
</span><span class="boring">
</span><span class="boring">  public:
</span><span class="boring">    using difference_type = long;
</span><span class="boring">    using value_type = V;
</span><span class="boring">    using pointer = const V *;
</span><span class="boring">    using reference = const V &amp;;
</span><span class="boring">    using iterator_category =
</span><span class="boring">        std::forward_iterator_tag;
</span><span class="boring">
</span><span class="boring">    iterator() {}
</span><span class="boring">    iterator(const Tree&lt;V&gt; *start) {
</span><span class="boring">      rest.push_back(start);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    reference operator*() const {
</span><span class="boring">      return rest.back()-&gt;value;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    iterator &amp;operator++() {
</span><span class="boring">      const Tree&lt;V&gt; *t = rest.back();
</span><span class="boring">      rest.pop_back();
</span><span class="boring">      if (t-&gt;right) {
</span><span class="boring">        rest.push_back(t-&gt;right.get());
</span><span class="boring">      }
</span><span class="boring">      if (t-&gt;left) {
</span><span class="boring">        rest.push_back(t-&gt;left.get());
</span><span class="boring">      }
</span><span class="boring">      return *this;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    iterator operator++(int) {
</span><span class="boring">      iterator retval = *this;
</span><span class="boring">      const Tree&lt;V&gt; *t = rest.back();
</span><span class="boring">      rest.pop_back();
</span><span class="boring">      if (t-&gt;right) {
</span><span class="boring">        rest.push_back(t-&gt;right.get());
</span><span class="boring">      }
</span><span class="boring">      if (t-&gt;left) {
</span><span class="boring">        rest.push_back(t-&gt;left.get());
</span><span class="boring">      }
</span><span class="boring">      return retval;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    bool operator==(const iterator &amp;other) const {
</span><span class="boring">      return rest == other.rest;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    bool operator!=(const iterator &amp;other) const {
</span><span class="boring">      return !(*this == other);
</span><span class="boring">    }
</span><span class="boring">  };
</span><span class="boring">
</span>  iterator begin() const {
    return iterator(this);
  }

  iterator end() const {
    return iterator();
  }
<span class="boring">
</span><span class="boring">  V value;
</span><span class="boring">  std::unique_ptr&lt;Tree&lt;V&gt;&gt; left;
</span><span class="boring">  std::unique_ptr&lt;Tree&lt;V&gt;&gt; right;
</span>};

int main() {
  Tree&lt;int&gt; t{1,
              std::make_unique&lt;Tree&lt;int&gt;&gt;(
                  2, nullptr, nullptr),
              std::make_unique&lt;Tree&lt;int&gt;&gt;(
                  3,
                  std::make_unique&lt;Tree&lt;int&gt;&gt;(
                      4, nullptr, nullptr),
                  nullptr)};

  for (auto v : t) {
    std::cout &lt;&lt; v &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod tree {
<span class="boring">   /// Binary tree with values at every node.
</span><span class="boring">   /// Not necessarily balanced.
</span><span class="boring">   pub struct Tree&lt;V&gt; {
</span><span class="boring">       pub value: V,
</span><span class="boring">       pub left: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
</span><span class="boring">       pub right: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub struct IterPreorder&lt;'a, V&gt;(Vec&lt;&amp;'a Tree&lt;V&gt;&gt;);
</span><span class="boring">
</span><span class="boring">   impl&lt;'a, V&gt; Iterator for IterPreorder&lt;'a, V&gt; {
</span><span class="boring">       type Item = &amp;'a V;
</span><span class="boring">       fn next(&amp;mut self) -&gt; Option&lt;&amp;'a V&gt; {
</span><span class="boring">           match self.0.pop() {
</span><span class="boring">               None =&gt; None,
</span><span class="boring">               Some(t) =&gt; {
</span><span class="boring">                   let Tree { value, left, right } = t;
</span><span class="boring">                   if let Some(right) = right {
</span><span class="boring">                       self.0.push(right.as_ref());
</span><span class="boring">                   }
</span><span class="boring">                   if let Some(left) = left {
</span><span class="boring">                       self.0.push(left.as_ref());
</span><span class="boring">                   }
</span><span class="boring">                   Some(value)
</span><span class="boring">               }
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    impl&lt;V&gt; Tree&lt;V&gt; {
        pub fn preorder(&amp;self) -&gt; IterPreorder&lt;V&gt; {
            IterPreorder(vec![self])
        }
    }

    impl&lt;'a, V&gt; IntoIterator for &amp;'a Tree&lt;V&gt; {
        type Item = &amp;'a V;
        type IntoIter = IterPreorder&lt;'a, V&gt;;

        fn into_iter(self) -&gt; Self::IntoIter {
            self.preorder()
        }
    }
}

use tree::*;

fn main() {
    let t = Tree {
        value: 1,
        left: Some(Box::new(Tree {
            value: 2,
            left: None,
            right: None,
        })),
        right: Some(Box::new(Tree {
            value: 3,
            left: Some(Box::new(Tree {
                value: 4,
                left: None,
                right: None,
            })),
            right: None,
        })),
    };

    for n in t.preorder() {
        println!("{}", n);
    }

    for n in &amp;t {
        println!("{}", n);
    }
}</code></pre></pre>
</div>
<p>Implementing the iterators for mutable references and owned values can be done
similarly. With all three, there are three <code>IntoIterator</code> implementations, one
for <code>&amp;Tree&lt;V&gt;</code>, one for <code>&amp;mut Tree&lt;V&gt;</code>, and one for <code>Tree&lt;V&gt;</code>.</p>
<h3 id="reducing-code-duplication"><a class="header" href="#reducing-code-duplication">Reducing code duplication</a></h3>
<p>As with implementing iterators and const iterators in C++, implementing
iterators for owned values, references, and mutable references can result in
significant code duplication in Rust.</p>
<p>One pattern for addressing this involves defining a private trait that captures
the decomposing of the type and then implementing the <code>Iterator</code> trait via a
blanket implementation in terms of that trait. Wrapper structs can then be used
to expose the iteration behavior without exposing the helper trait.</p>
<p>The following example implements this pattern for the <code>Tree&lt;V&gt;</code> type above as an
alternative to the simpler, but more duplicative, approach above.</p>
<pre><pre class="playground"><code class="language-rust">mod tree {
    /// Binary tree with values at every node.
    /// Not necessarily balanced.
    pub struct Tree&lt;V&gt; {
        pub value: V,
        pub left: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
        pub right: Option&lt;Box&lt;Tree&lt;V&gt;&gt;&gt;,
    }

    impl&lt;V&gt; Tree&lt;V&gt; {
        // ... static methods for constructing trees ...
<span class="boring">
</span><span class="boring">       /// Constructs a new node with two
</span><span class="boring">       /// subtrees.
</span><span class="boring">       pub fn node(value: V, left: Tree&lt;V&gt;, right: Tree&lt;V&gt;) -&gt; Tree&lt;V&gt; {
</span><span class="boring">           Tree {
</span><span class="boring">               value,
</span><span class="boring">               left: Some(Box::new(left)),
</span><span class="boring">               right: Some(Box::new(right)),
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       /// Constructs a new node with a left
</span><span class="boring">       /// subtree.
</span><span class="boring">       pub fn left(value: V, left: Tree&lt;V&gt;) -&gt; Tree&lt;V&gt; {
</span><span class="boring">           Tree {
</span><span class="boring">               value,
</span><span class="boring">               left: Some(Box::new(left)),
</span><span class="boring">               right: None,
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       /// Constructs a new node with a right
</span><span class="boring">       /// subtree.
</span><span class="boring">       pub fn right(value: V, right: Tree&lt;V&gt;) -&gt; Tree&lt;V&gt; {
</span><span class="boring">           Tree {
</span><span class="boring">               value,
</span><span class="boring">               left: None,
</span><span class="boring">               right: Some(Box::new(right)),
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       /// Constructs a new leaf node.
</span><span class="boring">       pub fn leaf(value: V) -&gt; Self {
</span><span class="boring">           Tree {
</span><span class="boring">               value,
</span><span class="boring">               left: None,
</span><span class="boring">               right: None,
</span><span class="boring">           }
</span><span class="boring">       }
</span>    }

    /// Internal trait for abstracting over access
    /// to the tree components.
    ///
    /// This reduces code duplication when
    /// implementing behavior that is essentially
    /// the same for Tree&lt;V&gt;, &amp;Tree&lt;V&gt;,
    /// and &amp;mut Tree&lt;V&gt;.
    trait Treeish: Sized {
        type Output;
        fn get(self) -&gt; (Option&lt;Self&gt;, Self::Output, Option&lt;Self&gt;);
    }

    impl&lt;V&gt; Treeish for Tree&lt;V&gt; {
        type Output = V;
        fn get(self) -&gt; (Option&lt;Self&gt;, Self::Output, Option&lt;Self&gt;) {
            let Tree { value, left, right } = self;
            (left.map(|x| *x), value, right.map(|x| *x))
        }
    }

    impl&lt;'a, V&gt; Treeish for &amp;'a Tree&lt;V&gt; {
        type Output = &amp;'a V;
        fn get(self) -&gt; (Option&lt;Self&gt;, Self::Output, Option&lt;Self&gt;) {
            let Tree { value, left, right } = self;
            (left.as_deref(), value, right.as_deref())
        }
    }

    impl&lt;'a, V&gt; Treeish for &amp;'a mut Tree&lt;V&gt; {
        type Output = &amp;'a mut V;
        fn get(self) -&gt; (Option&lt;Self&gt;, Self::Output, Option&lt;Self&gt;) {
            let Tree { value, left, right } = self;
            (left.as_deref_mut(), value, right.as_deref_mut())
        }
    }

    /// Internal struct for implementing Iterator
    /// in terms of Treeish.
    struct Preorder&lt;T&gt;(Vec&lt;T&gt;);

    impl&lt;T&gt; Iterator for Preorder&lt;T&gt;
    where
        T: Treeish,
    {
        type Item = T::Output;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            let next = self.0.pop();
            match next {
                None =&gt; None,
                Some(t) =&gt; {
                    // the helper trait is used here
                    let (left, value, right) = t.get();
                    if let Some(right) = right {
                        self.0.push(right);
                    }
                    if let Some(left) = left {
                        self.0.push(left);
                    }
                    Some(value)
                }
            }
        }
    }

    // Wrappers for exposing the iterator. The wrappers are necessary
    // in order to keep Treeish private. Treeish::Output would
    // otherwise be exposed and thus require Treeish to be public.

    /// Preorder iterator
    pub struct IntoIterPreorder&lt;V&gt;(Preorder&lt;Tree&lt;V&gt;&gt;);

    /// Preorder iterator
    pub struct IterPreorder&lt;'a, V&gt;(Preorder&lt;&amp;'a Tree&lt;V&gt;&gt;);

    /// Preorder iterator
    pub struct IterMutPreorder&lt;'a, V&gt;(Preorder&lt;&amp;'a mut Tree&lt;V&gt;&gt;);

    // Delegate to the wrapped implementation.

    impl&lt;V&gt; Iterator for IntoIterPreorder&lt;V&gt; {
        type Item = V;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            self.0.next()
        }
    }

    impl&lt;'a, V&gt; Iterator for IterPreorder&lt;'a, V&gt; {
        type Item = &amp;'a V;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            self.0.next()
        }
    }

    impl&lt;'a, V&gt; Iterator for IterMutPreorder&lt;'a, V&gt; {
        type Item = &amp;'a mut V;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            self.0.next()
        }
    }

    impl&lt;V&gt; Tree&lt;V&gt; {
        pub fn preorder(self) -&gt; IntoIterPreorder&lt;V&gt; {
            IntoIterPreorder(Preorder(vec![self]))
        }

        pub fn preorder_ref(&amp;self) -&gt; IterPreorder&lt;V&gt; {
            IterPreorder(Preorder(vec![self]))
        }

        pub fn preorder_ref_mut(&amp;mut self) -&gt; IterMutPreorder&lt;V&gt; {
            IterMutPreorder(Preorder(vec![self]))
        }
    }
}

use tree::*;

fn main() {
    let mut t = Tree::node(
        0,
        Tree::left(1, Tree::leaf(2)),
        Tree::node(3, Tree::leaf(4), Tree::right(5, Tree::leaf(6))),
    );

    for x in t.preorder_ref_mut() {
        *x += 10;
    }

    for x in t.preorder_ref() {
        println!("{}", x);
    }
}</code></pre></pre>
<h2 id="bidirectional-and-random-access-iterators"><a class="header" href="#bidirectional-and-random-access-iterators">Bidirectional and random access iterators</a></h2>
<p>The Rust standard library does not include support for bidirectional or random
access iterators. For most of the use cases supported by those iterators,
working with numeric indices suffices.</p>
<p>The standard library does have support for <a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html">double-ended
iterators</a>,
which allow consuming items from the back of the iterator. However, each item
can still only be consumed once: when the front and back meet in the middle,
iteration is over.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;iterators&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;For loops implicitly call `into_iter` on the iterated value. The method\n`into_iter` takes ownership of the value. To make this compile, the loop should\nbe on a reference to `v`, so that it is the reference that has ownership taken\nof it.\n\nEven though `last` is mutable, the `&amp;String` reference it would contain if `v`\nwere borrowed isn't. Thus, that does not conflict with the later use of `v`.\n&quot;,&quot;id&quot;:&quot;34e60ac8-ba03-4076-9ee4-a8a50e9c446d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program does not compile because the for loop moves `v`, and so it can't be\nborrowed afterwards.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The program compiles.\n&quot;,&quot;The program does not compile because `v` is a `Vec`, not an `Iterator`.\n&quot;,&quot;The program does not compile because `last` is mutable and borrows `x` while `v`\nis borrowed by `len()`.\n&quot;],&quot;prompt&quot;:&quot;Does the following Rust program compile? If not, why not?\n\n```rust\nfn main() {\n    let v = vec![\&quot;a\&quot;.to_string(), \&quot;b\&quot;.to_string()];\n\n    let mut last = None;\n    for x in v {\n        println!(\&quot;{}\&quot;, x);\n        last = Some(x);\n    }\n\n    println!(\&quot;{}\&quot;, v.len());\n    println!(\&quot;last: {:?}\&quot;, last);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The solution that uses `enumerate` fails to compile because `v` is borrowed for\nthe entirety of each for loop. The borrow checker cannot tell that the condition\nprevents `x` and `y` from being used at the same time when they point to the\nsame index.\n\nThe solution that uses indices but takes the references immediately fails to\ncompile for the same reason.\n\nThe solution that uses indices throughout works because the lifetimes of the\nborrows of `v` to compute the new value and to update the value at index `i` do\nnot overlap.\n\nThe solution splitting the vector into parts makes use of fact that the standard\nlibrary provides a safe API for partitioning a vector. There are never two\nmutable references to the same index in the vector. The standard library\ncontains many other similarly useful methods for operating on vectors, arrays,\nand slices.\n&quot;,&quot;id&quot;:&quot;5c1a704a-bc85-470a-9443-07fca80d7d1f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```\nfn main() {\n    let mut v: Vec&lt;i32&gt; = (0..10).collect();\n\n    for i in 0..v.len() {\n        for j in 0..v.len() {\n            if i != j {\n                v[i] += v[j];\n            }\n        }\n    }\n}\n```\n&quot;,&quot;```rust\nfn main() {\n    let mut v: Vec&lt;i32&gt; = (0..10).collect();\n\n    for i in 0..v.len() {\n        let (before, rest) = v.split_at_mut(i);\n        let (x, after) = rest.split_first_mut().unwrap();\n        for y in before.into_iter().chain(after) {\n            *x += *y;\n        }\n    }\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn main() {\n    let mut v: Vec&lt;i32&gt; = (0..10).collect();\n\n    for (i, x) in (&amp;mut v).into_iter().enumerate() {\n        for (j, y) in (&amp;v).into_iter().enumerate() {\n            if i != j {\n                *x += *y;\n            }\n        }\n    }\n}\n```\n&quot;,&quot;```rust\nfn main() {\n    let mut v: Vec&lt;i32&gt; = (0..10).collect();\n\n    for i in 0..v.len() {\n        let mut x = &amp;mut v[i];\n        for j in 0..v.len() {\n            if i != j {\n                let y = &amp;mut v[j];\n                *x += *y;\n            }\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following programs are ways in Rust to update each element of a\nvector based on all of the other elements in the vector?\n\nThe documentation for the following methods might be useful in answering this\nquestion:\n\n- &lt;a href=\&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate\&quot; target=\&quot;_blank\&quot;&gt;`enumerate`&lt;/a&gt;\n- &lt;a href=\&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut\&quot; target=\&quot;_blank\&quot;&gt;`split_at_mut`&lt;/a&gt;\n- &lt;a href=\&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut\&quot; target=\&quot;_blank\&quot;&gt;`split_first_mut`&lt;/a&gt;\n- &lt;a href=\&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain\&quot; target=\&quot;_blank\&quot;&gt;`chain`&lt;/a&gt;\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><hr>
<ol class="footnote-definition"><li id="footnote-mut-iterator-safety">
<p>The safety of the mutable references is given by the
fact that the references borrow from the vector, don't overlap, and are
never produced by the iterator more than once. <a href="#fr-mut-iterator-safety-1">↩</a></p>
</li>
<li id="footnote-owned-items-references">
<p>The owned items might themselves be references,
however. E.g., calling <code>into_iter</code> on a <code>Vec&lt;&amp;str&gt;</code> will not result in
iterating over <code>String</code> values even though the vector itself is consumed. <a href="#fr-owned-items-references-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas-closures-and-function-objects"><a class="header" href="#lambdas-closures-and-function-objects">Lambdas, closures, and function objects</a></h1>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function pointers</a></h2>
<p>Both C++ and Rust permit the use of functions as values. In both, the values can
have <a href="https://doc.rust-lang.org/std/primitive.fn.html">function pointer types</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int process(int n) {
  std::cout &lt;&lt; n &lt;&lt; std::endl;
  return 2 * n;
}

int main() {
  auto f = process;
  // or with type annotation
  // int (*f)(int) = process;

  std::cout &lt;&lt; f(42) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn process(n: i32) -&gt; i32 {
    println!("{}", n);
    2 * n
}

fn main() {
    let f = process;
    // or with type annotation
    // let f: fn(i32) -&gt; i32 = process;

    println!("{}", f(42));
}</code></pre></pre>
</div>
<p>Non-capturing closures are also convertible function pointers in both C++ and
Rust. In the following example the type could be inferred in both C++ and Rust,
but the type is explicitly given to demonstrate that in both cases the closure
has a function pointer type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
  int (*f)(int) = [](int n) {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    return 2 * n;
  };

  std::cout &lt;&lt; f(42) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f = |n: i32| {
        println!("{}", n);
        2 * n
    };
    // or with type annotation
    // let f: fn(i32) -&gt; i32 = process;

    println!("{}", f(42));
}</code></pre></pre>
</div>
<p>Unlike in C++, in Rust functions can be defined within other functions. This has
the same meaning as defining the functions outside of the function (i.e., the
function is not a capturing closure and so cannot capture variables defined in
the outer function), but the name of the function is only available within the
outer function.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn process(n: i32) -&gt; i32 {
        println!("{}", n);
        2 * n
    }

    println!("{}", process(42));
}</code></pre></pre>
<h2 id="rusts-call-operator-traits"><a class="header" href="#rusts-call-operator-traits">Rust's call operator traits</a></h2>
<p>In C++, any class can implement the call operator method <code>operator()</code> and be a
function object. Closures defined by lambdas do so automatically. In Rust the
equivalent are the call operator traits.</p>
<div class="table-wrapper"><table><thead><tr><th>Trait</th><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce&lt;Args&gt;</code></a></td><td><code>fn call_once(self, args: Args) -&gt; Self::Output</code></td><td>Can be called at most once</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut&lt;Args&gt;</code></a></td><td><code>fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output</code></td><td>Can be called multiple times and may mutate captures (like the <code>mutable</code> specifier in C++)</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn&lt;Args&gt;</code></a></td><td><code>fn call(&amp;self, args: Args) -&gt; Self::Output</code></td><td>Can be called multiple times and do not mutate captures</td></tr>
</tbody></table>
</div>
<p>Rust function pointers implement all three traits. Other closures implement the
traits depending on how they use the captured variables.</p>
<details>
<summary>
<p>Closure implementing only <code>FnOnce</code></p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hi");
  auto f = [x = std::move(x)]() mutable {
    return std::move(x);
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl;
  // compiles, but the captured value has been
  // moved
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints ""
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let f = {
       let x = String::from("hi");
       // f : FnOnce()
       move || x
   };

   // f() is equivalent to f.call_once()
   println!("{}", f()); // prints "hi"

   // Won't compile--call_once consumes f.
   // println!("{}", f());
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>FnMut</code> and taking ownership of the capture</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [x = std::move(x)]() mutable {
    x.push_back('!');
    return x.size();
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "1"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "2"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut f = {
        let mut x = String::from("");
        // f : FnMut() -&gt; usize
        move || {
            x.push('!');
            x.len()
        }
    };

    println!("{}", f()); // prints "1"
    println!("{}", f()); // prints "2"
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>FnMut</code> and capturing by mutable reference</p>
</summary>
<p>In this case, <code>x</code> has to be alive as long as the closure might be used, since
the closure borrows <code>x</code>. Therefore, <code>x</code> can't be declared in a block with the
lambda like in the previous example.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [&amp;x]() {
    x.push_back('!');
    return x.size();
  };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "1"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "2"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("");
    // g : FnMut() -&gt; usize
    let mut f = || {
        x.push('!');
        x.len()
    };

    println!("{}", f()); // prints "1"
    println!("{}", f()); // prints "2"
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Closure implementing <code>Fn</code></p>
</summary>
<p>Whether <code>x</code> is <code>mut</code> or not doesn't affect whether the closure implements <code>Fn</code>
or <code>FnMut</code>. What matters is how <code>x</code> is used by the closure.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("");
  auto f = [&amp;x]() { return x.size(); };

  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "0"
  std::cout &lt;&lt; f() &lt;&lt; std::endl; // prints "0"
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f = {
        let x = String::from("");
        // g : Fn() -&gt; usize
        move || x.len()
    };

    println!("{}", f()); // prints "0"
    println!("{}", f()); // prints "0"
}</code></pre></pre>
</div>
</details>
<h2 id="lambdas-and-closures"><a class="header" href="#lambdas-and-closures">Lambdas and closures</a></h2>
<p>In neither C++ nor Rust can the concrete type of a capturing closure be written.
In both languages, for local variables this means that the type must be
inferred.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
  std::string greeting = "hello";
  // Can't write the type of the closure
  auto sayHelloTo = [&amp;](std::string &amp;who) {
    std::ostringstream out;
    out &lt;&lt; greeting &lt;&lt; " " &lt;&lt; who;
    return out.str();
  };

  std::string world("world");
  std::string moon("moon");

  std::cout &lt;&lt; sayHelloTo(world) &lt;&lt; std::endl;
  std::cout &lt;&lt; sayHelloTo(moon) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to = |who: &amp;str| {
        format!("{} {}", greeting, who)
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
</div>
<p>In both C++ and Rust if the closure is heap-allocated a type can be given. In
C++ this is done using <code>std::function</code> while in Rust it again is done with the
call operator traits.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
  std::string greeting = "hello";
  // Can't write the type of the closure
  std::function&lt;std::string(std::string &amp;)&gt;
      sayHelloTo([&amp;](std::string &amp;who) {
        std::ostringstream out;
        out &lt;&lt; greeting &lt;&lt; " " &lt;&lt; who;
        return out.str();
      });

  std::string world("world");
  std::string moon("moon");

  std::cout &lt;&lt; sayHelloTo(world) &lt;&lt; std::endl;
  std::cout &lt;&lt; sayHelloTo(moon) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to: Box&lt;
        dyn Fn(&amp;str) -&gt; String,
    &gt; = Box::new(|who: &amp;str| {
        format!("{} {}", greeting, who)
    });

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
</div>
<p>Since <code>std::function</code> can be empty the above example isn't strictly equivalent.
However, since <code>std::function</code> is often used with the side condition that the
value not be empty, the <code>Box</code> without an <code>Option</code> wrapper for representing the
empty case is the more practical translation.</p>
<p>A type can also be given in terms of one of the function operator traits for
references to closures in Rust.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello";

    // Can't write the type of the closure
    let say_hello_to = |who: &amp;str| {
        format!("{} {}", greeting, who)
    };

    let say: &amp;dyn Fn(&amp;str) -&gt; String = &amp;say_hello_to;

    println!("{}", say("world"));
    println!("{}", say("moon"));
}</code></pre></pre>
<p>Additionally, in both C++ and Rust, the return type of the closure can be
annotated as part of the lambda expression. This is useful when the return type
either cannot be inferred or should be less specific than what would be
inferred. In the following example this is used to return a value in terms of an
interface it implements instead of the concrete type that would otherwise be
inferred.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

// The common interface
struct Debug {
  virtual std::ostream &amp;
  emit(std::ostream &amp;out) const = 0;
};

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
                         const Debug &amp;d) {
  d.emit(out);
  return out;
}

// Two things that implement the interface
struct A : public Debug {
  std::ostream &amp;
  emit(std::ostream &amp;out) const override {
    out &lt;&lt; "A";
    return out;
  }
};

struct B : public Debug {
  std::ostream &amp;
  emit(std::ostream &amp;out) const override {
    out &lt;&lt; "B";
    return out;
  }
};

int main() {
  // Without the return-type annotation,
  // std::unique_ptr&lt;A&gt; would be inferred.
  auto f = [](std::unique_ptr&lt;A&gt; a,
              std::unique_ptr&lt;B&gt; b)
      -&gt; std::unique_ptr&lt;Debug&gt; { return a; };
  std::cout &lt;&lt; *f(std::make_unique&lt;A&gt;(),
                  std::make_unique&lt;B&gt;())
            &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// The common interface
use std::fmt::Debug;

// Two things that implement the interface
#[derive(Debug)]
struct A;

#[derive(Debug)]
struct B;

fn main() {
    // Without the return type annotation,
    // Box&lt;A&gt; would be inferred.
    let f = move |a: Box&lt;A&gt;,
                  b: Box&lt;B&gt;|
          -&gt; Box&lt;dyn Debug&gt; { a };
    println!("{:?}", f(Box::new(A), Box::new(B)));
}</code></pre></pre>
</div>
<h2 id="capturing-variables"><a class="header" href="#capturing-variables">Capturing variables</a></h2>
<p>In C++, capture specifiers are used to indicate whether a variable should be
captured by reference, by copy, or by move. The capture specifiers can be given
for all of the variables at once, for each variable, or given as a default along
with specific choices for each variable.</p>
<p>In Rust, the variables are captured either all by reference (by default) or all by move (using
a <code>move</code> specifier). In order to express other capture strategies, the references
and copies need to be explicitly defined and the closure needs to capture those
variables instead.</p>
<p>Expressing the pattern of explicitly making copies or taking references
leverages the fact that in Rust blocks are expressions. In the examples that
need to do that, notice the lack of a semicolon in the last statement of the
block that is being assigned to the variable to hold the closure.</p>
<p>The following examples show examples of different patterns of capturing
variables in C++ and their analogs in Rust.</p>
<details>
<summary>
<p>Capture <code>x</code> and <code>y</code> by reference</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [&amp;]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x and y borrowed by f, but still available
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    let f = || {
        println!("{}", x);
        println!("{}", y);
    };

    // x and y borrowed by f, but still available
    println!("{}", x);
    println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Capture <code>x</code> and <code>y</code> by mutable reference</p>
</summary>
<p>The C++ version is same as when capturing by mutable reference.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [&amp;]() {
    x.push_back('!');
    y.push_back('!');
  };

  // x and y borrowed by mutably f, but still
  // available anyway
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();

  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("hello world");
    let mut y = String::from("goodnight moon");

    // f needs to be mut because it mutates
    // its captured variables
    let mut f = || {
        x.push('!');
        y.push('!');
    };

    // x and y borrowed mutably by f, and so
    // can't be used here
    // println!("{}", x);
    // println!("{}", y);

    f();

    println!("{}", x);
    println!("{}", y);
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Copy <code>x</code> and <code>y</code> to capture by value</p>
</summary>
<p>In C++ this requires that the lambda have the <code>mutable</code> specifier. In Rust this
requires</p>
<ul>
<li>making a copy of the values for the closure to capture,</li>
<li>marking those copy as mutable with <code>mut</code>,</li>
<li>marking the closure itself as mutable with <code>mut</code>, and</li>
<li>using the <code>move</code> specifier to move ownership of the copies into the closure.</li>
</ul>
<p>Types that indicate they are <a href="idioms/constructors/copy_and_move_constructors.html#trivially-copyable-types">trivially copyable by implementing the <code>Copy</code>
trait</a> do
not need to be explicitly cloned.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [=]() mutable {
    x.push_back('!');
    y.push_back('!');
  };

  // copies of x and y owned by f, originals
  // still available
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();

  // still don't have the !, since the copies
  // were modified not the originals
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    let mut f = {
        // Shadow outer variables with copies.
        // This needs to happen outside of the
        // closure expression.
        let mut x = x.clone();
        let mut y = y.clone();
        move || {
            x.push('!');
            y.push('!');
        }
    };

    // clones of x and y owned by f, originals
    // still available
    println!("{}", x);
    println!("{}", y);

    f();

    // still don't have the !, since the copies
    // were modified not the originals
    println!("{}", x);
    println!("{}", y);
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Move <code>x</code> and <code>y</code> to capture by value</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [x = std::move(x),
            y = std::move(y)]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x and y moved into f,
  // empty strings left behind.
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from("hello world");
    let y = String::from("goodnight moon");

    // captures x and y by value
    let f = move || {
        println!("{}", x);
        println!("{}", y);
    };

    // x and y moved into f,
    // original variables cannot be used
    // println!("{}", x);
    // println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<details>
<summary>
<p>Move <code>x</code> to capture by value, capture <code>y</code> by reference</p>
</summary>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string x("hello world");
  std::string y("goodnight moon");

  auto f = [x = std::move(x), &amp;y]() mutable {
    x.push_back('!');
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    std::cout &lt;&lt; y &lt;&lt; std::endl;
  };

  // x moved into f, y borrowed by f
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; y &lt;&lt; std::endl;

  f();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from("hello world");
    let y = String::from("goodnight moon");

    let mut f = {
        let y = &amp;y;
        // Actually captures both x and y by
        // value, but y is a reference
        move || {
            x.push('!');
            println!("{}", x);
            println!("{}", y);
        }
    };

    // x moved into f, y borrowed by f
    // println!("{}", x);
    println!("{}", y);

    f();
}</code></pre></pre>
</div>
</details>
<h2 id="function-objects"><a class="header" href="#function-objects">Function objects</a></h2>
<p>Unlike in C++, in Rust only functions and closures implement the function call
operator traits. The ability to directly implement the traits is <a href="https://github.com/rust-lang/rust/issues/29625">not yet part
of stable Rust</a>.</p>
<p>Instead, one can implement a <a href="idioms/./user-defined_conversions.html">conversion
function</a>. The standard conversion traits <code>From</code>
and <code>Into</code> cannot be implemented for this purpose, however, because the <code>impl Trait</code> syntax cannot be used in trait implementations.<sup class="footnote-reference" id="fr-impl-trait-impl-1"><a href="#footnote-impl-trait-impl">1</a></sup> Instead
a separate method must be defined.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct MyClosure {
  std::string msg;

  std::size_t operator()() {
    std::cout &lt;&lt; msg &lt;&lt; std::endl;
    return msg.size();
  }
};

int main() {
  MyClosure myClosure{"hello world"};
  myClosure();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2024">struct MyClosure {
    msg: String,
}

impl MyClosure {
    fn as_fn(&amp;self) -&gt; impl Fn() -&gt; usize {
        move || {
            println!("{}", self.msg);
            self.msg.len()
        }
    }
}

fn main() {
    let my_closure = MyClosure {
        msg: String::from("hello world"),
    };
    let f = my_closure.as_fn();

    f();
}</code></pre></pre>
</div>
<p>In Rust editions earlier than 2024, the above example requires a precise
capturing annotation using the <a href="https://doc.rust-lang.org/std/keyword.use.html#precise-capturing"><code>use&lt;'a&gt;</code>
syntax</a> to
specify that the returned closure borrows from the parameters, since otherwise a
lifetime bound is not inferred.</p>
<h2 id="member-functions-as-function-pointers"><a class="header" href="#member-functions-as-function-pointers">Member functions as function pointers</a></h2>
<p>In C++, pointers to member functions can be invoked with the <code>.*</code> operator or
can be converted to <code>std::function</code> values using <code>std::mem_fn</code>, enabling them to
be used in the same way as other <code>std::function</code> values. When called on a
derived class, whether the method whose address was taken or the overriding
method in the derived class is called depends on whether the method is defined
as virtual.</p>
<p>In Rust pointers to member functions are normal function pointers. For example,
a method on a type <code>T</code> with a <code>&amp;self</code> parameter is a function whose first
argument has type <code>&amp;T</code>. When the method is named via a trait, then the first
argument of the function has type <code>&amp;dyn T</code> with a lifetime bound. Determining
whether vtables are involved in the use of a pointer to a member function is
determined at the time that the method is referenced, rather than when the
method is defined.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

struct Interface {
  virtual void showVirtual() = 0;
};

struct A : public Interface {
  void show() {
    std::cout &lt;&lt; "A" &lt;&lt; std::endl;
  }

  void showVirtual() override {
    std::cout &lt;&lt; "A" &lt;&lt; std::endl;
  }
};

struct B : public Interface {
  void showVirtual() override {
    std::cout &lt;&lt; "B" &lt;&lt; std::endl;
  }

  void show() {
    std::cout &lt;&lt; "B" &lt;&lt; std::endl;
  }
};

int main() {
  auto showV = &amp;Interface::showVirtual;
  auto showA = &amp;A::show;
  auto showB = &amp;B::show;

  A a;
  B b;

  (a.*showV)(); // prints A
  (b.*showV)(); // prints B

  (a.*showA)(); // prints A
  (b.*showB)(); // prints B
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Interface {
    fn show(&amp;self);
}

struct A;

impl Interface for A {
    fn show(&amp;self) {
        println!("A");
    }
}

struct B;

impl Interface for B {
    fn show(&amp;self) {
        println!("B");
    }
}

fn main() {
    // types could be inferred, but given to show
    // that they are just a function pointers
    let show_a: fn(&amp;A) = A::show;
    let show_b: fn(&amp;B) = B::show;
    let show_v: fn(&amp;(dyn Interface + 'static)) =
        Interface::show;

    show_a(&amp;A); // prints A
    show_b(&amp;B); // prints B

    show_v(&amp;A); // prints A
    show_v(&amp;B); // prints B
}</code></pre></pre>
</div>
<h2 id="closures-as-parameters"><a class="header" href="#closures-as-parameters">Closures as parameters</a></h2>
<p>In both C++ and Rust, unboxed closures can be accepted as parameters. Just as
using <code>auto</code> as the type of a parameter in C++ makes the function actually a
function template, using <code>impl Trait</code> as the type of a parameter in Rust makes
the function generic. <a href="idioms/data_modeling/concepts.html#templates-vs-generic-functions">The resulting generic function is checked statically,
just like it would be if the type parameter and bound were given
explicitly.</a></p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int apply_to_0(auto f) {
  return f(0);
}

int main() {
  int x = 1;
  auto f([=](int n) { return n + x; });
  std::cout &lt;&lt; apply_to_0(f) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn apply_to_0(f: impl FnOnce(i32) -&gt; i32) -&gt; i32 {
    f(0)
}

fn main() {
    let x = 1;
    let f = move |n: i32| x + n;
    println!("{}", apply_to_0(&amp;f));
}</code></pre></pre>
</div>
<p>When accepting closures as type parameters in Rust, it is best practice to
specify the type as the the least restrictive interface required for how the
closure will be used.</p>
<p>Using <code>FnOnce</code> as the bound is the least restrictive, and so should be used so
that the function accepting a closure as a parameter is as compatible with as
many closures as possible . <code>FnOnce</code> works with <code>Fn</code> and <code>FnMut</code> because there
are <code>FnOnce</code> trait implementations for <code>&amp;Fn</code> and <code>&amp;FnMut</code>. The <code>FnMut</code> trait is
the next most restrictive, followed by <code>Fn</code>, and then actual function pointers,
whose types are written with a lowercase <code>fn</code>.</p>
<p>In both C++ and Rust, it is also possible to pass references or pointers to closures. In
the following example, the closure is in dynamically allocated storage in both
C++ and in Rust.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

int apply_to_0(std::function&lt;int(int)&gt; f) {
  return f(0);
}

int main() {
  int x = 1;
  // closure is on heap
  auto f(std::function(
      [=](int n) { return n + x; }));
  std::cout &lt;&lt; apply_to_0(f) &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn apply_to_0(f: Box&lt;dyn FnOnce(i32) -&gt; i32&gt;) -&gt; i32 {
    f(0)
}

fn main() {
    let x = 1;
    let f = Box::new(move |n: i32| x + n);
    println!("{}", apply_to_0(f));
}</code></pre></pre>
</div>
<p><code>FnOnce</code> can be called when in a <code>Box</code>, because the box owns the trait object,
but not when in a reference which doesn't. <code>Fn</code> and <code>FnMut</code> do not have the same
restriction.</p>
<h2 id="returning-closures"><a class="header" href="#returning-closures">Returning closures</a></h2>
<p>In C++, <code>auto</code> or <code>decltype(auto)</code> can be used as the return type for a function
returning a closure. In Rust, once again the <code>impl Trait</code> syntax can be used.
Just as how in C++ using <code>auto</code> in this way does not denote an abbreviated
function template, it does not denote a generic function in Rust. Instead the
type is inferred, and must satisfy the trait.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

decltype(auto) makeConst(int n) {
  return [n]() { return n; };
}

int main() {
  auto f = makeConst(42);
  std::cout &lt;&lt; f() &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn make_const(n: i32) -&gt; impl Fn() -&gt; i32 {
    move || n
}

fn main() {
    let f = make_const(42);
    println!("{}", f());
}</code></pre></pre>
</div>
<p>In places in C++ where <code>decltype</code> is used to name the closure, e.g., when
returning a closure in a template class, in Rust the <code>impl Trait</code> syntax is
used. If a type needs to be given in a let binding, then an underscore <code>_</code> can
be used to indicate that the part of the type that is the closure's type should
be inferred.</p>
<pre><pre class="playground"><code class="language-rust">struct Wrapper&lt;T&gt;(T);

fn make_closure() -&gt; Wrapper&lt;impl Fn(i32) -&gt; i32&gt;
{
    let x = 1;
    Wrapper(move |n: i32| x + n)
}

fn main() {
    let w: Wrapper&lt;_&gt; = make_closure();
    w.0(0);
}</code></pre></pre>
<p>There are several other places where <code>decltype</code> works but <code>impl Trait</code> does not
yet, such as <a href="https://github.com/rust-lang/rust/issues/99697">the output type for <code>Fn</code>
traits</a>. This means that one can
define closures that return closures in Rust, but cannot give them a type, and
therefore cannot return them from functions. The following compiles in C++ but
fails to compile in Rust for that reason.</p>
<div class="comparison">
<pre><code class="language-cpp">decltype(auto) makeClosure(int n) {
  return [n]() { return [n]() { return n; }; };
}
</code></pre>
<pre><code class="language-rust ignore">// Does not compile: not yet supported
fn make_closure(
    n: i32,
) -&gt; impl Fn() -&gt; impl Fn() -&gt; i32 {
    move || move || n
}</code></pre>
</div>
<h2 id="template-lambdas"><a class="header" href="#template-lambdas">Template lambdas</a></h2>
<p>Rust does not support generic closures. Thus, the following has no equivalent in
Rust.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  int n = 0;

  auto idCounter = [&amp;]&lt;typename T&gt;(T x) {
    n++;
    return x;
  };

  int y = idCounter(5);
  std::string z =
      idCounter.template operator()&lt;std::string&gt;(std::string("hi"));
}
</code></pre>
<p>However, if the lambda doesn't capture anything, it is possible to write the
following equivalent in Rust, by using an inner function definition.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
  auto id = []&lt;typename T&gt;(T x) { return x; };
  int y = id(5);
  std::string z = id(std::string("hi"));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn id&lt;T&gt;(x: T) -&gt; T {
        x
    }

    id(5);
    id(String::from("hi"));
}</code></pre></pre>
</div>
<h2 id="partial-application-and-stdbind"><a class="header" href="#partial-application-and-stdbind">Partial application and <code>std::bind</code></a></h2>
<p>There is no equivalent to the C++ template <code>std::bind</code> in the Rust standard
library. The idiomatic way to express partial application in Rust is to write
out the lambda.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;functional&gt;

int add(int x, int y) {
  return x + y;
}

int main() {
  using namespace std::placeholders;

  auto addTen = std::bind(add, 10, _1);
  assert(42 == addTen(32));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

fn main() {
    let add_ten = move |y| add(10, y);
    assert_eq!(42, add_ten(32));
}</code></pre></pre>
</div>
<p>The third-party crate
<a href="https://docs.rs/partial_application/latest/partial_application/">partial_application</a>
provides something akin to <code>std::bind</code> using Rust macros.</p>
<pre><code class="language-rust ignore">use partial_application::*;

fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

fn main() {
    let add_ten = partial!(move add =&gt; 10, _);

    assert_eq!(42, add_ten(32));
}</code></pre>
<h2 id="returning-references-to-captured-variables"><a class="header" href="#returning-references-to-captured-variables">Returning references to captured variables</a></h2>
<p>In Rust it is not possible to have a closure return a reference to a captured
variable. This is due to a limitation with how the <code>Fn</code> family of traits are
defined: <code>Fn::Output</code> does not have a way to express a lifetime bound.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  std::string msg("hello world");
  auto f = [=]() -&gt; const std::string &amp; {
    return msg;
  };
  std::cout &lt;&lt; f() &lt;&lt; std::endl;
}
</code></pre>
<pre><code class="language-rust ignore">fn main() {
    let msg = String::from("hello world");
    // fails to compile!
    let f = move || &amp;msg;

    println!("{}", f());
}</code></pre>
</div>
<p>The workarounds to this limitation in Rust involve either heap-allocating and
using a shared pointer <code>Rc</code>, or defining a new trait instead of using one of the
<code>Fn</code> traits. The following example shows a trait that uses <a href="https://doc.rust-lang.org/reference/items/associated-items.html#r-items.associated.type.generic">generic associated types</a> to define a generalized
<code>Fn</code> trait. In practice, however, it is usually better either to
define a custom trait for each use case or to elide the trait entirely if a
single struct is sufficient.</p>
<pre><pre class="playground"><code class="language-rust">trait Closure&lt;Args&gt; {
    // The lifetime parameter enables expressing
    // the bound.
    type Output&lt;'a&gt;
    where
        Self: 'a;

    // The bound from self can then be
    // provided to Output.
    fn call&lt;'a&gt;(
        &amp;'a self,
        args: Args,
    ) -&gt; Self::Output&lt;'a&gt;;
}

struct MyClosure {
    msg: String,
}

impl Closure&lt;()&gt; for MyClosure {
    type Output&lt;'a&gt; = &amp;'a str;

    fn call(&amp;self, _: ()) -&gt; &amp;str {
        &amp;self.msg
    }
}

fn main() {
    let f = MyClosure {
        msg: String::from("hello world"),
    };

    println!("{}", f.call(()));
}</code></pre></pre>
<h2 id="closures-ownership-and-fnonce"><a class="header" href="#closures-ownership-and-fnonce">Closures, ownership, and <code>FnOnce</code></a></h2>
<p>Closures are a part of Rust where the borrow checker is likely to cause
frustration for a C++ programmer. This is usually not because of lifetimes,
which have to be similarly considered in C++, but rather because C++ defaults to
copy semantics while Rust defaults to move semantics. For example, this small
adjustment to one of the earlier examples fails to compile.</p>
<pre><code class="language-rust ignore">fn main() {
    let greeting = "hello ".to_string();

    // Can't write the type of the closure
    let say_hello_to = move |who: &amp;str| {
        greeting + who
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre>
<p>This fails to compile because the <code>+</code> operator takes ownership of <code>greeting</code>,
which makes it no longer accessible for later invocations. Because of this, the
closure only implements <code>FnOnce</code>, not <code>Fn</code>, and therefore can only be called
once, because the call takes ownership of the closure itself.</p>
<pre><code class="language-text">error[E0382]: use of moved value: `say_hello_to`
 --&gt; example.rs:9:20
  |
8 |     println!("{}", say_hello_to("world"));
  |                    --------------------- `say_hello_to` moved due to this call
9 |     println!("{}", say_hello_to("moon"));
  |                    ^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `greeting` out of its environment
 --&gt; example.rs:6:26
  |
6 |         move |who: &amp;str| greeting + who;
  |                          ^^^^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; example.rs:8:20
  |
8 |     println!("{}", say_hello_to("world"));
  |
</code></pre>
<p>In many cases like this, the answer is to clone the value so that the copy owned
by the closure can be retained for future invocations.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = "hello ".to_string();

    // Can't write the type of the closure
    let say_hello_to = move |who: &amp;str| {
        greeting.clone() + who
    };

    println!("{}", say_hello_to("world"));
    println!("{}", say_hello_to("moon"));
}</code></pre></pre>
<p>If cloning isn't desired because it is too expensive, then the closure needs to
be redesigned to avoid giving away ownership of its captured variables.</p>
<h2 id="documentation-best-practices"><a class="header" href="#documentation-best-practices">Documentation best practices</a></h2>
<p>C++ often recommended to explicitly list captures in a lambda expression,
especially in situations where a closure will outlive its context. The purpose
of this is to assist in reasoning about the lifetimes of the captures to ensure
that the closure does not outlive any of the objects it has captured.</p>
<p>In Rust, the same decisions about captures with respect to lifetimes have to be
made, but the compiler tracks them instead of having to do the reasoning
manually. That is, in spite of the type of the closure not being expressible, it
does still include the lifetimes of variables captured by reference, and so is
checked the same way that any other structure would be.</p>
<p>This results in the best practices for documenting closures in Rust not
including enumerating captures, even in situations where one would do so in C++.</p>
<p>The same is true about the destructibility of the content of the captures in a
closure. The example involving <code>FnOnce</code> functions in <a href="idioms/closures.html#closures-ownership-and-fnonce">the previous
section</a> may be a point of frustration
initially, but the behavior has the benefit of reducing the documentation and reasoning
burdens.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;closures&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The compiler will actually infer the equivalent problem that the closure is\n`FnMut` and then state that captured variables cannot be moved out of a `FnMut`\nclosure.\n\nThe way to fix the problem depends on whether the closure needs to return owned\n`String` values, or if `&amp;str` is enough. In the latter case, the closure can be\n`|_| &amp;s` instead. In the former case, the closure needs to return a clone of\n`s`.\n&quot;,&quot;id&quot;:&quot;15d61c38-0bd1-45eb-bb2f-db9d357995e3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program does not compile because the `|_| s` is a `FnOnce` closure, but\n`map` takes a `FnMut` closure.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The program compiles.\n&quot;,&quot;The program does not compile because `|_| s` is a `FnOnce` closure, but is\ncalled 10 times because the range is `0..10`.\n&quot;],&quot;prompt&quot;:&quot;Does the following Rust program compile? If not, why not?\n\n```rust\nfn main() {\n    let s = String::from(\&quot;hi\&quot;);\n\n    for x in (0..10).map(|_| s) {\n        println!(\&quot;{}\&quot;, x);\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Because `i32` implements the `Copy` trait, returning `n` implicitly copies `n`,\nmaking the closure a `Fn` closure instead of a `FnOnce` closure. `Fn` closures\nimplement `FnMut`, and so can be used with `map`.\n&quot;,&quot;id&quot;:&quot;798f623e-0802-4b29-8516-09d443dbb7e8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program compiles.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The program does not compile because the `|_| s` is a `FnOnce` closure, but\n`map` takes a `FnMut` closure.\n&quot;,&quot;The program does not compile because `|_| s` is a `FnOnce` closure, but is\ncalled 10 times because the range is `0..10`.\n&quot;],&quot;prompt&quot;:&quot;Does the following Rust program compile? If not, why not?\n\n```rust\nfn main() {\n    let n: i32 = 42;\n\n    for x in (0..10).map(|_| n) {\n        println!(\&quot;{}\&quot;, x);\n    }\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><hr>
<ol class="footnote-definition"><li id="footnote-impl-trait-impl">
<p>That is, one can write neither <code>impl From&lt;&amp;MyClosure&gt; for impl Fn() -&gt; usize {...}</code> nor <code>impl Into&lt;impl Fn() -&gt; usize&gt; for &amp;MyClosure {...}</code>. <a href="#fr-impl-trait-impl-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="object-identity"><a class="header" href="#object-identity">Object identity</a></h1>
<p>In C++ the pointer to an object is sometimes used to represent its identity in
terms of the logic of a program.</p>
<p>In some cases, this is a standard optimization, such as when implementing the
copy assignment operator.</p>
<p>In other cases the pointer value is used as a logical identity to distinguish
between specific instances of an object that otherwise have the same properties.
For example, representing a labeled graph where there may be distinct nodes that
have the same label.</p>
<p>In Rust, some of these cases are not applicable, and others cases are typically
handled by instead by implementing a synthetic notion of identity for the
values.</p>
<h2 id="overloading-copy-assignment-and-equality-comparison-operators"><a class="header" href="#overloading-copy-assignment-and-equality-comparison-operators">Overloading copy assignment and equality comparison operators</a></h2>
<p>For example, when implementing the copy-assignment operator, one might
short-circuit when the copied object and the assignee are the same.
Note that in this use the pointer values are not stored.</p>
<p>This kind of optimization is unnecessary when implementing <a href="idioms/./constructors/copy_and_move_constructors.html#assignment-operators">Rust's equivalent to
the copy assignment
operator</a>
<code>Clone::clone_from</code>. The type of <code>Clone::clone_from</code> prevents the same object
from being passed as both arguments, because one of the arguments is a mutable
reference, which is exclusive, and so prevents the other reference argument from
referring to the same object.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Person
{
    std::string name;
    // many other expensive-to-copy fields

    Person&amp; operator=(const Person&amp; other) {
        // compare object identity first
        if (this != &amp;other) {
            this.name = other.name;
            // copy the other expensive-to-copy fields
        }

        return *this;
    }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}

impl Clone for Person {
    fn clone(&amp;self) -&gt; Self {
        Self { name: self.name.clone() }
    }

    fn clone_from(&amp;mut self, source: &amp;Self) {
        // self and source cannot be the same here,
        // because that would mean there are a
        // mutable and an immutable reference to
        // the same memory location. Therefore, a
        // check for assignment to self is not
        // needed, even for the purpose of
        // optimization.

        self.name.clone_from(&amp;source.name);
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In cases in C++ where most comparisons are between an object and itself (e.g.,
the object's primary use is to be stored in a hash set), and comparison of
unequal objects is expensive, comparing object identity might be used as
optimization for the equality comparison operator overload.</p>
<p>For supporting similar operations in Rust,
<a href="https://doc.rust-lang.org/std/ptr/fn.eq.html"><code>std::ptr::eq</code></a> can be used.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Person
{
    std::string name;
    // many other expensive-to-compare fields
};


bool operator==(const Person&amp; lhs, const Person&amp; rhs) {
    // compare object identity first
    if (&amp;lhs == &amp;rhs) {
        return true;
    }

    // compare the other expensive-to-compare fields

    return true;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    // many other expensive-to-compare fields
}

impl PartialEq for Person {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if std::ptr::eq(self, other) {
            return true;
        }
        // compare other expensive-to-compare fields

        true
    }
}

impl Eq for Person {}
<span class="boring">}</span></code></pre></pre>
</div>
<h2 id="distinguishing-between-values-in-a-relational-structure"><a class="header" href="#distinguishing-between-values-in-a-relational-structure">Distinguishing between values in a relational structure</a></h2>
<p>The other use is when relationships between values are represented using a data
structure external to the values, such as when representing a labeled graph in
which multiple nodes might share the same label, but have edges between
different sets of other nodes. This differs from the earlier case because the
pointer value is preserved.</p>
<p>One real-world example of this is in the LLVM codebase, where occurrences of
declarations, statements, and expressions in the AST are distinguished by object
identity. For example, variable expressions (<code>class DeclRefExpr</code>) contain the
<a href="https://github.com/llvm/llvm-project/blob/ddc48fefe389789f64713b5924a03fb2b7961ef3/clang/include/clang/AST/Expr.h#L1265C1-L1275C16">pointer to the occurrence of the declaration to which the variable
refers</a>.</p>
<p>Similarly, when comparing whether two variable declarations represent
declarations of the same variable, <a href="https://github.com/llvm/llvm-project/blob/aa33c095617400a23a2b814c4defeb12e7761639/clang/lib/AST/Stmt.cpp#L1476-L1485">a pointer to some canonical <code>VarDecl</code> is
used</a>:</p>
<pre><code class="language-cpp">VarDecl *VarDecl::getCanonicalDecl();

bool CapturedStmt::capturesVariable(const VarDecl *Var) const {
  for (const auto &amp;I : captures()) {
    if (!I.capturesVariable() &amp;&amp; !I.capturesVariableByCopy())
      continue;
    if (I.getCapturedVar()-&gt;getCanonicalDecl() == Var-&gt;getCanonicalDecl())
      return true;
  }

  return false;
}
</code></pre>
<p>This kind of use is often discouraged in C++ because of the risk of
use-after-free bugs, but might be used in performance sensitive applications
where either storing the memory to represent the mapping or the additional
indirection to resolve an entity's value from its identity is cost prohibitive.</p>
<p>In Rust it is generally preferred to represent the identity of the objects with
synthetic identifiers. This is in part as a technique for modeling
self-referential data structures.</p>
<p>As an example, one popular Rust graph library
<a href="https://docs.rs/petgraph/latest/petgraph/">petgraph</a> uses <code>u32</code> as its default
node identity type. This incurs the cost of an extra call to dereference the
synthetic identifier to the label of the represented node as well as the extra
memory required to store the mapping from nodes to labels.</p>
<p>A simplified graph representation using the same synthetic identifier technique
would look like the following, which represents the node identities by their
index in the vectors that represent the labels and the edges.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Blue
}

struct Graph {
    /// Maps from node id to node labels, which here are colors.
    nodes_labels: Vec&lt;Color&gt;,

    /// Maps from node id to adjacent nodes ids.
    edges: Vec&lt;Vec&lt;usize&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If performance requirements make the use of synthetic identifiers unacceptable,
then it may be necessary to use prevent the value from being moved. The <a href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code>
and <code>PhantomPinned</code> structs</a> can
be used to achieve an effect similar to deleting the move constructor in C++.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;object_identity&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;9f8a464a-6fbb-4352-815a-7a42d162f9fd&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Because because `self` is a mutable reference, the borrow checker ensures that\n`source` can't be a reference to the same memory location.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Because `std::ptr::mem` is unsafe Rust.\n&quot;,&quot;Because the compiler will add the check when optimizing anyway.\n&quot;],&quot;prompt&quot;:&quot;Why is the check for self-assignment in `clone_from` not idiomatic Rust?\n\n```rust\nstruct LargeStruct {\n    field1: String,\n    // ...\n    field100: String,\n}\n\nimpl Clone for LargeStruct {\n    fn clone(&amp;self) -&gt; Self {\n        Self {\n            field1: self.field1.clone(),\n            // ...\n            field100: self.field100.clone(),\n        }\n    }\n\n    fn clone_from(&amp;mut self, source: &amp;Self) {\n        if std::ptr::eq(self, source) {\n            return;\n        }\n\n        self.field1.clone_from(&amp;source.field1);\n        // ...\n        self.field100.clone_from(&amp;source.field100);\n    }\n}\n```\n&quot;}},{&quot;id&quot;:&quot;d60a321a-3b38-4425-8a9a-6b95fe0e3837&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Synthetic identifiers are easier to use for forming self-referential structures.\n&quot;,&quot;Synthetic identifiers avoid the complexity of using `Pin` to prevent values from\nbeing moved.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;There is no way to access memory locations in Rust.\n&quot;,&quot;Comparing memory locations requires unsafe Rust.\n&quot;],&quot;prompt&quot;:&quot;Which are reasons why in Rust synthetic identifiers are usually used instead of\nmemory location for object identity?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="out-parameters"><a class="header" href="#out-parameters">Out parameters</a></h1>
<p>There are several idioms in C++ that involve the use of out parameters: passing
pointers or references to functions for the function to mutate to provide its
results.</p>
<p>The chapters in this section address idiomatic ways to achieve the same goals
that out parameters are used for in C++. Many of the Rust idioms resemble the
recommended alternatives to out parameters when programming against newer C++
standards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h1>
<p>One idiom for returning multiple values from a function or method in C++ is to
pass in references to which the values can be assigned.</p>
<p>There are several reasons why this idiom might be used:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, or</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic translation of this program into Rust makes use of either
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> or a named
structure for the return type.</p>
<div class="comparison">
<pre><code class="language-cpp">void get_point(int &amp;x, int &amp;y) {
  x = 5;
  y = 6;
}

int main() {
  int x, y;
  get_point(x, y);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn get_point() -&gt; (i32, i32) {
    (5, 6)
}

fn main() {
    let (x, y) = get_point();
    // ...
}</code></pre></pre>
</div>
<p>Rust has a dedicated tuple syntax and supports pattern matching with <code>let</code>
bindings in part to support use cases like this one.</p>
<h2 id="problems-with-the-direct-transliteration"><a class="header" href="#problems-with-the-direct-transliteration">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but Rust requires the initialization of the variables before they can be
passed to a function. The resulting program is not idiomatic Rust.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOMATIC RUST
fn get_point(x: &amp;mut i32, y: &amp;mut i32) {
    *x = 5;
    *y = 6;
}

fn main() {
    let mut x = 0; // initialized to arbitrary values
    let mut y = 0;
    get_point(&amp;mut x, &amp;mut y);
    // ...
}</code></pre></pre>
<p>This approach requires assigning arbitrary initial values to the variables and
making the variables mutable, both of which make it harder for the compiler to
help with avoiding programming errors.</p>
<p>Additionally, the Rust compiler is tuned for optimizing the idiomatic version of
the program, and produces a significantly faster binary for that version.</p>
<p>In situations where the performance of memory allocation is a concern (such as
when it is necessary to reuse entire buffers in memory), the trade-offs may be
different. That situation is discussed in the chapter on <a href="idioms/out_params/./pre-allocated_buffers.html">pre-allocated
buffers</a>.</p>
<h2 id="similarities-with-idiomatic-c-since-c11"><a class="header" href="#similarities-with-idiomatic-c-since-c11">Similarities with idiomatic C++ since C++11</a></h2>
<p>In C++11 and later, <code>std::pair</code> and <code>std::tuple</code> are available for returning
multiple values instead of assigning to reference parameters.</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;utility&gt;

std::pair&lt;int, int&gt; get_point() {
  return std::make_pair(5, 6);
}

int main() {
  int x, y;
  std::tie(x, y) = get_point();
  // ...
}
</code></pre>
<p>This more closely aligns with the normal Rust idiom for returning multiple
values.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;multiple_return&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e30276-7ebe-499e-b8b0-4acfb815feaa&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n) -&gt; (&amp;[u8], &amp;[u8]);\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n) -&gt; (usize, usize);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    remaining: &amp;mut &amp;[u8],\n) -&gt; &amp;[u8];\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic translation of this C++ function\nsignature into a Rust function signature?\n\n```cpp\nvoid main() {}\n```\n\n```cpp\n#include &lt;cstdint&gt;\n\nvoid splitAt(std::uint8_t *data,\n             std::size_t dataSize,\n             std::size_t mid,\n             uint8_t **left,\n             std::size_t *leftSize,\n             uint8_t **right,\n             std::size_t *rightSize);\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="optional-return-values"><a class="header" href="#optional-return-values">Optional return values</a></h1>
<p>One idiom in C++ for optionally producing a result from a method or function is
to use a reference parameter along with a boolean or integer return value to
indicate whether the result was produced. This might be done for the same
reasons as for using <a href="idioms/out_params/./multiple_return.html">out parameters for multiple return
values</a>:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, and</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic Rust approach for optionally returning a value is to return a
value of type <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

bool safe_divide(unsigned int dividend,
                 unsigned int divisor,
                 unsigned int &amp;quotient) {
  if (divisor != 0) {
    quotient = dividend / divisor;
    return true;
  } else {
    return false;
  }
}

void go(unsigned int dividend,
        unsigned int divisor) {
  unsigned int quotient;
  if (safe_divide(dividend, divisor, quotient)) {
    std::cout &lt;&lt; quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn safe_divide(
    dividend: u32,
    divisor: u32,
) -&gt; Option&lt;u32&gt; {
    if divisor != 0 {
        Some(dividend / divisor)
    } else {
        None
    }
}

fn go(dividend: u32, divisor: u32) {
    match safe_divide(dividend, divisor) {
        Some(quotient) =&gt; {
            println!("{}", quotient);
        }
        None =&gt; {
            println!("Division failed!");
        }
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
</div>
<p>When there is useful information to provide in the failing case, the <a href="https://doc.rust-lang.org/std/result/"><code>Result</code>
type</a> can be used instead. The <a href="idioms/out_params/../exceptions.html">chapter
on error handling</a> describes the use of <code>Result</code>.</p>
<h2 id="returning-a-pointer"><a class="header" href="#returning-a-pointer">Returning a pointer</a></h2>
<p>When the value being returned is a pointer, another common idiom in C++ is to
use <code>nullptr</code> to represent the optional case. In the Rust translation of that
idiom, <code>Option</code> is also used, along with a reference type, such as <code>&amp;</code> or <code>Box</code>.
See <a href="idioms/out_params/../null/sentinel_values.html#nullptr">the chapter on using <code>nullptr</code> as a sentinel
value</a> for more details.</p>
<h2 id="problems-with-the-direct-transliteration-1"><a class="header" href="#problems-with-the-direct-transliteration-1">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but the resulting code is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOIMATIC RUST
fn safe_divide(dividend: u32, divisor: u32, quotient: &amp;mut u32) -&gt; bool {
    if divisor != 0 {
        *quotient = dividend / divisor;
        true
    } else {
        false
    }
}

fn go(dividend: u32, divisor: u32) {
    let mut quotient: u32 = 0; // initliazed to arbitrary value
    if safe_divide(dividend, divisor, &amp;mut quotient) {
        println!("{}", quotient);
    } else {
        println!("Division failed!");
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<p>This shares the same problems as with using out-parameters for <a href="idioms/out_params/./multiple_return.html#problems-with-the-direct-transliteration">multiple return
values</a>.</p>
<h2 id="similarities-with-c-since-c17"><a class="header" href="#similarities-with-c-since-c17">Similarities with C++ since C++17</a></h2>
<p>C++17 and later offer <code>std::optional</code>, which can be used to express optional
return values in a way similar to the idiomatic Rust example.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;optional&gt;

std::optional&lt;unsigned int&gt; safe_divide(unsigned int dividend,
                                        unsigned int divisor) {
  if (divisor != 0) {
    return std::optional&lt;unsigned int&gt;(dividend / divisor);
  } else {
    return std::nullopt;
  }
}

void go(unsigned int dividend, unsigned int divisor) {
  if (auto quotient = safe_divide(dividend, divisor)) {
    std::cout &lt;&lt; *quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<h2 id="helpful-option-utilities"><a class="header" href="#helpful-option-utilities">Helpful <code>Option</code> utilities</a></h2>
<p>Rust provides several syntactic sugars for simplifying use of functions that return <code>Option</code>. If a failure should be propagated to the caller, then use the <code>?</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: u32, divisor: u32) -&gt; Option&lt;()&gt; {
    let quotient = safe_divide(dividend, divisor)?;
    println!("{}", quotient);
    Some(())
}
<span class="boring">}</span></code></pre></pre>
<p>If <code>None</code> should not be propagated, it is sometimes clearer to use <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let-else</code>
syntax</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: u32, divisor: u32) {
    let Some(quotient) = safe_divide(dividend, divisor) else {
        println!("Division failed!");
        return;
    };
    println!("{}", quotient);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>If there is a default value that should be used in the <code>None</code> case, the
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>Option::unwrap_or</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option::unwrap_or_else</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>,
or
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
methods can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn expensive_computation() -&gt; u32 {
    // ...
<span class="boring">   0
</span>}

fn go(dividend: u32, divisor: u32) {
    // If None, returns the given value.
    let result = safe_divide(dividend, divisor).unwrap_or(0);

    // If None, returns the result of calling the given function.
    let result2 = safe_divide(dividend, divisor).unwrap_or_else(expensive_computation);

    // If None, returns Default::default(), which is 0 for u32.
    let result3 = safe_divide(dividend, divisor).unwrap_or_default();

    // If None, panics. Prefer the other methods!
    // let result3 = safe_divide(dividend, divisor).unwrap();
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>In performance-sensitive code where you have manually checked that the result is
guaranteed to be <code>Some</code>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_unchecked"><code>Option::unwrap_unchecked</code></a>
can be used, but is an unsafe method.</p>
<p>There are <a href="https://doc.rust-lang.org/std/option/#boolean-operators">additional utility
methods</a> that enable
concise handling of <code>Option</code> values, which this book covers in the chapter on
<a href="idioms/out_params/../exceptions.html">exceptions and error handling</a>.</p>
<h2 id="an-alternative-approach"><a class="header" href="#an-alternative-approach">An alternative approach</a></h2>
<p>An alternative approach in Rust to returning optional values is to require that
the caller of a function prove that the value with which they call a function
will not result in the failing case.</p>
<p>For the above safe division example, this involves the caller guaranteeing that
the provided divisor is non-zero. In the following example this is done with a
dynamic check. In other contexts the evidence needed may be available
statically, provided from callers further upstream, or used more than once. In
those cases, this approach reduces both runtime cost and code complexity.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::num::NonZero;

fn safe_divide(dividend: u32, divisor: NonZero&lt;u32&gt;) -&gt; u32 {
    // This is more efficient because the overflow check is skipped.
    dividend / divisor
}

fn go(dividend: u32, divisor: u32) {
    let Ok(safe_divisor) = NonZero::try_from(divisor) else {
        println!("Can't divide!");
        return;
    };

    let quotient = safe_divide(dividend, safe_divisor);
    println!("{}", quotient);
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;optional_return&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;6471e372-6552-41e9-88c6-7b7f6665928e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) -&gt; Option&lt;&amp;'a mut [u8]&gt; {\n    if buf1.len() &gt;= needed_len {\n        Some(buf1)\n    } else if buf2.len() &gt;= needed_len {\n        Some(buf2)\n    } else {\n        None\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut &amp;'a mut [u8],\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) {\n    if buf1.len() &gt;= needed_len {\n        *buffer = buf1;\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = buf2;\n    }\n}\n```\n&quot;,&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut &amp;'a mut [u8],\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) -&gt; bool {\n    if buf1.len() &gt;= needed_len {\n        *buffer = buf1;\n        return true;\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = buf2;\n        return true;\n    }\n\n    return false;\n}\n```\n&quot;,&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut Option&lt;&amp;'a mut [u8]&gt;,\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) {\n    if buf1.len() &gt;= needed_len {\n        *buffer = Some(buf1);\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = Some(buf2);\n    } else {\n        *buffer = None;\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic translation of C++ function into\nRust?\n\n```cpp\n#include &lt;cstdint&gt;\n\nvoid chooseBuffer(std::size_t neededLen,\n                  std::uint8_t **buffer,\n                  std::size_t *bufferLen,\n                  uint8_t *buf1,\n                  std::size_t buf1Len,\n                  uint8_t *buf2,\n                  std::size_t buf2Len) {\n\tif (buf1Len &gt;= neededLen) {\n\t\t*buffer = buf1;\n\t\t*bufferLen = buf1Len;\n\t} else if (buf2Len &gt;= neededLen) {\n\t\t*buffer = buf2;\n\t\t*bufferLen = buf2Len;\n\t} else {\n\t\t*buffer = nullptr;\n\t\t*bufferLen = 0;\n\t}\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="pre-allocated-buffers"><a class="header" href="#pre-allocated-buffers">Pre-allocated buffers</a></h1>
<p>There are situations where large quantities of data need to be returned from a
function that will be called repeatedly, so that incurring the copies involved
in returning by value or repeated heap allocations would be cost prohibitive.
Some of these situations include:</p>
<ul>
<li>performing file or network IO,</li>
<li>communicating with graphics hardware,</li>
<li>communicating with hardware on embedded systems, or</li>
<li>implementing cryptography algorithms.</li>
</ul>
<p>In these situations, C++ programs tend to pre-allocate buffers that are reused
for all calls. This also usually enables allocating the buffer on the stack,
rather than having to use dynamic storage.</p>
<p>The following example pre-allocates a buffer and reads a large file into it
within a loop.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;fstream&gt;

int main() {
  std::ifstream file("/path/to/file");
  if (!file.is_open()) {
    return -1;
  }

  byte buf[1024];
  while (file.good()) {
    file.read(buf, sizeof buf);
    std::streamsize count = file.gcount();

    // use data in buf
  }

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{BufReader, Read};

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut f = BufReader::new(File::open(
        "/path/to/file",
    )?);

    let mut buf = [0u8; 1024];

    loop {
        let count = f.read(&amp;mut buf)?;
        if count == 0 {
            break;
        }

        // use data in buf
    }

    Ok(())
}</code></pre></pre>
</div>
<p>The major difference between the C++ program and the Rust program is that in the
Rust program the buffer must be initialized before it can be used. In most
cases, this one-time initialization cost is not significant. When it is, unsafe
Rust is required to avoid the initialization.</p>
<p>The technique for avoiding initialization makes use of
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>std::mem::MaybeUninit</code></a>.
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#examples">Examples of safe usage of
<code>MaybeUninit</code></a>
are given in the API documentation for the type.</p>
<p>The IO API in stable Rust does not include support for <code>MaybeUninit</code>. Instead,
there is a <a href="idioms/out_params/pre-allocated_buffers.html#upcoming-changes-and-borrowedbuf">new safe API being developed</a>
that will enable avoiding initialization without requiring unsafe Rust in code
that uses the API.</p>
<p>If the callee might need to grow the provided buffer and dynamic allocation is
allowed, then a <code>&amp;mut Vec&lt;T&gt;</code> can be used instead of <code>&amp;mut [T]</code>. This is similar
to providing a <code>std::vector&lt;T&gt;&amp;</code> in C++. To avoid unnecessary reallocation, the
vector can be created using <code>Vec::&lt;T&gt;::with_capacity(n)</code>.</p>
<h2 id="a-note-on-reading-files"><a class="header" href="#a-note-on-reading-files">A note on reading files</a></h2>
<p>While the examples here use IO to demonstrate re-using pre-allocated buffers,
there are higher-level interfaces available for reading from <code>File</code>s, both from
the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> traits, and
from convenience functions in
<a href="https://doc.rust-lang.org/std/io/index.html#functions-1"><code>std::io</code></a> and in
<a href="https://doc.rust-lang.org/std/fs/index.html#functions-1"><code>std::fs</code></a>.</p>
<p>The techniques described here are useful, however, in other situations where a
reusable buffer is required, such as when interacting with hardware APIs, when
using existing C or C++ libraries, or when implementing algorithms that produce
larges amount of data in chunks, such as cryptography algorithms.</p>
<h2 id="upcoming-changes-and-borrowedbuf"><a class="header" href="#upcoming-changes-and-borrowedbuf">Upcoming changes and <code>BorrowedBuf</code></a></h2>
<p>The Rust community is refining approaches to working with uninitialized buffers.
On the nightly branch of Rust, one can use
<a href="https://doc.rust-lang.org/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a> to
achieve the same results as when using slices of <code>MaybeUninit</code>, but without
having to write any unsafe code. The IO APIs for avoiding unnecessary
initialization use <code>BorrowedBuf</code> instead of slices of <code>MaybeUninit</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;pre-allocated_buffers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;5b23f54f-b4a2-46f5-87b4-5551a2c93be8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nlet mut buf = [0u8; 1024];\n\nwhile let Some(count) = fetch(&amp;mut buf) {\n    // use data in buf\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nlet mut buf;\n\nwhile let Some(count) = fetch(&amp;mut buf) {\n    // use data in buf\n}\n```\n&quot;,&quot;```rust\nloop {\n    let mut buf = [0u8; 1024];\n    let Some(count) = fetch(&amp;mut buf) else {\n        break;\n    };\n    // use data in buf\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic way in Rust to use the following\nfunction?\n\n```rust\n/// Fetches data into the given buffer. Returns the number of bytes populated,\n/// or `None` when the end of the data is reached. The contents of `buf` will\n/// not be read.\nfn fetch(buf: &amp;mut [u8]) -&gt; Option&lt;usize&gt;\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-c-interoperability-ffi"><a class="header" href="#rust-and-c-interoperability-ffi">Rust and C++ interoperability (FFI)</a></h1>
<p>The Rustonomicon <a href="https://doc.rust-lang.org/nomicon/ffi.html">contains a
chapter</a> covering many of the
concerns relevant to a C++ programmer that wants to call C (or C++ via <code>extern "C"</code> functions) from Rust or Rust from C or C++ code.</p>
<p>Many C libraries have existing crates, both with low-level bindings and with
high-level safe Rust abstractions. For example, for the libgit2 library there is
both a low-level <a href="https://crates.io/crates/libgit2-sys">libgit2-sys crate</a> and a
high-level <a href="https://crates.io/crates/git2">git2 crate</a>.</p>
<p>Bindings to libraries can be generated from a C header file using
<a href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nrvo-and-rvo"><a class="header" href="#nrvo-and-rvo">NRVO and RVO</a></h1>
<div class="warning">
<p>Some of the statements about Rust in this chapter are dependent on the specifics
of how the compiler optimizes various programs. Unless otherwise state, the
results presented here are based on rustc 1.87 using the <a href="https://doc.rust-lang.org/edition-guide/introduction.html">2024 language
edition</a> and with
<code>-O2</code> for C++ and <code>--opt-level=2</code> for Rust.</p>
</div>
<p>Unlike C++, Rust does not guarantee return value optimization (RVO). Neither
language guarantees named return value optimization (NRVO). However, RVO and
NRVO are usually applied in Rust where they would be in C++.</p>
<h2 id="rvo"><a class="header" href="#rvo">RVO</a></h2>
<p>The pattern where RVO and NRVO are likely most important is in static factory
methods (which Rust calls <a href="idioms/./constructors.html">constructor methods</a>). In the
following example, C++17 and later guarantee RVO. In Rust the optimization is
performed reliably, but is not guaranteed.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Widget {
    signed char x;
    double y;
    long z;
};

Widget make(signed char x, double y, long z) {
    return Widget{x, y, z};
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Widget {
    x: i8,
    y: f64,
    z: i64,
}

impl Widget {
    fn new(x: i8, y: f64, z: i64) -&gt; Self {
        Widget { x, y, z }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>One can see in <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyahSAVyVFyKxqiIEh1ZpgDC6embZMQANnLOAGQImbAA5TwAjbFIpAFZyAAd0JWIHJjcPL19E5NShIJDwtiiYnnibbDs0kSIWUiIMz28/CqqhGrqiArDI6LjrWvrGrJbBruCe4r6ygEprdDNSVE4uS3M7AGoAdQJMYGwiDYBSAHYAISOtAEEN243NDYIADnJLm7uATxANmh9ZN7uGwAXt8CH9XtdTgARN5vAhsBL0ba7faHU4Xa6Ao4AJgAzEdYmczEwlCwaNgIEx0AB9NjGYCMGYEmGYu40JgbEIAdwgD2e5A2Xx%2B4OBoL%2BMw2AFojrjcMi9gdjucAYC7jsFWjlazVar1BD3jrAR99YbVUCTYboSrblbIScWVcuHN6NxYvxvFwdOR0NwAEoWQ5KBZLbDHPF8chEbROuYAaxAsWxADppD4TrEfLingBOHM8GS4wzcaT8NgJrTkD1en1cfhKEAVqOep3kOCwFAYHD4YhkSjUOiMVgcbgRwTCMQSTgyOTCZRqTTN8j6bGGeloHEXbFnazYWz2RwQZzDbwrwITIolEDZnIpffpdxNEArpK3tLdC99a%2BtO8dIYPrI8Due7VGM769KUAydMeBiWJ0YFTKUcxBosyzcGsZibOqqJKhiBobCkwAhJgGyoEgdT3DKuGApgCwRIwgqUdaGz0EIwDAoxdowriuFvNg6hENEHJYYqdKxhSBFESRZGkPcAo0WYdGhsazGscCErokxpAHIsQkogc6J6oKApAla3GwvaLYulwbqVtG3rcC4G4bvhwbLGGuLYvwTY6DMcxINgLA4DEEDOsWpblrZi41nWDaRtGvnkPGiYpmmGZZrm2b5tIhZWbi7p2dFcXNnMbYIPAEAdugCIMNEfYQBg1WMDEpA8E8JwVgOAmkPWEARHZETBHUXy8PwA2sKQHwAPIRLolRNhGDUcMIk1MPQw1ejgERmMALgSPQ9YjeQOB0iYkiLoQWlVAAbtgB1enxlRmAJdnBAJVlevQBARKQQ1uDgdlEKQ8IjvwN2kBEyTYFC2AnQywSgMVAhGMASgAGoENgXKTQkzAgzOojiJI05jooKgaHZ%2BiAUYJggOYliGF99aQHM6AJHeB2SpKLgbKzRCSowN30DKUKed6YNAzgTMhUBc1pE4TCuP%2B3g8KeCvwZefgvnk96ZMrz65He6t9C0u6y%2B0YzQSrMttEwv7jIU4HZLBf661IK7O/bkwa0hrlTqF1n5VF3AbHTRCoBsPBJm1SZaBsEDdiQMk4riPAzF58WtigCxEAkT11Q1CQ1aQoTsCsofh5H0f3YQie7AYJMTkTsgk3O5OLpT5Bcj9CQg/7NlVvwNaTU9ueHOgNAhwGFdRycMdx24jXRO5qfp8VcYgNIs%2BxB52U%2BDwWj708TyxC8VkluQZaxBWA/2bW1ixd5LalRVaBVYXTX52/RcgMAZSAZ10Qep9UXGNIaeNQETWmrNOweNFrMCICtNadlNrbV2vQfaeNjr0jOhtAgl17A3TuvwB6qAnorAjK9XcdlPrfV%2BlgFYXpAbA0OmDCGKhoaw0%2BjTRGNBkZowxljHGHpRzyEblOZu8hW4Li9MuVcNNUBOS3AzCIUsWZszSBzSwmBhYKK3BuPEUpJqi3QOLXYt14BIVNjbeWitXaATPA7BCBgtZ3ktjebWRsILfhAlBJWMErE/lAueR2gEPZuI9p4qQPsUKcGxH3QO1Zg7qCeD4SUfwNjAFQBXWISYeBxwTmQdycTV4%2BUziAbOo9P6L2LqXbgyTUnpMydk3JxCa5kDriuBuhNxH4ykRTJ8ndu69yLAHSKiSuDDxzk9HmE96lpOkBkrJEccl5IgAvd%2BS9k7FKKj5PyAUgrUH9ufS%2B18CrcBio2eK69N5Jm3tiXe%2B9D7H1PtwPKYzB7nJ2TGEZosb6FUfglMGKRHDSCAA%3D%3D">the assembly</a> that for both programs the value is
written directly into the destination provided by the caller.</p>
<div class="comparison">
<pre><code class="language-asm">// C++
make(signed char, double, long):
        mov     BYTE PTR [rdi], sil
        mov     rax, rdi
        mov     QWORD PTR [rdi+16], rdx
        movsd   QWORD PTR [rdi+8], xmm0
        ret
</code></pre>
<pre><code class="language-asm">// Rust
new:
        mov     rax, rdi
        mov     byte ptr [rdi + 16], sil
        movsd   qword ptr [rdi], xmm0
        mov     qword ptr [rdi + 8], rdx
        ret
</code></pre>
</div>
<h2 id="nrvo"><a class="header" href="#nrvo">NRVO</a></h2>
<p>NRVO isn't guaranteed in either C++ or Rust, but the optimization often triggers
in cases where it is commonly desired. For example, in both C++ and Rust
when creating an array, initializing its contents, and then returning it, the
initialization assigns directly to the return location.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;array&gt;

std::array&lt;int, 10&gt; make() {
    std::array&lt;int, 10&gt; v;
    for (int i = 0; i &lt; 10; i++) {
        v[i] = i;
    }
    return v;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
fn new() -&gt; [i32; 10] {
    let mut v = [0; 10];
    for i in 0..10 {
        v[i] = i as i32;
    }
    v
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyahSAVyVFyKxqiIEh1ZpgDC6embZMDzgDIEmbAA5TwAjbFIQAE5yAAd0JWIHJjcPLwN4xPshf0CQtnDImJtsO2SRIhZSIlTPbx5rbFtspgqqolzgsIjo60rq2vSGy3bO/MLogEprdDNSVE4uAFIAJgBmJYBWACEzJiUWGmwIJnQAfTZjYEZJrYARJa0AQRomAGpAgHcISbeAWiWa1wby22wIaxWgO2bx4WnuIIA7NtHk83mi3owiG82GYsQA3EFrO4gnZwtbQ2H3KEo9FvQSkN4ERnvLQAOlZsMRyOetNpeNBBHhgOJTJYSkZEOpPPRSwRD2laP5z1l8qeXGm9G4m343i4OnI6G4ACULFilLN5tgQes%2BOQiNp1dMANYgTYrVnSABsCM2nrWAA4ooGeDI1oZuNJ%2BGxXVpyLr9YauPwlCBY/a9eryHBYCgMDh8MQyJRqHRGKwONxbYJhGIJJwZHJhMo1JoM%2BR9CtDFc0KtkStto1msknExXO46iA1ptyH4Al0Cj1p5kkkJBt4p3EEiumGNupFpyUykI2gNx%2BkN4eWieOnPxou%2Bu015OD/0b3k967pua5gtuKs1gEqAeDghIuFUpAsAAnoCuAoiiliYCAIDgVBgIuAEVgwmSwKXE6xy/LK3KouiCFISh0FrOhwjkFhMFvPy5I0ui9JvBAGGMoSxJktCTJobR5KMr2vYEUiTG8vRApCkSgmMQqiKqrSpDYEQczvAxREqpmmpcNqcYOga3AuEJ/ZvN%2BlrWhC/DpjokzTEg2AsDgkQ/OGXCRuQ0abLG8b8ImyapnaDq2eQLpuh63q%2BgGQZRCG0hhtpaw6vpfmBRm0zZgg8AQLm6BsLEDARMWEAYHlBWRKQPD%2BgisalkQEQphAoT6aEARVJBlb8C1rCkJBADyoS6KU6a2iVHDCL1TD0O1bY4KEZjAGB9D0CmvD8DglwmJIM0EEpZR4tgK36tg6ilLiiz6hhTT6fQBChBBPVuDg%2BlEKQBDRqt5D7aQoQJNgdzYBt1wBKAaUCEYwBKAAagQ2CfL1sTMB1jaiOIkgNtWigqBo%2Bn6A0RgmCA5iWIYt0ppA0zoLELQrX8fwuG8lNEH8jD7fQworL5X2vTgZMuZew4QM4T6ejOo67gukQNsuLTC5uWTJOLEwNvzx6vrLKutK%2Bis9Mratnt4IsjNU2uS9IX4Wr%2BPAalqSVtombxE0QqAwqyVWslorEFiQDL/lbVlBVmKCzEQsS4kVJX5YwpBBOwiyO87PCuwi7v8NghDewQiENBjtZo7IGPNtjba4%2BQnwQbEHXWzptsJtwvW4qHWLoDQDumgnSfu6xbilVHFl%2B6lNnOiA0jJ5sEJxZ6sKwv6/qbP6rnuZ53nJdw/lpgHGXZWguWR4VVDFTvZUgMAPCbNnDB1aQDVNW2XVtUjd89f1g12Ejo3MEQE1Tfps3zYty1I3WlcLa%2BpCC7XsPtQ6qcTqoDOkjS62l9Q3Tum1R650rKvXeraL6P0VD/UBjdAmoMaDgyhjDOGCNdRVnkLnes%2Bd5CF1bPqDsXYCaoGMgOZBvMKZU2SDTBCwp2H9l7Osf4vUOYGi5pnA68AvxNCGgLIW%2BsQAIlFpgE2IARbS2SE%2BVR2ici3g/IbeRR5NaPmUaojW14NGGz1mkbwlitaGIlpo82P5OArCrrpHyBkuBvHUP6T0fxPTSDeMAVACdNgck9unMgFlPH%2B1BlvYOjdw6HyjjHCsXAAlBJCWEiJMIom2jToWbmIBOw51RnQ5GjCcblNLuXSurlvEry4PXEOuIGYtxycE0J4TInRIgN3XePt1gJIHo6cg9lHI9BctpReMY9J21XtYAK1lJkuhHqyMeKwJ5Ty0DPOerlEpLNrkmCZwVtISJ8SldZwUvqJEcNIIAA%3D%3D">generated assembly</a> for the two versions of the program are
nearly identical, and both construct the array directly in the return location.</p>
<div class="comparison">
<pre><code class="language-asm">// C++
make():
        movdqa  xmm0, XMMWORD PTR .LC0[rip]
        mov     rdx, QWORD PTR .LC2[rip]
        mov     rax, rdi
        movups  XMMWORD PTR [rdi], xmm0
        movdqa  xmm0, XMMWORD PTR .LC1[rip]
        mov     QWORD PTR [rdi+32], rdx
        movups  XMMWORD PTR [rdi+16], xmm0
        ret
.LC0:
        .long   0
        .long   1
        .long   2
        .long   3
.LC1:
        .long   4
        .long   5
        .long   6
        .long   7
.LC2:
        .long   8
        .long   9
</code></pre>
<pre><code class="language-asm">// Rust
.LCPI0_0:
        .long   0
        .long   1
        .long   2
        .long   3
.LCPI0_1:
        .long   4
        .long   5
        .long   6
        .long   7
new:
        mov     rax, rdi
        movaps  xmm0, xmmword ptr [rip + .LCPI0_0]
        movups  xmmword ptr [rdi], xmm0
        movaps  xmm0, xmmword ptr [rip + .LCPI0_1]
        movups  xmmword ptr [rdi + 16], xmm0
        movabs  rcx, 38654705672
        mov     qword ptr [rdi + 32], rcx
        ret
</code></pre>
</div>
<h2 id="determining-whether-the-optimization-occurred"><a class="header" href="#determining-whether-the-optimization-occurred">Determining whether the optimization occurred</a></h2>
<p>Tools like <a href="https://github.com/pacak/cargo-show-asm">cargo-show-asm</a> can be used
to show the assembly for individual functions in order to confirm that RVO or
NRVO was applied where desired.</p>
<p>There are also high-quality <a href="https://bheisler.github.io/criterion.rs/book/index.html">benchmarking
tools</a> for Rust, which
can be used to ensure that changes do not unexpectedly result in worse
performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="placement-new"><a class="header" href="#placement-new">Placement new</a></h1>
<div class="warning">
<p>Some of the statements about Rust in this chapter are dependent on the specifics
of how the compiler optimizes various programs. Unless otherwise state, the
results presented here are based on rustc 1.87 using the <a href="https://doc.rust-lang.org/edition-guide/introduction.html">2024 language
edition</a>.</p>
</div>
<p>The primary purposes of placement new in C++ are</p>
<ul>
<li>situations where <a href="idioms/placement_new.html#custom-allocators-and-custom-containers">storage allocation is separate from
initialization</a> such as in the
implementation of <code>std::vector</code> or memory pools,</li>
<li>situations where the structures need to be placed at a specific memory
location, e.g., for <a href="idioms/placement_new.html#memory-mapped-registers-and-embedded-development">working with memory-mapped
registers</a>, and</li>
<li><a href="idioms/placement_new.html#performance-and-storage-reuse">storage reuse for performance reasons</a>.</li>
</ul>
<p>You also might have ended up on this page looking for <a href="idioms/placement_new.html#constructing-large-values-on-the-heap">how to construct large
values directly on the heap in Rust</a>.</p>
<p>There is an <a href="https://github.com/rust-lang/rfcs/pull/2884">open proposal</a> for
adding the features analogous to placement new in Rust, but the design of the
features is still under discussion. In the meantime, for many of the use cases
of placement new, there are either alternatives in safe Rust or approaches that
use unsafe Rust that can accomplish the required behaviors.</p>
<h2 id="custom-allocators-and-custom-containers"><a class="header" href="#custom-allocators-and-custom-containers">Custom allocators and custom containers</a></h2>
<p>It is uncommon to use placement new for the first reason because the major use
cases are covered by using STL containers with custom allocators. Similarly,
Rust's standard libraries can be used with custom allocators. However, in Rust
the API for custom allocators is still
<a href="https://github.com/rust-lang/rust/issues/32838">unstable</a>, and so they are only
available when using the nightly compiler with <a href="https://doc.rust-lang.org/unstable-book/library-features/allocator-api.html">a feature
flag</a>.
The Rust Book has <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#unstable-features">instructions on how to install the nightly
toolchain</a>
and the The Rust Unstable Book has <a href="https://doc.rust-lang.org/unstable-book/">instructions on how to use unstable
features</a>.</p>
<p>For stable Rust, there are libraries that cover many of the uses of allocators.
For example, <a href="https://docs.rs/bumpalo/latest/bumpalo/">bumpalo</a> provides a safe
interface to a bump allocation arena, a <a href="https://docs.rs/bumpalo/latest/bumpalo/collections/vec/struct.Vec.html">vector type using the
arena</a>,
and other utility types using the arena.</p>
<p>For implementing custom collection types that involves separate allocation and
initialization of memory, the chapters in the Rustonomicon on <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">implementing
<code>Vec</code></a> are a useful resource.</p>
<h2 id="memory-mapped-registers-and-embedded-development"><a class="header" href="#memory-mapped-registers-and-embedded-development">Memory-mapped registers and embedded development</a></h2>
<p>If you are using Rust for embedded development, you may want to additionally
read the <a href="https://docs.rust-embedded.org/book/">Embedded Rust Book</a>. The
chapters on
<a href="https://docs.rust-embedded.org/book/peripherals/index.html">peripherals</a>
discuss how to work with structures that are located at a specific address in
memory.</p>
<p>The Embedded rust Book also includes <a href="https://docs.rust-embedded.org/book/c-tips/index.html">a chapter on advice for embedded C
programmers using Rust for embedded
development</a>.</p>
<h2 id="performance-and-storage-reuse"><a class="header" href="#performance-and-storage-reuse">Performance and storage reuse</a></h2>
<p>This use of placement new in C++ for the purpose of reusing storage can usually
be replaced in Rust by a simple assignment. Because <a href="idioms/./constructors/copy_and_move_constructors.html">assignment in Rust is
always a move, and in Rust moves do not leave behind objects that require
destruction</a>, the optimizer will
usually produce code analogous to placement new for this use case. In some
cases, this also depends on an <a href="idioms/./rvo.html">RVO or NRVO optimization</a>. While these
optimizations are not guaranteed, they are reliable enough for common coding
patterns, especially when combined with
<a href="https://bheisler.github.io/criterion.rs/book/index.html">benchmarking</a> the
performance-sensitive code to confirm that the desired optimization was
performed. Additionally, the generated assembly for specific functions can be
examined using a tool like
<a href="https://github.com/pacak/cargo-show-asm">cargo-show-asm</a>.</p>
<p>The Rust version of the following example relies on the optimizations <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyahSAVyVFyKxqiIEh1ZpgDC6embZMpATnLOAGQImbAA5TwAjbFIQADZyAAd0JWIHJjcPL19E5NShIJDwtiiY%2BJtsOzSRIhZSIgzPbx4/csqhatqiArDI6LjrGrqGrOaBzu6ikriASmt0M1JUTi4AUgAmAGYVgFYAIRxSAgA3bAgAEWwaFjN6Immds5WtAEFLczsAagDa4GwAdQImF%2BRA%2BKwA7Lsns8PjCPoCQB8LAQAF7YchQ8GPF4YzY7XZmJhKFg0U5MdAAfTYxmAjHu2yxzxoTA%2BmApAHcyABrCBshHrWJsMwg76kX4AoHYO6giFQ2EfQSkOFw5laAB0qp4Wi00shLzlcoAVGzQRszl8fv9AcCdbL9Xb4XD0Xq7dLHhtddCXQB6L2IlQfNm2u2WTAgEBIYJEMMRIyoTnkiLodQQfls%2B7uoOujFghlQpkfKnBCDTG3OmGMEGCkFKVCkFhEVBIE1mkViq2SsM4K43IjFlYZsss9lclNrAVCj41usNpDpj2YqFcWb0bjbfjeLg6cjobgAJQs1fmi2woM2fHIUc3S9mnJA2zWquksTB21iGwAHD5PzwZBtDNxpH4Ng7y0cgNy3HcuH4JQQFAy8dFmOBYBQDAcHwYgyEoag6EYVgOG4c9BGEMQJE4GQ5GEZQ1E0K9yH0NZDGpNB1khNZdmsbBbHsRwIGcYZvDWHh/CYTAJl6GJZCSFJuPSdxGhAQScmktIxOKPpZFaGSOiGOSskUzSqkGLpgh6NSJLGHTMgEoTLHGEzJnU2YlCPJZuHWDZglQDwcBNFxUBDLt%2B1wHEPKYLyzB8/sXBCQMNmC7EXjeMxPlbS0JRBcEPRhEMwxSVFyRBQF%2B3nHNioxF4iGwNgEiMSrfKIABPBJmHYE8ABUgqhbB1Eq0hmSOdBAQ%2BGMWDjXYkwgNrT1idQ53K54BqG1k/hHRbMA%2BA0p3rRsS0y20FQ%2BCAcpAPLsAKpV%2BzNLRioujYXA%2BTVrvdOEWJY3aZUHa4SA2tkIBiw6tpnEtUvFYFMtVIbLpenM5sHH0/RPQNBxGsaJrTMrBzZABaIKAD8QfbXtYc9BdsVKhLnkjAsWCLd6so%2BCQCGAVglAgRnmfQGgIAJ9LphLRtakzGEODYMgGrxU7Oe5i1QclOk3XptafubAsqrFjHPWWkd0YHZ5SeeJd/y4NcwO0fhIJcV62MnFyT3ctZ%2BHg69yCQbAWAOahlwAoCQNN2jIOg2CLzNvnyFve9H2fV8Py/Hwf2kP8Vy4DZ1zN7duEdkPyCQhB4AgFD0GqhhoiwiAMCLxgYlIHh3zBUCcN6mCIAiNOImCWoGoI/g29YUgGoAeQiXQKkvc9y44YR%2B6YehO9onAIjMYAXAkegYN4fgcCpExJDnghSBH45sDXrduoqIVli3SNOLT%2BgCAiOs%2B7cHA06IQ5gPX8gTlIRMVAuLeaWCKAK8swaBGGAEoAAagQbAbJ%2B7NQ3IReQJFJDkSIooFQGg076CEkYEwIBzCWEMHfGCkBZjoASDJNeWMsb3XIUQLGjATj0Eug7bcX9Dg4BIcWDiXE0hOBEvxAwgR7LiQMFJPIskrJiNyDJVSUwbKcQPu0IygiFG8OUXZQooibIqN0k0CyxktFmSkE5W2JijYm3AubbgHwCENgeqqWuqptQQHQiQRU7keDTEzsA7OKB5hEASEKUu5cEjF1IKEVq3A7GoAcU4k%2BhB3HwiEmg5BZFZBoKopg2i2DyBsjrAkLuXtjap39twfuQogkgk5rYg8sSeCOLBM4w6bgK7RFPBsLxPiEI3hANIJp2wNhrATrETUmp3zvm2O%2BI2gFyDAW2KBKx6coLWCDk7RCiB85oELmEyuISdnhJAMAHg2wUkMEbtQFutEe4dy7uQG5fdB7DzsHc8ezAiBTxnmneei9l70FXncze1Id5bkIPvSoJxj78FPqgc%2Bdyr5Jy3Lfe%2BHcn4X0dm/O5X8f7YD/sCwBWdQEsHAVAmBcDmB3NSeIFBGT5BZJolueijE8GoCtuxZFXCyEULSFQkMl1WVsRYpsD4WN%2B6sPQOwwER94BOUUW0bwvEBF6KESJORfQhLiJkqopSEi1UxDUUopg2l6jKoNfK41eqDC2UsvJHRmjTLyNMQsVyaximWLTpBD46h3yxCxrEaQHxgCoHqdsDUh03FkA6a67phstkBKqfstpESolcG9b6/1gbg0PVDeebAiSyDwgYlS0iUhaWUQwQyvQCk8kFKKRY0pEFymVInDUtNfqA1BpDWGiArTdntPtt44OwDZiu3dn0bhSdZnzMWR6jOqy4Ih16f01UgzhkbFGVocZkzplJxTn7RtKz1nFNYUsgOQ6emf2iCkRw0ggA%3D%3D">to
achieve the desired behavior</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;new&gt;

struct LargeWidget {
  std::size_t id;
};

template &lt;typename T&gt;
extern void blackBox(T &amp;x);

void doWork(void *scratch) {
  for (std::size_t i = 0; i &lt; 100; i++) {
    auto *w(new (scratch) LargeWidget{.id = i});
    // use w
    blackBox(w);
    w-&gt;~LargeWidget();
  }
}

int main() {
  alignas(alignof(LargeWidget)) char
      memory[sizeof(LargeWidget)];
  void *w = memory;
  doWork(w);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct LargeWidget {
    id: usize,
}

fn do_work(w: &amp;mut LargeWidget) {
    for i in 0..100 {
        *w = LargeWidget { id: i };
        // use w
        std::hint::black_box(&amp;w);
    }
}

fn main() {
    let mut scratch = LargeWidget::default();
    do_work(&amp;mut scratch);
}</code></pre></pre>
</div>
<p>Adding in a <code>Drop</code> implementation for <code>LargeWidget</code> does result in the drop
function being called on each loop iteration, but makes the generated assembly
much harder to read, and so has been omitted from the example.</p>
<h2 id="constructing-large-values-on-the-heap"><a class="header" href="#constructing-large-values-on-the-heap">Constructing large values on the heap</a></h2>
<p><code>new</code> in C++ constructs objects directly in dynamic storage, and placement <code>new</code>
constructs them directly in the provided location. In Rust, <code>Box::new</code> is a
normal function, so the value is constructed on the stack and then moved to the
heap (or to the storage provided by the custom allocator).</p>
<p>While the initial construction of the value on the stack can sometimes be
optimized away, in order to guarantee that the stack is not used for the large
value requires the use of unsafe Rust and <code>MaybeUninit</code>. Additionally, the
mechanisms available for initializing a value on the heap do not guarantee that
the values will not be created on the stack and then moved to the heap. Instead,
they just make it possible to incrementally initialize a structure (either
field-by-field or element-by-element), so that the entire structure does not
have to be on the stack at once. The same optimizations do apply, however, and
so the additional copies might be avoided.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
  constexpr unsigned int SIZE = 8000000;
  std::unique_ptr b = std::make_unique&lt;
      std::array&lt;unsigned int, SIZE&gt;&gt;();
  for (std::size_t i; i &lt; SIZE; ++i) {
    (*b)[i] = 42;
  }

  // use b so that it isn't optimized away
  for (std::size_t i; i &lt; SIZE; ++i) {
    std::cout &lt;&lt; (*b)[i] &lt;&lt; std::endl;
  }
}
</code></pre>
<!-- must be no_run because mdbook test doesn't compile with opt-level=2 -->
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;

    // optimization here makes it not overflow
    // the stack with opt-level=2
    let mut b = Box::new([0; SIZE]);
    for i in 0..SIZE {
        b[i] = 42;
    }

    // use b so that it isn't optimized away
    std::hint::black_box(&amp;b);
}</code></pre></pre>
</div>
<p>On the other hand, directly defining the array as <code>[42; SIZE]</code> does result in
the value being first constructed on the stack, which produces an error when
run.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;

    let b = Box::new([42; SIZE]);

    // use b so that it isn't optimized away
    std::hint::black_box(&amp;b);
}</code></pre></pre>
<pre><code class="language-text">thread 'main' has overflowed its stack
fatal runtime error: stack overflow
Aborted (core dumped)
</code></pre>
<p>While construction of the values directly on the heap is not possible to
enforce, it is possible to incrementally construct the value by using unsafe
Rust, which avoids overflowing the stack. This technique relies on both
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a> and
<a href="https://doc.rust-lang.org/std/ptr/macro.addr_of_mut.html"><code>addr_of_mut!</code></a>.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    const SIZE: usize = 8_000_000;
    let mut b = Box::&lt;[i32; SIZE]&gt;::new_uninit();
    let bptr = b.as_mut_ptr();
    for i in 0..SIZE {
        unsafe {
            std::ptr::addr_of_mut!(((*bptr)[i])).write(42);
        }
    }

    let b2 = unsafe { b.assume_init() };

    for i in 0..SIZE {
        println!("{}", b2[i]);
    }
}</code></pre></pre>
<p>Depending on what is need, this particular use can be generalized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_with&lt;T, const SIZE: usize&gt;(
    f: impl Fn(usize) -&gt; T,
) -&gt; Box&lt;[T; SIZE]&gt; {
    let mut b = Box::&lt;[T; SIZE]&gt;::new_uninit();
    let bptr = b.as_mut_ptr();
    for i in 0..SIZE {
        unsafe {
            std::ptr::addr_of_mut!(((*bptr)[i]))
                .write(f(i));
        }
    }

    unsafe { b.assume_init() }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that a more idiomatic way to deal with a large array on the heap is to
represent it as either a boxed slice or a vector instead of a boxed array, in
which case using iterators to define the value avoids constructing it on the
stack, and does not require the use of unsafe Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_with&lt;T, const SIZE: usize&gt;(
    f: impl Fn(usize) -&gt; T,
) -&gt; Box&lt;[T]&gt; {
    (0..SIZE).map(f).collect()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adapter-pattern"><a class="header" href="#adapter-pattern">Adapter pattern</a></h1>
<p>In C++, if an existing class needs to implement a new interface, the adapter
pattern is normally used. The pattern involves defining a wrapper class that
implements the interface by delegating to the methods on the original class.</p>
<p>In Rust, the same pattern is possible and is <a href="https://doc.rust-lang.org/book/ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">sometimes necessary due to the
orphan
rule</a>.
However, because traits can be implemented where <em>either</em> the type or the trait
is defined, usually it is possible to just implement the trait for the type
directly, without the need for a wrapper.</p>
<p>The following example adds an interface to <code>std::string</code> in C++ and <code>String</code> in
Rust for use with a template function defined in the library. When dynamic
dispatch is needed, there is no change to how to implement the trait for the
existing type in Rust.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
concept doubleable = requires(const T t) {
  { t.twice() } -&gt; std::same_as&lt;T&gt;;
};

template &lt;doubleable T&gt;
T quadruple(const T &amp;x) {
  return x.twice().twice();
}

struct DoubleableString {
  std::string str;

  DoubleableString twice() const {
    return DoubleableString{this-&gt;str +
                            this-&gt;str};
  }
};

int main() {
  auto s = quadruple(
      DoubleableString{std::string("a")});
  std::cout &lt;&lt; s.str &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Doubleable {
    fn twice(&amp;self) -&gt; Self;
}

impl Doubleable for String {
    fn twice(&amp;self) -&gt; Self {
        self.clone() + self
    }
}

fn quadruple&lt;T: Doubleable&gt;(x: T) -&gt; T {
    x.twice().twice()
}

fn main() {
    let s = quadruple(String::from("a"));
    println!("{}", s);
}</code></pre></pre>
</div>
<h2 id="extension-traits"><a class="header" href="#extension-traits">Extension traits</a></h2>
<p>The usual approach to adding functionality to an existing type in C++ is to
define the additional functionality as functions.</p>
<p>Rust can similarly add functionality by defining freestanding functions. Rust
also supports the ability to add methods to existing types. It does so by using
the same mechanism as described in the previous section. By using a blanket
implementation, methods can even be added to any type that implements some other
trait. This is the approach used by the <a href="https://docs.rs/itertools/latest/itertools/"><code>itertools</code>
crate</a> to add additional
functionality to anything that implements the <code>Iterator</code> trait.</p>
<pre><pre class="playground"><code class="language-rust">trait Middle {
    type Output;
    fn middle(&amp;mut self) -&gt; Option&lt;Self::Output&gt;;
}

impl&lt;T: ExactSizeIterator&gt; Middle for T {
    type Output = T::Item;

    fn middle(&amp;mut self) -&gt; Option&lt;Self::Output&gt; {
        let len = self.len();
        if len &gt; 0 &amp;&amp; len % 2 == 1 {
            self.nth(len / 2)
        } else {
            None
        }
    }
}

fn main() {
    println!("{:?}", [1, 2, 3].iter().middle());
    println!("{:?}", [1, 2, 3].iter().map(|n| n + 1).middle());
}</code></pre></pre>
<p>The <code>map</code> method returns a different type than <code>iter</code>, but <code>middle</code> can be
called on the result of either one.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;adapter&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The apdapter pattern is needed when the orphan rule prevents implementing a\ntrait for a type.\n\nThe [orphan\nrule](https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules)\nsays that a at least one of the trait or a type in the trait implementation\nneeds to be defined in the current crate. When at least one of `Shape` or\n`Circle` is defined in the current crate, the orphan rule does not prevent the\nimplementation.\n&quot;,&quot;id&quot;:&quot;b6394504-9fdb-49c8-88c0-046c42f74287&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`Circle` and `Shape` are both defined in `crate_a`.\n&quot;,&quot;`Circle` is defined in `crate_a`, and `Shape` is defined in `crate_b`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Circle` and `Shape` are both defined in the current crate.\n&quot;,&quot;`Circle` is defined in the current crate, and and `Shape` is defined in `crate_a`.\n&quot;,&quot;`Shape` is defined in the current crate, and and `Circle` is defined in `crate_a`.\n&quot;],&quot;prompt&quot;:&quot;Consider a situation where you are working with a type `Circle` and a trait\n`Shape`. The type and trait are each defined in one of:\n\n- the current crate,\n- a dependency crate `crate_a` of the current crate, or\n- a depedency `crate_b` of the current crate.\n\nFor which situations is the adapter pattern necessary in Rust?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="visitor-pattern-and-double-dispatch"><a class="header" href="#visitor-pattern-and-double-dispatch">Visitor pattern and double dispatch</a></h1>
<p>In C++ the visitor pattern is typically used to enable adding behaviors to a
type without modifying the class definitions. In Rust, the same goal is
conventionally accomplished by using Rust enums, which resemble C++ <a href="patterns/../idioms/data_modeling/tagged_unions.html">tagged
unions</a>. While the chapter on tagged
unions compares using Rust enums with C++ <code>std::variant</code>, this chapter <a href="patterns/visitor.html#use-a-rust-enum-instead">compares
using the visitor pattern in C++ with using Rust
enums</a>.</p>
<p>Since the visitor pattern and double dispatch may be useful for other purposes
as well, a <a href="patterns/visitor.html#visitors">Rust visitor pattern version of the example</a> is also
given.</p>
<p>Extensions of the visitor pattern are sometimes used in C++ to make it possible
to extend both data and behavior without modifying the original definitions
(i.e., to solve <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/">the expression
problem</a>).
Other approaches, enabled by Rust's traits and generics, are <a href="patterns/visitor.html#varying-data-and-behavior">more likely to be
used in Rust</a>.</p>
<h2 id="use-a-rust-enum-instead"><a class="header" href="#use-a-rust-enum-instead">Use a Rust enum instead</a></h2>
<p>For the first case, where the variants are fixed but behaviors are not, the
idiomatic approach in Rust is to implement the data structure as an enum instead
of as many structs with a common interface. This is similar to using
<code>std::variant</code> in C++.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

// Declare types that visitor can visit
class Lit;
class Plus;
class Var;
class Let;

// Define abstract class for visitor
struct Visitor {
  virtual void visit(Lit &amp;e) = 0;
  virtual void visit(Plus &amp;e) = 0;
  virtual void visit(Var &amp;e) = 0;
  virtual void visit(Let &amp;e) = 0;
  virtual ~Visitor() = default;

protected:
  Visitor() = default;
};

// Define abstract class for expressions
struct Exp {
  virtual void accept(Visitor &amp;v) = 0;
  virtual ~Exp() = default;
};

// Implement each expression variant
struct Lit : public Exp {
  int value;

  Lit(int value) : value(value) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Plus : public Exp {
  std::unique_ptr&lt;Exp&gt; lhs;
  std::unique_ptr&lt;Exp&gt; rhs;

  Plus(std::unique_ptr&lt;Exp&gt; lhs,
       std::unique_ptr&lt;Exp&gt; rhs)
      : lhs(std::move(lhs)), rhs(std::move(rhs)) {
  }

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Var : public Exp {
  std::string name;

  Var(std::string name) : name(name) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Let : public Exp {
  std::string name;
  std::unique_ptr&lt;Exp&gt; exp;
  std::unique_ptr&lt;Exp&gt; body;

  Let(std::string name, std::unique_ptr&lt;Exp&gt; exp,
      std::unique_ptr&lt;Exp&gt; body)
      : name(std::move(name)),
        exp(std::move(exp)),
        body(std::move(body)) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

// Define Visitor for evaluating expressions

// Exception for representing expression
// evaluation errors
struct UnknownVar : std::exception {
  std::string name;

  UnknownVar(std::string name) : name(name) {}

  const char *what() const noexcept override {
    return "Unknown variable";
  }
};

// Define type for evaluation environment
using Env = std::unordered_map&lt;std::string, int&gt;;

// Define evaluator
struct EvalVisitor : public Visitor {
  // Return value. Results propagate up the stack.
  int value = 0;

  // Evaluation environment. Changes propagate
  // down the stack
  Env env;

  // Define behavior for each case of the
  // expression.
  void visit(Lit &amp;e) override { value = e.value; }
  void visit(Plus &amp;e) override {
    e.lhs-&gt;accept(*this);
    auto lhs = value;
    e.rhs-&gt;accept(*this);
    auto rhs = value;
    value = lhs + rhs;
  }
  void visit(Var &amp;e) override {
    try {
      value = env.at(e.name);
    } catch (std::out_of_range &amp;ex) {
      throw UnknownVar(e.name);
    }
  }
  void visit(Let &amp;e) override {
    e.exp-&gt;accept(*this);
    auto orig_env = env;
    env[e.name] = value;
    e.body-&gt;accept(*this);
    env = orig_env;
  }
};

int main() {
  // Construct an expression
  auto x = Plus(std::make_unique&lt;Let&gt;(
                    std::string("x"),
                    std::make_unique&lt;Lit&gt;(3),
                    std::make_unique&lt;Var&gt;(
                        std::string("x"))),
                std::make_unique&lt;Lit&gt;(2));

  // Construct the evaluator
  EvalVisitor visitor;

  // Run the evaluator
  x.accept(visitor);

  // Print the output
  std::cout &lt;&lt; visitor.value &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

// Define expressions.
//
// This covers the first 3 sections of the
// C++ version.
enum Exp {
    Var(String),
    Lit(i32),
    Plus {
        lhs: Box&lt;Exp&gt;,
        rhs: Box&lt;Exp&gt;,
    },
    Let {
        var: String,
        exp: Box&lt;Exp&gt;,
        body: Box&lt;Exp&gt;,
    },
}

// Exception for representing expression
// evaluation errors
#[derive(Debug)]
enum EvalError&lt;'a&gt; {
    UnknownVar(&amp;'a str),
}

// Define type for evaluation environment
type Env&lt;'a&gt; = HashMap&lt;&amp;'a str, i32&gt;;

// Define evaluator
fn eval&lt;'a&gt;(
    env: &amp;Env&lt;'a&gt;,
    e: &amp;'a Exp,
) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
    match e {
        Exp::Var(x) =&gt; env
            .get(x.as_str())
            .cloned()
            .ok_or(EvalError::UnknownVar(x)),
        Exp::Lit(n) =&gt; Ok(*n),
        Exp::Plus { lhs, rhs } =&gt; {
            let lv = eval(env, lhs)?;
            let rv = eval(env, rhs)?;
            Ok(lv + rv)
        }
        Exp::Let { var, exp, body } =&gt; {
            let val = eval(env, exp)?;
            let mut env = env.clone();
            env.insert(var, val);
            eval(&amp;env, body)
        }
    }
}

fn main() {
    use Exp::*;

    // Construct an expression
    let e = Let {
        var: "x".to_string(),
        exp: Box::new(Lit(3)),
        body: Box::new(Plus {
            lhs: Box::new(Var("x".to_string())),
            rhs: Box::new(Lit(2)),
        }),
    };

    // Run the evaluator
    let res = eval(&amp;HashMap::new(), &amp;e);

    // Print the output
    println!("{:?}", res);
}</code></pre></pre>
</div>
<h2 id="visitors"><a class="header" href="#visitors">Visitors</a></h2>
<p>If the visitor pattern is still needed for some reason, it can be implemented
similarly to how it is in C++. This can make direct ports of programs that use
the visitor pattern more feasible. However, the enum-based implementation should
still be preferred.</p>
<p>The following example shows how to implement the same program as in the previous
example, but using a visitor in Rust. The C++ program is identical to the
previous one.</p>
<p>The example also demonstrates using double dispatch with trait objects in Rust.
The expressions are represented as <code>dyn Exp</code> trait objects which accept a <code>dyn Visitor</code> trait object, and then call on the visitor the method specific to the
type of expression.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

// Declare types that visitor can visit
class Lit;
class Plus;
class Var;
class Let;

// Define abstract class for visitor
struct Visitor {
  virtual void visit(Lit &amp;e) = 0;
  virtual void visit(Plus &amp;e) = 0;
  virtual void visit(Var &amp;e) = 0;
  virtual void visit(Let &amp;e) = 0;
  virtual ~Visitor() = default;

protected:
  Visitor() = default;
};

// Define abstract class for expressions
struct Exp {
  virtual void accept(Visitor &amp;v) = 0;
  virtual ~Exp() = default;
};

// Implement each expression variant
struct Lit : public Exp {
  int value;

  Lit(int value) : value(value) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Plus : public Exp {
  std::unique_ptr&lt;Exp&gt; lhs;
  std::unique_ptr&lt;Exp&gt; rhs;

  Plus(std::unique_ptr&lt;Exp&gt; lhs,
       std::unique_ptr&lt;Exp&gt; rhs)
      : lhs(std::move(lhs)), rhs(std::move(rhs)) {
  }

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Var : public Exp {
  std::string name;

  Var(std::string name) : name(name) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

struct Let : public Exp {
  std::string name;
  std::unique_ptr&lt;Exp&gt; exp;
  std::unique_ptr&lt;Exp&gt; body;

  Let(std::string name, std::unique_ptr&lt;Exp&gt; exp,
      std::unique_ptr&lt;Exp&gt; body)
      : name(std::move(name)),
        exp(std::move(exp)),
        body(std::move(body)) {}

  void accept(Visitor &amp;v) override {
    v.visit(*this);
  }
};

// Define Visitor for evaluating expressions

// Exception for representing expression
// evaluation errors
struct UnknownVar : std::exception {
  std::string name;

  UnknownVar(std::string name) : name(name) {}

  const char *what() const noexcept override {
    return "Unknown variable";
  }
};

// Define type for evaluation environment
using Env = std::unordered_map&lt;std::string, int&gt;;

// Define evaluator
struct EvalVisitor : public Visitor {
  // Return value. Results propagate up the stack.
  int value = 0;

  // Evaluation environment. Changes propagate
  // down the stack
  Env env;

  // Define behavior for each case of the
  // expression.
  void visit(Lit &amp;e) override { value = e.value; }
  void visit(Plus &amp;e) override {
    e.lhs-&gt;accept(*this);
    auto lhs = value;
    e.rhs-&gt;accept(*this);
    auto rhs = value;
    value = lhs + rhs;
  }
  void visit(Var &amp;e) override {
    try {
      value = env.at(e.name);
    } catch (std::out_of_range &amp;ex) {
      throw UnknownVar(e.name);
    }
  }
  void visit(Let &amp;e) override {
    e.exp-&gt;accept(*this);
    auto orig_env = env;
    env[e.name] = value;
    e.body-&gt;accept(*this);
    env = orig_env;
  }
};

int main() {
  // Construct an expression
  auto x = Plus(std::make_unique&lt;Let&gt;(
                    std::string("x"),
                    std::make_unique&lt;Lit&gt;(3),
                    std::make_unique&lt;Var&gt;(
                        std::string("x"))),
                std::make_unique&lt;Lit&gt;(2));

  // Construct the evaluator
  EvalVisitor visitor;

  // Run the evaluator
  x.accept(visitor);

  // Print the output
  std::cout &lt;&lt; visitor.value &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// This is NOT an idiomatic translation. The
// previous example using Rust enums is.

use std::collections::HashMap;

// Define types that the visitor can visit
struct Lit(i32);
struct Plus {
    lhs: Box&lt;dyn Exp&gt;,
    rhs: Box&lt;dyn Exp&gt;,
}
struct Var(String);
struct Let {
    name: String,
    exp: Box&lt;dyn Exp&gt;,
    body: Box&lt;dyn Exp&gt;,
}

// Define trait for expressions
trait Exp {
    // Much like C++ can't have virtual template
    // methods, Rust can't have trait objects
    // where the traits have generic methods.
    //
    // Therefore the visitor either has to be
    // mutable to collect the results or the
    // accept method has to be specialized to a
    // specific return type.
    fn accept&lt;'a&gt;(&amp;'a self, v: &amp;mut dyn Visitor&lt;'a&gt;);
}

// Define trait for the visitor
trait Visitor&lt;'a&gt; {
    fn visit_lit(&amp;mut self, e: &amp;'a Lit);
    fn visit_plus(&amp;mut self, e: &amp;'a Plus);
    fn visit_var(&amp;mut self, e: &amp;'a Var);
    fn visit_let(&amp;mut self, e: &amp;'a Let);
}

// Implement accept behavior for each expression variant
impl Exp for Lit {
    fn accept&lt;'a&gt;(&amp;'a self, v: &amp;mut (dyn Visitor&lt;'a&gt;)) {
        v.visit_lit(self);
    }
}

impl Exp for Plus {
    fn accept&lt;'a&gt;(&amp;'a self, v: &amp;mut dyn Visitor&lt;'a&gt;) {
        v.visit_plus(self);
    }
}

impl Exp for Var {
    fn accept&lt;'a&gt;(&amp;'a self, v: &amp;mut dyn Visitor&lt;'a&gt;) {
        v.visit_var(self);
    }
}

impl Exp for Let {
    fn accept&lt;'a&gt;(&amp;'a self, v: &amp;mut dyn Visitor&lt;'a&gt;) {
        v.visit_let(self);
    }
}

// Define Visitor for evaluating expressions

// Error for representing expression evaluation
// errors.
//
// Has a lifetime parameter beacause it borrows
// the name from the expression.
#[derive(Debug)]
enum EvalError&lt;'a&gt; {
    UnknownVar(&amp;'a str),
}

// Define type for evaluation environment
//
// Has a lifetime parameter because it borrows
// the names from the expression.
type Env&lt;'a&gt; = HashMap&lt;&amp;'a str, i32&gt;;

// Define the evaluator
struct EvalVisitor&lt;'a&gt; {
    // Return value. Results propagate up the stack.
    env: Env&lt;'a&gt;,

    // Evaluation environment. Changes propagate
    // down the stack
    value: Result&lt;i32, EvalError&lt;'a&gt;&gt;,
}

// Define behavior for each case of the
// expression.
impl&lt;'a&gt; Visitor&lt;'a&gt; for EvalVisitor&lt;'a&gt; {
    fn visit_lit(&amp;mut self, e: &amp;'a Lit) {
        self.value = Ok(e.0);
    }

    fn visit_plus(&amp;mut self, e: &amp;'a Plus) {
        e.lhs.accept(self);
        let Ok(lv) = self.value else {
            return;
        };
        e.rhs.accept(self);
        let Ok(rv) = self.value else {
            return;
        };
        self.value = Ok(lv + rv);
    }

    fn visit_var(&amp;mut self, e: &amp;'a Var) {
        self.value = self
            .env
            .get(e.0.as_str())
            .ok_or(EvalError::UnknownVar(&amp;e.0))
            .copied();
    }

    fn visit_let(&amp;mut self, e: &amp;'a Let) {
        e.exp.accept(self);
        let Ok(val) = self.value else {
            return;
        };
        let orig_env = self.env.clone();
        self.env.insert(e.name.as_ref(), val);
        e.body.accept(self);
        self.env = orig_env;
    }
}

fn main() {
    // Construct an expression
    let x = Plus {
        lhs: Box::new(Let {
            name: "x".to_string(),
            exp: Box::new(Lit(3)),
            body: Box::new(Var("x".to_string())),
        }),
        rhs: Box::new(Lit(2)),
    };

    // Construct the evaluator
    let mut visitor = EvalVisitor {
        value: Ok(0),
        env: HashMap::new(),
    };

    // Run the evaluator
    x.accept(&amp;mut visitor);

    // Print the output
    println!("{:?}", visitor.value);
}</code></pre></pre>
</div>
<h2 id="varying-data-and-behavior"><a class="header" href="#varying-data-and-behavior">Varying data and behavior</a></h2>
<p>In C++, extensions to the visitor pattern are sometimes used to handle
situations where both data and behavior and vary. However, those solutions also
make use of dynamic casting. In Rust, that requires opting into
<a href="patterns/./../idioms/rtti.html">RTTI</a> by making <code>Any</code> a supertrait of the trait for the
visitors, so they can be downcast. While this extension to the visitor pattern
is possible to implement, the ergonomics of the approach make other approaches
more common in Rust.</p>
<p>One of the alternative approaches, adopted from functional programming and
leveraging the design of traits and generics in Rust, is called <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/14416CB20C4637164EA9F77097909409/S0956796808006758a.pdf/data-types-a-la-carte.pdf">"data types à
la
carte"</a>.</p>
<p>The following example shows a variation on the earlier examples using this
pattern to make it so that two parts of the expression type can be defined
separately and given evaluators separately. This approach can lead to
performance problems (in large part due to the indirection through nested
structures) or increases in compilation time, so its necessity should be
carefully evaluated before it is used.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

// A type for combining separately-defined
// expressions. Defining individual expressions
// completely separately and then using an
// application-specific sum type instead of nesting
// Sum can improve performance.
enum Sum&lt;L, R&gt; {
    Inl(L),
    Inr(R),
}

// Define arithmetic expressions
enum ArithExp&lt;E&gt; {
    Lit(i32),
    Plus { lhs: E, rhs: E },
}

// Define let bindings and variables
enum LetExp&lt;E&gt; {
    Var(String),
    Let { name: String, exp: E, body: E },
}

// Combine the expressions
type Sig&lt;E&gt; = Sum&lt;ArithExp&lt;E&gt;, LetExp&lt;E&gt;&gt;;

// Define the fixed-point for recursive
// expressions.
struct Exp(Sig&lt;Box&lt;Exp&gt;&gt;);

// Define an evaluator

// The evaluation environment
type Env&lt;'a&gt; = HashMap&lt;&amp;'a str, i32&gt;;

// Evaluation errors
#[derive(Debug)]
enum EvalError&lt;'a&gt; {
    UndefinedVar(&amp;'a str),
}

// A trait for expressions that can
// be evaluated.
trait Eval {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt;;
}

// Implement the evaluator trait for
// the administrative types

impl&lt;L: Eval, R: Eval&gt; Eval for Sum&lt;L, R&gt; {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
        match self {
            Sum::Inl(left) =&gt; left.eval(env),
            Sum::Inr(right) =&gt; right.eval(env),
        }
    }
}

impl&lt;E: Eval&gt; Eval for Box&lt;E&gt; {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
        self.as_ref().eval(env)
    }
}

// Implement the trait for the desired variants.
impl&lt;E: Eval&gt; Eval for ArithExp&lt;E&gt; {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
        match self {
            ArithExp::Lit(n) =&gt; Ok(*n),
            ArithExp::Plus { lhs, rhs } =&gt; Ok(lhs.eval(env)? + rhs.eval(env)?),
        }
    }
}

impl&lt;E: Eval&gt; Eval for LetExp&lt;E&gt; {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
        match self {
            LetExp::Var(x) =&gt; env
                .get(x.as_str())
                .copied()
                .ok_or(EvalError::UndefinedVar(x)),
            LetExp::Let { name, exp, body } =&gt; {
                let arg = exp.eval(env)?;
                let mut env = env.clone();
                env.insert(name, arg);
                body.eval(&amp;env)
            }
        }
    }
}

// Since the trait is implemented for everything
// inside of Exp, it can be implemented for Exp.
impl Eval for Exp {
    fn eval&lt;'a&gt;(&amp;'a self, env: &amp;Env&lt;'a&gt;) -&gt; Result&lt;i32, EvalError&lt;'a&gt;&gt; {
        self.0.eval(env)
    }
}

// helpers for constructing expressions

fn lit(n: i32) -&gt; Exp {
    Exp(Sum::Inl(ArithExp::Lit(n)))
}

fn plus(lhs: Exp, rhs: Exp) -&gt; Exp {
    Exp(Sum::Inl(ArithExp::Plus {
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    }))
}

fn var(x: &amp;str) -&gt; Exp {
    Exp(Sum::Inr(LetExp::Var(x.to_string())))
}

fn elet(name: &amp;str, val: Exp, body: Exp) -&gt; Exp {
    Exp(Sum::Inr(LetExp::Let {
        name: name.to_string(),
        exp: Box::new(val),
        body: Box::new(body),
    }))
}

fn main() {
    let e = elet("x", lit(3), plus(var("x"), lit(2)));

    println!("{:?}", e.eval(&amp;HashMap::new()));
}</code></pre></pre>
<p>One thing worth noting about the above implementation is that no dynamic
dispatch was required.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;visitor&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The compiler checks for exhasutiveness in handling the cases of a Rust\nenum. This makes it easy to determine where in the code additional logic is\nneeded to handle the new variants, making the trade-offs easier to live with.\n&quot;,&quot;id&quot;:&quot;8435b363-2e95-42e7-a518-d5746ffef385&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Adding variants requires changing the enum definition.\n&quot;,&quot;Adding variants requires changing existing behaviors.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Adding behaviors requires changing the enum definition.\n&quot;,&quot;Adding behaviors requires changing existing behaviors.\n&quot;,&quot;RTTI is necessary to add new variants.\n&quot;],&quot;prompt&quot;:&quot;Which are true trade-offs are made when defining free functions over an enum\ninstead of using the visitor pattern in Rust?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="curiously-recurring-template-pattern-crtp"><a class="header" href="#curiously-recurring-template-pattern-crtp">Curiously recurring template pattern (CRTP)</a></h1>
<p>The C++ <a href="https://en.cppreference.com/w/cpp/language/crtp">curiously recurring template
pattern</a> is used to make the
concrete type of the derived class available in the definition of methods
defined in the base class.</p>
<h2 id="sharing-implementations-with-static-polymorphism"><a class="header" href="#sharing-implementations-with-static-polymorphism">Sharing implementations with static polymorphism</a></h2>
<p>The basic use of the CRTP is for reducing redundancy in implementations that
make use of static polymorphism. In this use case, the <code>this</code> pointer is cast to
the type provided by the template parameter so that methods from the derived
class can be called. This enables methods implemented in the base class to call
methods in the derived class without having to declare them virtual, avoiding
the cost of dynamic dispatch.</p>
<p>In the following example, <code>Triangle</code> and <code>Square</code> have a common implementation
of <code>twiceArea</code> without the need for dynamic dispatch. This use case is addressed
in Rust using default trait methods.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
struct Shape {
  // This implementation is shared and can call
  // the area method from derived classes without
  // declaring it virtual.
  double twiceArea() {
    return 2.0 * static_cast&lt;T *&gt;(this)-&gt;area();
  }
};

struct Triangle : public Shape&lt;Triangle&gt; {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() {
    return 0.5 * base * height;
  }
};

struct Square : public Shape&lt;Square&gt; {
  double side;

  Square(double side) : side(side) {}

  double area() {
    return side * side;
  }
};

int main() {
  Triangle triangle{2.0, 1.0};
  Square square{2.0};

  std::cout &lt;&lt; triangle.twiceArea() &lt;&lt; std::endl;
  std::cout &lt;&lt; square.twiceArea() &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;

    fn twice_area(&amp;self) -&gt; f64 {
        2.0 * self.area()
    }
}

struct Triangle {
    base: f64,
    height: f64,
}

impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Square {
    side: f64,
}

impl Shape for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn main() {
    let triangle = Triangle {
        base: 2.0,
        height: 1.0,
    };
    let square = Square { side: 2.0 };
    println!("{}", triangle.twice_area());
    println!("{}", square.twice_area());
}</code></pre></pre>
</div>
<p>The reason why nothing additional needs to be done for the default method to
invoke area statically in Rust is that calls to methods on <code>self</code> are always
resolved statically in Rust. This is possible because <a href="patterns/../idioms/data_modeling/inheritance_and_reuse.html">Rust does not have
inheritance between concrete
types</a>. Despite being defined in
the trait, the default method is actually implemented as part of the
implementing struct.</p>
<h2 id="method-chaining"><a class="header" href="#method-chaining">Method chaining</a></h2>
<p>Another common use for the CRTP is for implementing method chaining when an
implementation of a method to be chained is provided by a base class.</p>
<p>In C++ the template parameter is used to ensure that the type returned from the
shared function is that of the derived class, so that further methods defined in
the derived class can be called on it. The template parameter is also used to
call a method on the derived type without declaring the method as virtual.</p>
<p>In Rust the template parameter is not required because the <code>Self</code> type is
available in traits to refer to the type of the implementing struct.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;span&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// D is the type of the derived class
template &lt;typename D&gt;
struct Combinable {
  D combineWith(D &amp;d);

  // concat is implemented in the base class, but
  // operates on values of the derived class.
  D concat(std::span&lt;D&gt; vec) {
    D acc(*static_cast&lt;D *&gt;(this));

    for (D &amp;v : vec) {
      acc = acc.combineWith(v);
    }

    return acc;
  }
};

struct Sum : Combinable&lt;Sum&gt; {
  int sum;

  Sum(int sum) : sum(sum) {}

  Sum combineWith(Sum s) {
    return Sum(sum + s.sum);
  }

  // Sum includes an additional method that can be
  // chained.
  Sum mult(int n) {
    return Sum(sum * n);
  }
};

int main() {
  Sum s(0);
  std::vector&lt;Sum&gt; v{1, 2, 3, 4};
  Sum x = s.concat(v)
              // Even though concat is part of the
              // base class, it returns a value of
              // the implementing class, making it
              // possible to chain methods
              // specific to that class.
              .mult(2)
              .combineWith(5);
  std::cout &lt;&lt; x.sum &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// No generic type is required: Self already
// refers to implementing type.
trait Combinable {
    fn combine_with(&amp;self, other: &amp;Self) -&gt; Self;

    // concat has a default implementation in
    // terms of Self.
    fn concat(&amp;self, others: &amp;[Self]) -&gt; Self
    where
        Self: Clone,
    {
        let mut acc = self.clone();

        for v in others {
            acc = acc.combine_with(v);
        }
        acc
    }
}

#[derive(Clone)]
struct Sum(i32);

impl Sum {
    // Sum includes an additional method that can be
    // chained.
    fn mult(&amp;self, n: i32) -&gt; Self {
        Self(self.0 * n)
    }
}

impl Combinable for Sum {
    fn combine_with(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 + other.0)
    }
}

fn main() {
    let s = Sum(0);
    let v = vec![Sum(1), Sum(2), Sum(3), Sum(4)];
    let x = s
        .concat(&amp;v)
        // Even though concat is part of the
        // trait, it returns a value of the
        // implementing type, making it possible
        // to chain methods specific to that type.
        .mult(2)
        .combine_with(&amp;Sum(5));
    println!("{}", x.0)
}</code></pre></pre>
</div>
<p>Again, the reason why <code>Self</code> can refer to the implementing type is that <a href="patterns/../idioms/data_modeling/inheritance_and_reuse.html">Rust
does not have inheritance between concrete
types</a>. This contrasts with C++
where a value may be used at any number of types which are concrete, and so it
would not be clear which type something like <code>Self</code> should refer to.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;crtp&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Dynamic dispatch in Rust only occurs when invoking a method on a trait object.\nSome of the patterns used to ensure static dispatch is used in C++ are not\nneeded in Rust.\n&quot;,&quot;id&quot;:&quot;9dd51ab1-5e7a-441b-bc59-c80a73bde71f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`total += shape.area(); // 2`\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`2.0 * self.area() // 1`\n&quot;,&quot;`println!(\&quot;{}\&quot;, triangle.twice_area()); // 3`\n&quot;,&quot;`println!(\&quot;{}\&quot;, square.twice_area()); // 4`\n&quot;,&quot;`2.0 * self.area() // 1` when invoked via `sum_areas`.\n&quot;],&quot;prompt&quot;:&quot;In the following Rust program, which calls are resolved using dynamic dispatch?\n\n```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n\n    fn twice_area(&amp;self) -&gt; f64 {\n        2.0 * self.area() // 1\n    }\n}\n\nstruct Triangle {\n    base: f64,\n    height: f64,\n}\n\nimpl Shape for Triangle {\n    fn area(&amp;self) -&gt; f64 {\n        0.5 * self.base * self.height\n    }\n}\n\nstruct Square {\n    side: f64,\n}\n\nimpl Shape for Square {\n    fn area(&amp;self) -&gt; f64 {\n        self.side * self.side\n    }\n}\n\nfn sum_areas(shapes: &amp;[&amp;dyn Shape]) -&gt; f64 {\n    let mut total = 0.0;\n    for shape in shapes {\n        total += shape.area(); // 2\n    }\n    total\n}\n\nfn main() {\n    let triangle = Triangle {\n        base: 2.0,\n        height: 1.0,\n    };\n    let square = Square { side: 2.0 };\n    println!(\&quot;{}\&quot;, triangle.twice_area()); // 3\n    println!(\&quot;{}\&quot;, square.twice_area()); // 4\n\n    println!(\n        \&quot;{}\&quot;,\n        sum_areas(&amp;[&amp;triangle, &amp;square])\n    );\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="pointer-to-implementation-pimpl"><a class="header" href="#pointer-to-implementation-pimpl">Pointer-to-implementation (PIMPL)</a></h1>
<p>The <a href="https://en.cppreference.com/w/cpp/language/pimpl.html">PIMPL pattern</a> in
C++ is usually used for the purpose of improving compilation times by removing
implementation details from the ABI of a translation unit. It also can be used
to hide implementation details that otherwise would be exposed in a header file.</p>
<p>In Rust, the unit of separate compilation is the crate, rather than the file or
module. Within a crate, the compiler minimizes compilation times via incremental
compilation, rather than via separate compilation. Between crates, there is no
guarantee of Rust-native ABI stability, so if an upstream crate changes,
downstream crates need to be recompiled. Thus, for performance purposes, the
PIMPL pattern does not apply.</p>
<p>For the hiding of implementation details, <a href="patterns/../idioms/encapsulation.html">instead of excluding details from a
header file, modules can be used to control
visibility</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>C++ programs tend to either use libraries that come with operating system
distributions or that are vendored.</p>
<p>Rust programs tend to rely on a central registry of Rust libraries ("crates")
called <a href="https://crates.io/">crates.io</a> (along with a central documentation
repository created from the in-code documentation of those crates called
<a href="https://docs.rs/">docs.rs</a>). Dependencies on crates are managed using the
<a href="https://doc.rust-lang.org/cargo/index.html">Cargo package manager</a>.</p>
<p><a href="https://lib.rs/">Lib.rs</a> is a good resource for finding popular crates organized by category.</p>
<h2 id="some-specific-alternatives"><a class="header" href="#some-specific-alternatives">Some specific alternatives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>C++ library</th><th>Rust alternative</th></tr></thead><tbody>
<tr><td>STL UTF-16 and UTF-32 strings</td><td><a href="https://docs.rs/widestring/latest/widestring/">widestring</a></td></tr>
<tr><td>STL random</td><td><a href="https://github.com/rust-random/rand">rand</a></td></tr>
<tr><td>STL regex</td><td><a href="https://github.com/rust-lang/regex">regex</a></td></tr>
<tr><td>Reflection</td><td><a href="https://docs.rs/bevy_reflect/latest/bevy_reflect/">bevy_reflect</a></td></tr>
<tr><td>Boost.Test</td><td><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">cargo test</a></td></tr>
<tr><td>pybind11</td><td><a href="https://pyo3.rs/">PyO3</a></td></tr>
<tr><td>OpenSSL</td><td><a href="https://github.com/rustls/rustls">rustls</a></td></tr>
</tbody></table>
</div><!-- | STL `multiset`                |                                                             |
| STL `multimap`                |                                                             | -->
<p>If there is a C++ library that you use where you cannot find a Rust alternative,
please leave feedback using the link below, letting us know the name and purpose
of the library.</p>
<h2 id="supply-chain-management"><a class="header" href="#supply-chain-management">Supply chain management</a></h2>
<p>In situations where managing the library supply chain is important, Cargo can be
used either with <a href="https://doc.rust-lang.org/cargo/reference/registries.html">custom self-managed or organization-managed
registries</a> or with
<a href="https://doc.rust-lang.org/cargo/commands/cargo-vendor.html">vendored versions of dependencies fetched from
crates.io</a>.</p>
<p>Both approaches provide mechanisms for reviewing dependencies as part supply
chain security.</p>
<p>Solutions for supply chain security that do not involve vendoring or custom
registries are <a href="https://github.com/rust-lang/rfcs/pull/3724">in progress</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>This chapter gives a small example of testing in Rust by comparison to
<a href="https://github.com/boostorg/test">Boost.Test</a> for C++. A more thorough guide to
testing in Rust is available as part of the <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Rust
Book</a>, including
information on <a href="https://doc.rust-lang.org/stable/book/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">documentation
testing</a>.
Details on the built-in support for testing in
<a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc</a> and
<a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html">Cargo</a> are available
in their respective manuals.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>When using C++ test frameworks such as Boost.Test, tests are defined as
functions which are registered with the framework. The tests are compiled
against a test driver provided by the framework.</p>
<p>In Rust, testing is handled similarly. Unlike with C++, the test registration
mechanism and test driver are both provided by Rust itself.</p>
<p>Additionally, the way that tests are organized is different. In C++, unit tests
are defined in separate files from the units under test. In Rust, they are
typically defined in the same file, usually in a <code>test</code> sub-module, with
inclusion of the module controlled by the <code>test</code> feature flag via the
<code>#[cfg(test)]</code> annotation.</p>
<p>The example below defines a small class and tests for that class. In C++ this
involves creating three separate files: a header file for the interface, the
implementation of the interface, and the test driver. In Rust, this is all done
in a single file.</p>
<div class="comparison">
<pre><code class="language-cpp">// counter.h
#ifndef COUNTER_H
#define COUNTER_H

class Counter {
  unsigned int count;

public:
  Counter();
  unsigned int get();
  void increment();
};

#endif

// counter.cc
#include "counter.h"
Counter::Counter() : count(0) {}

unsigned int Counter::get() {
  return count;
}

void Counter::increment() {
  ++count;
}

// test_main.cc
#define BOOST_TEST_MODULE my_tests
#include &lt;boost/test/included/unit_test.hpp&gt;
#include "counter.h"

BOOST_AUTO_TEST_CASE(test_counter_initialize) {
  Counter c;
  BOOST_TEST(c.get() == 0);
}

BOOST_AUTO_TEST_CASE(test_counter_increment) {
  Counter c;
  c.increment();
  BOOST_TEST(c.get() == 1);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// counter.rs
pub struct Counter(u32);

impl Counter {
    pub fn new() -&gt; Counter {
        Counter(0)
    }

    pub fn get(&amp;self) -&gt; u32 {
        self.0
    }

    pub fn increment(&amp;mut self) {
        self.0 += 1;
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn counter_initialize() {
        let c = Counter::new();
        assert_eq!(0, c.get());
    }

    #[test]
    fn counter_increment() {
        let mut c = Counter::new();
        c.increment();
        assert_eq!(1, c.get());
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Defining unit tests within the module being tested has the benefit of making
internals of the module under test visible to the test code. This makes it
possible to unit test internal components without exposing them to the rest of
the program, as one would have to in C++ by including declarations in the header
file and by declaring test fixtures as <code>friend</code>s.</p>
<p>Running the tests in C++ involves linking against <code>boost_unit_test_framework</code>.
In Rust, the tests can be run with <code>cargo test</code>. If not using Cargo, the tests
can be compiled by passing the flag <code>--test</code> to rustc, and running the
executable produced.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h2>
<p>Integration tests as supported by Cargo, are still defined outside of the module
and outside of the crate, purely in terms of the exposed API.</p>
<p>See the <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">Rust
Book</a>
for details on how to organize integration tests for Rust programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-eg-doxygen"><a class="header" href="#documentation-eg-doxygen">Documentation (e.g., Doxygen)</a></h1>
<p>While C++ has several documentation tools, such as Doxygen and Sphinx, Rust has
a single documentation tool,
<a href="https://doc.rust-lang.org/rustdoc/index.html">Rustdoc</a>. Rustdoc is supported by
<a href="https://docs.rs/"><code>docs.rs</code></a>, cargo,
<a href="https://rust-analyzer.github.io/">rust-analyzer</a>, and is the tool used for
documenting <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#blanket-implementations">the standard
library</a>.
Rustdoc is installed by default with the Rust toolchain for most distributions.</p>
<p>The features and options available for Rustdoc are documented in the <a href="https://doc.rust-lang.org/rustdoc/">Rustdoc
Book</a>. The book also documents <a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">best
practices for documenting Rust
code</a>, which
differ slightly from the recommended practices for documenting C++ code using
Doxygen.</p>
<p>The Cargo integration is documented at in the Cargo book under the <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a> and <a href="https://doc.rust-lang.org/cargo/commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> commands,
as well as in the <a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html#documentation-tests">doctests
section</a>
of the <code>cargo test</code> command.</p>
<p>This chapter compares some aspects of Rustdoc with Doxygen in order to help with
understanding what to expect when using Rustdoc when coming from Doxygen or
similar C++ documentation tools.</p>
<h2 id="output-formats"><a class="header" href="#output-formats">Output formats</a></h2>
<p>Unlike Doxygen which can also produce PDF and man page output, Rustdoc only
produces HTML output. The produced documentation does include client-side
searching, which includes the ability to search by type signature.</p>
<p>The <a href="https://rust-analyzer.github.io/">rust-analyzer</a> language server supports
Rustdoc comments, and makes them available to editors with language server
protocol support on hover, even for Rustdoc comments in the current project.</p>
<h2 id="rustdoc-comment-syntax"><a class="header" href="#rustdoc-comment-syntax">Rustdoc comment syntax</a></h2>
<p>Unlike Doxygen, which has several supported comment syntaxes for C++, Rustup
supports a single comment syntax. Comments beginning with <code>//!</code> document the
top-level module or crate. Comments beginning with <code>///</code> document the following
item.</p>
<div class="comparison">
<pre><code class="language-cpp">/**
 * @file myheader.h
 * @brief A description of this file.
 *
 * A longer description, with examples, etc.
 */

/**
 * @brief A description of this class.
 *
 * A longr description, with examples, etc.
 */
struct MyClass {
  // ...
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! A description of this module or crate.
//!
//! A longer description, with examples, etc.

/// A description of this type.
///
/// A longer description, with examples, etc.
struct MyClass {
    // ...
}
<span class="boring">}</span></code></pre></pre>
</div>
<h3 id="special-forms"><a class="header" href="#special-forms">Special forms</a></h3>
<p>The content of the comment up until the first blank line is treated similarly to
the <code>@brief</code> form in Doxygen.</p>
<p>Aside from that, Rustdoc does not have special forms for documenting various
parts of an item, such as the parameters of a function. Instead, <a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html#markdown">Markdown
syntax can be
used</a>
to format the documentation, which is otherwise given in prose.</p>
<p>There are several common conventions used for structuring documentation
comments. The most common convention is to include sections (defined using
Markdown header syntax) for whichever of the following are necessary for the
item being documented:</p>
<ul>
<li>panics (for functions that panic, e.g., on
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#panics-32"><code>Vec::split_at</code></a>),</li>
<li>safety (for unsafe functions, e.g., on
<a href="https://doc.rust-lang.org/std/primitive.slice.html#safety-10"><code>Vec::split_at_unchecked</code></a>),
and</li>
<li>examples (e.g., on <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#examples-105"><code>Vec::split_at</code></a>).</li>
</ul>
<p>The following comment compares documentation for a C++ function using Doxygen to
documentation for a Rust function using Rustdoc.</p>
<div class="comparison">
<a id="special-forms-comparison"></a>
<pre><code class="language-cpp">/**
 * @brief Computes the factorial.
 *
 * Computes the factorial in a stack-safe way.
 * The factorial is defined as...
 *
 * @code
 * #include &lt;cassert&gt;
 * #include "factorial.h"
 *
 * int main() {
 *    int res = factorial(3);
 *    assert(6 == res);
 * }
 * @endcode
 *
 * @param n The number of which to take the factorial
 *
 * @return The factorial
 *
 * @exception domain_error If n &lt; 0
 */
int factorial(int n);
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Computes the factorial.
///
/// Computes the factorial in a stack-safe way.
/// The factorial is defined as...
///
/// # Examples
///
/// ```
/// let res = factorial(3);
/// assert_eq!(6, res);
/// ```
///
/// # Panics
///
/// Requires that `n &gt;= 0`, otherwise panics.
/// For the non-panicking version see
/// [`factorial_checked`].
fn factorial(n: i32) -&gt; i32 {
    // ...
<span class="boring">   todo!()
</span>}
<span class="boring">}</span></code></pre></pre>
<div>
<h3 id="automatic-documentation"><a class="header" href="#automatic-documentation">Automatic documentation</a></h3>
<p>Many of the things that can be derived from the code are automatically included
by Rustdoc. A major one is that trait implementations (e.g., on
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#trait-implementations"><code>Vec</code></a>),
including blanket implementations (e.g., on
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#blanket-implementations"><code>Vec</code></a>),
for a type do not have to be documented manually because implementations that
are visible in the crate are automatically discovered and included by Rustdoc.</p>
<h1 id="additional-features"><a class="header" href="#additional-features">Additional features</a></h1>
<p>Some valuable Rustdoc features may not be expected by someone coming from using
Doxygen. Because those features provide significant benefit, they are pointed
out here.</p>
<h2 id="doctest-support-via-rustdoc-and-cargo-test"><a class="header" href="#doctest-support-via-rustdoc-and-cargo-test">Doctest support via Rustdoc and <code>cargo test</code></a></h2>
<p>One specific benefit of including examples when documenting Rust programs using
Rustdoc is that <a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">the examples can be included in the test suite when running
<code>cargo test</code></a>.</p>
<p>The handling of examples as tests in Rustdoc includes logic for handling partial
programs, so that even <a href="etc/documentation.html#special-forms-comparison">the code example in the earlier
comparison</a> can serve as a test.</p>
<h2 id="local-documentation-for-project-and-installed-libraries"><a class="header" href="#local-documentation-for-project-and-installed-libraries">Local documentation for project and installed libraries</a></h2>
<p>Local documentation for both the working project and dependent libraries can be
viewed in-browser using <code>cargo doc --open</code>. Private items for the project can be
included in the documentation by using <code>cargo doc --open --document-private-items</code>. Because Rustdoc comments are also used by the
<a href="https://rust-analyzer.github.io/">rust-analyzer</a> language server to provide
documentation on hover in compatible editors, it is often worth it to document
private items using Rustdoc comments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-systems-eg-cmake"><a class="header" href="#build-systems-eg-cmake">Build systems (e.g., CMake)</a></h1>
<p>One major difference between the C++ and Rust ecosystems is that C++ and C
libraries tend to be either provided by OS distributions or be included in the
repository for a project, while Rust has a central language-specific package
registry called <a href="https://crates.io/">crates.io</a>.</p>
<p>This difference is amplified by the fact that the Rust build tool, Cargo, has a
build in package manager that works with crates.io, private registries, local
packages, and vendored sources.</p>
<p>Cargo is documented in detail in the <a href="https://doc.rust-lang.org/cargo/">Cargo
Book</a>.</p>
<h2 id="packages-for-c-and-c-system-libraries"><a class="header" href="#packages-for-c-and-c-system-libraries">Packages for C and C++ system libraries</a></h2>
<p>Many C libraries have crates on crates.io providing both low-level bindings and
high-level safe Rust abstractions. For example, for the libgit2 library there is
both a low-level <a href="https://crates.io/crates/libgit2-sys">libgit2-sys crate</a> and a
high-level <a href="https://crates.io/crates/git2">git2 crate</a>. See the <a href="etc/../idioms/ffi.html">chapter on the
Rust FFI</a> for more information on how to define these crates.</p>
<h2 id="building-c-c-and-rust-code"><a class="header" href="#building-c-c-and-rust-code">Building C, C++, and Rust code</a></h2>
<p>Cargo <a href="https://doc.rust-lang.org/cargo/reference/build-script-examples.html">build
scripts</a>
can be used to build C and C++ code as part of a Rust project. The linked
chapter of the Cargo book includes links to resources handling the compilation
of C, C++, and other code, working with <code>pkg-config</code>, etc.</p>
<h2 id="testing-ctest"><a class="header" href="#testing-ctest">Testing (CTest)</a></h2>
<p>Cargo includes support for <a href="https://doc.rust-lang.org/cargo/guide/tests.html">running
tests</a>.</p>
<h2 id="packaging-for-distribution-cpack"><a class="header" href="#packaging-for-distribution-cpack">Packaging for distribution (CPack)</a></h2>
<p>Unlike CPack which is provided with CMake, Cargo does not come with tools for
packaging for distribution to end users. However, there are third party Cargo
helpers for packaging, such as <a href="https://crates.io/crates/cargo-deb">cargo-deb</a>
for creating Debian package,
<a href="https://crates.io/crates/cargo-generate-rpm">cargo-generate-rpm</a> for creating
RPM packages, and <a href="https://crates.io/crates/cargo-wix">cargo-wix</a> for creating
Windows installers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribution-notices"><a class="header" href="#attribution-notices">Attribution notices</a></h1>
<p>This book makes use of the Standard C++ Foundation logo under their posted
<a href="https://isocpp.org/home/terms-of-use">terms of use</a>.</p>
<p>This book makes use of the Rust logo, including a modified version of the logo,
under the Creative Commons CC-BY license, as posted in the <a href="https://github.com/rust-lang/rust-artwork">rust-artwork
repository</a> and under the posted
<a href="https://rustfoundation.org/policy/rust-trademark-policy/">terms of use</a> for the
trademark.</p>


                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q3W4ES0FTM"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q3W4ES0FTM');
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="telemetry/dist/telemetry.iife.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
