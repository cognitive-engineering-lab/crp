<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ to Rust Phrasebook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c-to-rust-phrasebook"><a class="header" href="#c-to-rust-phrasebook">C++ to Rust Phrasebook</a></h1>
<p>The goal of this book is to make programming in Rust less frustrating for C++
programmers by providing translations of common C++ idioms and patterns into
idiomatic Rust. Along with the translations, we provide descriptions of the engineering trade-offs involved.
The translations are often not straightforward transliterations. They demonstrate how to holistically
follow Rust's philosophy in addressing systems programming problems through the lens of comparable C++ idioms.</p>
<p>The book can be read front-to-back, but is designed to be used random-access:
when you are writing Rust code and think, "I know how to do this in C++ but not Rust", then
look for the corresponding chapter in this book.
The chapters are also organized around C++ concepts instead of Rust concepts, to
aid C++ programmers in finding a specific solution to a problem in terms that
will be natural to them while they are learning Rust.</p>
<p><strong>This iteration is a first draft of a subset of the full book. Our current goal is to get early feedback on the utility of this format before writing the remaining chapters.</strong></p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>If you are not primarily a C or C++ programmer, <a href="https://rust-book.cs.brown.edu/">The Rust Programming
Language</a> may be a better starting point.</p>
<p>If you are primarily an embedded systems programmer using C or C++, this book is
a complement to <a href="https://docs.rust-embedded.org/book/">The Embedded Rust Book</a>.</p>
<h2 id="feedback-on-this-book"><a class="header" href="#feedback-on-this-book">Feedback on this book</a></h2>
<p>We're seeking feedback on this book! At the bottom of every page there is a link
to a form where you can submit feedback. Whether you've found a mistake or just
want to let us know which topic you'd like us to cover next, use the form to
send us a message!</p>
<p>This book is incomplete and may include links to chapters that have not yet been
published. If you encounter such a link and want us to prioritize that chapter,
let us know using the feedback form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-modeling"><a class="header" href="#data-modeling">Data modeling</a></h1>
<p>In C++ the mechanisms available for data modeling are classes, enums, and
unions.</p>
<p>Rust, on the other hand, uses records
(<a href="https://doc.rust-lang.org/book/ch05-00-structs.html">structs</a>) and algebraic
data types (<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">enums</a>).</p>
<p>Although Rust supports one major piece of object oriented design, polymorphism
using interfaces, Rust also has language features for modeling things using
algebraic data types (which in simple cases are like a much more ergonomic
<code>std::variant</code>).</p>
<p>This section gives examples of common constructions used when programming in C++
and how to achieve the same effects using Rust's features.</p>
<h2 id="fixed-operations-varying-data"><a class="header" href="#fixed-operations-varying-data">Fixed operations, varying data</a></h2>
<p>In situations where one needs to model a fixed set of operations that clients
will use, but the data that implements those operations are not fixed ahead of
time, the approach in C++ and the approach in Rust are the same. In both cases
interfaces that defines the required operations are defined. Concrete types,
possibly defined by the client, implement those interfaces.</p>
<p>This way of modeling data can make use of either
<a href="idioms//idioms/data_modeling/abstract_classes.html">dynamic</a> or <a href="idioms//idioms/data_modeling/concepts.html">static
dispatch</a>, each of which is covered in its
own section.</p>
<h2 id="fixed-data-varying-operations"><a class="header" href="#fixed-data-varying-operations">Fixed data, varying operations</a></h2>
<p>In situations where there is a fixed set of data but the operations that the
data must support vary, there are a few approaches in C++. Which approaches are
available to use depend on the version of the standard in use.</p>
<p>In older versions of the standard, one might use manually defined tagged unions.
In newer versions, <code>std::variant</code> is available to improve the safety and
ergonomics of tagged unions. <a href="idioms//idioms/data_modeling/tagged_unions.html">Both of these approaches map to the same approach
in Rust</a>.</p>
<p>Additionally, despite it not being strictly necessary to model a fixed set of
variants, the visitor pattern is sometimes used for this situation, especially
when using versions of the C++ standard before the introduction of
<code>std::variant</code>. In most of these cases the idiomatic Rust solution is the same
as what one would do when converting a C++ solution that uses tagged unions. The
chapter on the <a href="idioms/TODO">visitor pattern</a> describes when to use a Rust version of
the visitor pattern or when to use Rust's enums (which are closer to
<code>std::variant</code> than to C++ enums) to model the data.</p>
<h2 id="varying-data-and-operations"><a class="header" href="#varying-data-and-operations">Varying data and operations</a></h2>
<p>When both data and operations may be extended by a client, the <a href="idioms/TODO">visitor pattern
is used in both C++ and in Rust</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes-interfaces-and-dynamic-dispatch"><a class="header" href="#abstract-classes-interfaces-and-dynamic-dispatch">Abstract classes, interfaces, and dynamic dispatch</a></h1>
<p>In C++ when an interface will be used with dynamic dispatch to resolve invoked
methods, the interface is defined using an abstract class. Types that implement
the interface inherit from the abstract class. In Rust the interface is given by
a <em>trait</em>, which is then implemented for the types that support that trait.
Programs can then be written over <em>trait objects</em> that use that trait as their
base type.</p>
<p>The following example defines an interface, two implementations of that
interface, and a function that takes an argument that satisfies the interface.
In C++ the interface is defined with an abstract class with pure virtual
methods, and in Rust the interface is defined with a trait. In both languages,
the function (<code>printArea</code> in C++ and <code>print_area</code> in Rust) invokes a method
using dynamic dispatch.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

// Define an abstract class for an interface
struct Shape {
  Shape() = default;
  virtual ~Shape() = default;
  virtual double area() = 0;
};

// Implement the interface for a concrete class
struct Triangle : public Shape {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() override {
    return 0.5 * base * height;
  }
};

// Implement the interface for a concrete class
struct Rectangle : public Shape {
  double width;
  double height;

  Rectangle(double width, double height)
      : width(width), height(height) {}

  double area() override {
    return width * height;
  }
};

// Use an object via a reference to the interface
void printArea(Shape &amp;shape) {
  std::cout &lt;&lt; shape.area() &lt;&lt; std::endl;
}

int main() {
  Triangle triangle = Triangle{1.0, 1.0};

  printArea(triangle);

  // Use an object via an owned pointer to the
  // interface
  std::unique_ptr&lt;Shape&gt; shape;
  if (true) {
    shape = std::make_unique&lt;Rectangle&gt;(1.0, 1.0);
  } else {
    shape = std::make_unique&lt;Triangle&gt;(
        std::move(triangle));
  }

  // Convert to a reference to the interface
  printArea(*shape);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define an interface
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

// Implement the interface for a concrete type
impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }
}

// Use a value via a reference to the interface
fn print_area(shape: &amp;dyn Shape) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    print_area(&amp;triangle);

    // Use a value via an owned pointer to the
    // interface
    let shape: Box&lt;dyn Shape&gt; = if true {
        Box::new(Rectangle {
            width: 1.0,
            height: 1.0,
        })
    } else {
        Box::new(triangle)
    };

    // Convert to a reference to the interface
    print_area(shape.as_ref());
}</code></pre></pre>
</div>
<p>There are several places where the Rust implementation differs slightly from the
C++ implementation.</p>
<p>In Rust, a trait's methods are always visible whenever the trait itself is
visible. Additionally, the fact that a type implements a trait is always visible
whenever both the trait and the type are visible. These properties of Rust
explain the lack of visibility declarations in places where one might find them
in C++.</p>
<p>In C++, to associate methods with a type rather than value of that type, you use
the <code>static</code> keyword. In Rust, non-static methods take an explicit <code>self</code> parameter.
This syntactic choice makes it possible to indicate (in way similar to other parameters) whether the
method mutates the object (by taking <code>&amp;mut self</code> instead of <code>&amp;self</code>) and whether
it takes ownership of the object (by taking <code>self</code> instead of <code>&amp;self</code>).</p>
<p>Rust methods do not need to be declared as virtual. Because of differences in
vtable representation, all methods for a type are available for dynamic
dispatch. Types of values that use vtables are indicated with the <code>dyn</code> keyword.
This is further described <a href="idioms/data_modeling/abstract_classes.html#vtables-and-rust-trait-object-types">below</a>.</p>
<p>Additionally, Rust does not have an equivalent for the virtual destructor
declaration because in Rust every vtable includes the drop behavior (whether
given by a user defined <code>Drop</code> implementation or not) required for the value.</p>
<h2 id="vtables-and-rust-trait-object-types"><a class="header" href="#vtables-and-rust-trait-object-types">Vtables and Rust trait object types</a></h2>
<p>C++ and Rust both requires some kind of indirection to perform dynamic dispatch
against an interface. In C++ this indirection takes the form of a pointer to the
abstract class (instead of the derived concrete class), making use of a vtable
to resolve the virtual method.</p>
<p>In the above Rust example, the type <code>dyn Shape</code> is the type of a trait object
for the <code>Shape</code> trait. A trait object includes a vtable along with the
underlying value.</p>
<p>In C++ all objects whose class inherits from a class with a virtual method have
a vtable in their representation, whether dynamic dispatch is used or not.
Pointers or references to objects are the same size as pointers to objects
without virtual methods, but every object includes its vtable.</p>
<p>In Rust, vtables are present only when values are represented as trait objects.
The reference to the trait object is twice the size of a normal reference since
it includes both the pointer to the value and the pointer to the vtable. In the
Rust example above, the local variable <code>triangle</code> in <code>main</code> does not have a
vtable in its representation, but when the reference to it is converted to a
reference to a trait object (so that it can be passed to <code>print_area</code>), that
does include a pointer to the vtable.</p>
<p>Additionally, just as abstract classes in C++ cannot be used as the type of a
local variable, the type of a parameter of a function, or the type of a return
value of a function, trait object types in Rust cannot be used in corresponding
contexts. In Rust, this is enforced by the type <code>dyn Shape</code> not implementing the
<code>Sized</code> marker trait, preventing it from being used in contexts that require
knowing the size of a type statically.</p>
<p>The following example shows some places where a trait object type can and cannot
be used due to not implementing <code>Sized</code>. The uses forbidden in Rust would also
be forbidden in C++ because <code>Shape</code> is an abstract class.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // Local variables must have a known size.
    // let v: dyn Shape = Triangle { base: 1.0, height: 1.0 };

    // References always have a known size.
    let shape: &amp;dyn Shape = &amp;Triangle {
        base: 1.0,
        height: 1.0,
    };
    // Boxes also always have a known size.
    let boxed_shape: Box&lt;dyn Shape&gt; = Box::new(Triangle {
        base: 1.0,
        height: 1.0,
    });

    // Types like Option&lt;T&gt; the value of type T directly, and so also need to
    // know the size of T.
    // let v: Option&lt;dyn Shape&gt; = Some(Triangle { base: 1.0, height: 1.0 });
}

// Parameter types must have a known size.
// fn print_area(shape: dyn Shape) { }
fn print_area(shape: &amp;dyn Shape) {}</code></pre></pre>
<p>The decision to include the vtable in the reference instead of in the value is
one part of what makes it reasonable to use traits both for polymorphism via
dynamic dispatch and for <a href="idioms/data_modeling//idioms/data_modeling/concepts.html">polymorphism via static dispatch, where one would use
concepts in C++</a>.</p>
<h2 id="limitations-of-trait-objects-in-rust"><a class="header" href="#limitations-of-trait-objects-in-rust">Limitations of trait objects in Rust</a></h2>
<p>In Rust, not all traits can be used as the base trait for trait objects. The
most commonly encountered restriction is that traits that require knowledge of
the object's size via a <code>Sized</code> supertrait are not <code>dyn</code>-compatible. There are
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">additional
restrictions</a>.</p>
<h2 id="trait-objects-and-lifetimes"><a class="header" href="#trait-objects-and-lifetimes">Trait objects and lifetimes</a></h2>
<p>Objects which are used with dynamic dispatch may contain pointers or references
to other objects. In C++ the lifetimes of those references must be tracked
manually by the programmer.</p>
<p>Rust checks the bounds on the lifetimes of references that the trait objects may
contain. If the bounds are not given explicitly, they are determined according
to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#r-lifetime-elision.trait-object">lifetime elision
rules</a>.
The bound is part of the type of the trait object.</p>
<p>Usually the elision rules pick the correct lifetime bound. Sometimes, the rules
result in surprising error messages from the compiler. In those situations or
when the compiler cannot determine which lifetime bound to assign, the bound may
be given manually. The following example shows explicitly what the inferred
lifetimes are for a structure storing a trait object and for the <code>print_area</code>
function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Shape {
</span><span class="boring">    fn area(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {
</span><span class="boring">    fn area(&amp;self) -&gt; f64 {
</span><span class="boring">        0.5 * self.base * self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Scaled {
    scale: f64,
    // 'static is the lifetime that would be inferred by the lifetime elision
    // rule [lifetime-elision.trait-object.default].
    shape: Box&lt;dyn Shape + 'static&gt;,
}

impl Shape for Scaled {
    fn area(&amp;self) -&gt; f64 {
        self.scale * self.shape.area()
    }
}

// These are the lifetimes that would be inferred by the lifetime elision rule
// [lifetime-elision.function.implicit-lifetime-parameters] for the reference
// and [lifetime-elision.trait-object.containing-type-unique] for the trait
// bound.
fn print_area&lt;'a&gt;(shape: &amp;'a (dyn Shape + 'a)) {
    println!("{}", shape.area());
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };
    print_area(&amp;triangle);

    let scaled_triangle = Scaled {
        scale: 2.0,
        shape: Box::new(triangle),
    };
    print_area(&amp;scaled_triangle);
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;abstract_classes&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;507115c6-4ed1-4a16-9f40-f5a01d3830a8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\ntrait Iterable {\n  type Item;\n  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nstruct Iterable&lt;Item&gt; {}\nimpl&lt;Item&gt; Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\nstruct Iterable&lt;Item&gt; {\n  fn next(&amp;mut self) -&gt; Option&lt;Item&gt;;\n}\n```\n&quot;,&quot;```rust\ntrait Iterable {\n  type Item;\n  fn new() -&gt; Self;\n  fn drop(self);\n  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n```\n&quot;],&quot;prompt&quot;:&quot;For the following C++ abstract virtual class, which of the following snippets represents the most idiomatic translation into Rust?\n```cpp\ntemplate&lt;typename Item&gt;\nstruct Iterable {\n  Iterable() {};\n  virtual ~Iterable() {};\n  virtual Item* next() = 0;\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-interfaces-and-static-dispatch"><a class="header" href="#concepts-interfaces-and-static-dispatch">Concepts, interfaces, and static dispatch</a></h1>
<p>In C++, static dispatch over an interface is achieved by implementing a template
function or template method that interacts with the type using some expected
interface.</p>
<p>The template function <code>twiceArea</code> in the example below makes use of an <code>area()</code>
method on the template type parameter.</p>
<p>To achieve the same goal in Rust involves defining a trait (<code>Shape</code>) with the
desired method (<code>twice_area</code>) and using the trait as a bound on the type
parameter for the generic function.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  // NOT virtual: it will be used with static dispatch
  double area() {
    return 0.5 * base * height;
  }
};

// Generic function using interface
template &lt;class T&gt;
double twiceArea(T &amp;shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Interface that generic function will use
trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Triangle {
    base: f64,
    height: f64,
}

// Implementation of interface for type
impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

// Generic function using interface
fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}

fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 1.0,
    };

    println!("{}", twice_area(&amp;triangle));
}</code></pre></pre>
</div>
<p>Note that in the Rust example, the definition of the trait and the struct have
not changed from the example in the chapter on <a href="idioms/data_modeling//idioms/data_modeling/abstract_classes.html">virtual methods and dynamic
dispatch</a>. Even so, this example
does use static dispatch. This is the result of a design trade-off in Rust
around the representation of vtables and vptrs which is <a href="idioms/data_modeling//idioms/data_modeling/abstract_classes.html#vtables-and-rust-trait-object-types">described later in that
chapter</a>.</p>
<p>The difference between Rust and C++ in the above examples arises from Rust being
nominally typed (types must opt in to supporting a specific interface, merely
having the right methods isn't enough) and C++'s template meta-programming
enabling a kind of structural or duck typing (types only need to have the
methods actually used, and there is no need to explicitly opt in to supporting
an interface).</p>
<h2 id="templates-vs-generic-functions"><a class="header" href="#templates-vs-generic-functions">Templates vs generic functions</a></h2>
<p>The reason why Rust is nominally typed instead of structurally typed has to do
with the difference between C++ templates and Rust generic functions. In
particular, C++ templates are only type checked after all of the template
arguments are provided and they are fully expanded, while Rust generic functions
are type checked independently of the type arguments.</p>
<p>Since the functions are checked before the type arguments are known, the methods
and functions that can be applied to values of those types also need to be known
before the type arguments are known.</p>
<p>This point in the programming language design space favors simplicity of
reasoning about these functions over the flexibility that comes from the
template programming approach. This becomes especially valuable when writing
libraries that both provide generic functions defined in terms of other generic
functions, for which a C++ compiler can give many fewer static guarantees, since
it would not be possible to test all possible instantiations.</p>
<p>In both C++ and Rust, however, multiple implementations are generated by the
compiler in order to achieve static dispatch.</p>
<h2 id="c-constraints-and-concepts"><a class="header" href="#c-constraints-and-concepts">C++ constraints and concepts</a></h2>
<p>Rust's approach to static dispatch over an interface can be partially (but only
partially) modeled with a strict application of <a href="https://en.cppreference.com/w/cpp/language/constraints">C++
concepts</a>.</p>
<p>The usual way to apply concepts is still structural and does not model Rust's
approach: it only requires that a method with specific properties be present on
the type.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

template &lt;typename T&gt;
concept shape = requires(T t) {
  { t.area() } -&gt; std::same_as&lt;double&gt;;
};

template &lt;shape T&gt;
double twiceArea(T shape) {
  return shape.area() * 2;
}
</code></pre>
<p>A closer equivalent to the above Rust program in C++ is to use a combination of
abstract classes and concepts.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

struct Triangle : Shape {
  double base;
  double height;

  Triangle(double base, double height) : base(base), height(height) {}

  // still NOT virtual: will be used static dispatch
  double area() override {
    return 0.5 * base * height;
  }
};

template &lt;shape T&gt;
double twiceArea(T shape) {
  return shape.area() * 2;
}

int main() {
  Triangle triangle{1.0, 1.0};

  std::cout &lt;&lt; twiceArea(triangle) &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>This is still not the same, however, because the concept only creates a
requirement on the use of the template, not on the use of values of type <code>T</code>
within the template. In Rust, the trait bound constrains both. So the following
still compiles in C++.</p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

struct Shape {
  Shape() {}
  virtual ~Shape() {}
  virtual double area() = 0;
};

template &lt;typename T&gt;
concept shape = std::derived_from&lt;T, Shape&gt;;

template &lt;shape T&gt;
double twiceArea(T shape) {
  // note the call to a method not defined in Shape
  return shape.volume() * 2;
}
</code></pre>
<p>However, the equivalent does not compile in Rust and instead produces an error.</p>
<pre><code class="language-rust ignore">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    // note the call to a method not defined in Shape
    2.0 * shape.volume()
}</code></pre>
<pre><code class="language-text">error[E0599]: no method named `volume` found for reference `&amp;T` in the current scope
 --&gt; example.rs:7:17
  |
7 |     2.0 * shape.volume()
  |                 ^^^^^^ method not found in `&amp;T`
</code></pre>
<p>These additional static checks mean that in many situations where C++ templates
would be useful but hard to implement correctly, Rust generics are freely used.</p>
<h2 id="required-traits-and-ergonomics"><a class="header" href="#required-traits-and-ergonomics">Required traits and ergonomics</a></h2>
<p>In the above examples, the function requiring a trait was defined like the following.</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T: Shape&gt;(shape: &amp;T) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
<p>This is a commonly used shorthand for the following:</p>
<pre><code class="language-rust ignore">fn twice_area&lt;T&gt;(shape: &amp;T) -&gt; f64
where
    T: Shape,
{
    2.0 * shape.area()
}</code></pre>
<p>The more verbose form is preferred when there are many type parameters or those
type parameters must implement many traits. An even shorter-hand available in some
cases is the <code>impl</code> keyword:</p>
<pre><code class="language-rust ignore">fn twice_area(shape: &amp;impl Shape) -&gt; f64 {
    2.0 * shape.area()
}</code></pre>
<h2 id="generics-and-lifetimes"><a class="header" href="#generics-and-lifetimes">Generics and lifetimes</a></h2>
<p>When defining a template in C++ that makes use of a type template parameter, the
lifetimes of references stored within objects of that type must be tracked
manually by the programmer.</p>
<p>The following (contrived) C++ example compiles without error, but could be used
in a way that results in undefined behavior.</p>
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">
</span><span class="boring">struct Shape {
</span><span class="boring">  Shape() {}
</span><span class="boring">  virtual ~Shape() {}
</span><span class="boring">  virtual double area() = 0;
</span><span class="boring">};
</span><span class="boring">
</span>template&lt;typename S&gt;
void store(S s, std::unique_ptr&lt;Shape&gt; data) {
    // Will pointers or references in `s` become dangling while `data`
    // is still in use?
	*data = s;
}
</code></pre>
<p>Rust checks the bounds on lifetimes of references contained within type
parameters. <a href="idioms/data_modeling//idioms/data_modeling/abstract_classes.html#trait-objects-and-lifetimes">Just as with trait object
types</a>,
these bounds are usually inferred according to the <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision
rules</a>. When they
cannot be inferred, or they are inferred incorrectly, the bounds can be declared
manually.</p>
<p>In the Rust transliteration of the above example, the lifetime bounds have to be
given manually because the inferred bounds are incorrect. Without explicit
bounds, the compiler produces an error.</p>
<pre><code class="language-rust ignore"><span class="boring">trait Shape {}
</span><span class="boring">
</span>fn store&lt;S: Shape&gt;(x: S, data: &amp;mut Box&lt;dyn Shape&gt;) {
    *data = Box::new(x);
}</code></pre>
<pre><code class="language-text">error[E0310]: the parameter type `S` may not live long enough
 --&gt; example.rs:7:5
  |
7 |     *data = Box::new(x);
  |     ^^^^^
  |     |
  |     the parameter type `S` must be valid for the static lifetime...
  |     ...so that the type `S` will meet its required lifetime bounds
  |
</code></pre>
<p>The error message becomes clearer when the inferred lifetime bounds are made
explicit. With the given type for <code>store</code>, the argument for <code>x</code> could be
something that has a lifetime that does not last as long as the lifetimes in the
contents in the box.</p>
<pre><code class="language-rust ignore"><span class="boring">trait Shape {}
</span><span class="boring">
</span><span class="boring">struct Triangle {
</span><span class="boring">    base: f64,
</span><span class="boring">    height: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Shape for Triangle {}
</span><span class="boring">
</span>// The type parameter S is assigned no lifetime bound.
fn store&lt;'a, S: Shape&gt;(
    x: S,
    // The reference is assigned a fresh lifetime by rule
    // [lifetime-elision.function.implicit-lifetime-parameters].
    //
    // The trait object is assigned 'static by rule
    // [lifetime-elision.trait-object.default] and
    // [lifetime-elision.trait-object.innermost-type].
    data: &amp;'a mut Box&lt;dyn Shape + 'static&gt;,
) {
    *data = Box::new(x);
}

// An example of how the implementation of store could be misused with
// the given type.
fn main() {
    let triangle = Triangle {
        base: 1.0,
        height: 2.0,
    };
    let mut b: Box&lt;dyn Shape&gt; = Box::new(triangle);
    {
        let short_lived_triangle = Triangle {
            base: 5.0,
            height: 10.0,
        };
        store(short_lived_triangle, &amp;mut b);
    }
    // Here b contains a dangling reference.
}</code></pre>
<p>For this specific case, the most general solution is to define a new lifetime
parameter to bound both <code>S</code> and <code>dyn Shape</code>. The type parameter for the
reference can be elided, because it will be assigned a fresh lifetime parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape {}

// Note the common bound
// -----------------here-\
// ----------------------|---------------------------and here-\
//                       v                                    v
fn store&lt;'s, S: Shape + 's&gt;(x: S, data: &amp;mut Box&lt;dyn Shape + 's&gt;) {
    *data = Box::new(x);
}
<span class="boring">}</span></code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;concepts&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust needs to know that the type of `Scaled::shape` supports the `area` method,\nso a trait bound on the type parameter is necessary. Trait implementations are\nall or nothing, so the requirement applies to the whole implementation, not the\nindividual method.\n&quot;,&quot;id&quot;:&quot;3cb5759b-5fe0-491e-ac87-4ba455b26e8f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T: Shape&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;,&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64\n    where\n        T: Shape,\n    {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;,&quot;```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Scaled&lt;T: Shape&gt; {\n    scale: f64,\n    shape: T,\n}\n\nimpl&lt;T&gt; Shape for Scaled&lt;T&gt; {\n    fn area(&amp;self) -&gt; f64 {\n        self.scale * self.shape.area()\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Consider the following C++ program.\n\n```cpp\ntemplate&lt;typename T&gt;\nstruct Scaled {\n\tdouble scale;\n\tT shape;\n\n\tdouble area() const {\n\t\treturn scale * shape.area();\n\t}\n};\n\ntemplate &lt;typename T&gt;\nvoid printArea(T &amp;shape) {\n\tstd::cout &lt;&lt; shape.area() &lt;&lt; std::endl;\n}\n```\n\nWhich of the following snippets represents the most idiomatic translation of the\n`Scaled` template class into Rust?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-unions-and-stdvariant"><a class="header" href="#tagged-unions-and-stdvariant">Tagged unions and <code>std::variant</code></a></h1>
<h2 id="c-style-tagged-unions"><a class="header" href="#c-style-tagged-unions">C-style tagged unions</a></h2>
<p>Because unions cannot be used for type punning in C++, they are usually used
with a tag to discriminate between which variant of the union is active.</p>
<p>Rust's equivalent to union types are always tagged. They are a generalization of
Rust enums, where additional data may be associated with the enum variants.</p>
<div class="comparison">
<pre><code class="language-cpp">enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };

  double area() {
    switch (this-&gt;tag) {
    case Rectangle: {
      return this-&gt;rectangle.width *
             this-&gt;rectangle.height;
    }
    case Triangle: {
      return 0.5 * this-&gt;triangle.base *
             this-&gt;triangle.height;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
            Shape::Triangle { base, height } =&gt; {
                0.5 * base * height
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>When matching on an enum, Rust requires that all variants of the enum be
handled. In situations where <code>default</code> would be used with a C++ <code>switch</code> on the
tag, a wildcard can be used in the Rust <code>match</code>.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;iostream&gt;
</span><span class="boring">
</span><span class="boring">enum Tag { Rectangle, Triangle, Circle };
</span><span class="boring">
</span>struct Shape {
<span class="boring">  Tag tag;
</span><span class="boring">  union {
</span><span class="boring">    struct {
</span><span class="boring">      double width;
</span><span class="boring">      double height;
</span><span class="boring">    } rectangle;
</span><span class="boring">    struct {
</span><span class="boring">      double base;
</span><span class="boring">      double height;
</span><span class="boring">    } triangle;
</span><span class="boring">    struct {
</span><span class="boring">      double radius;
</span><span class="boring">    } circle;
</span><span class="boring">  };
</span><span class="boring">
</span>  void print_shape() {
    switch (this-&gt;tag) {
    case Rectangle: {
      std::cout &lt;&lt; "Rectangle" &lt;&lt; std::endl;
      break;
    }
    default: {
      std::cout &lt;&lt; "Some other shape"
                &lt;&lt; std::endl;
      break;
    }
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn print_shape(&amp;self) {
        match self {
            Shape::Rectangle { .. } =&gt; {
                println!("Rectangle");
            }
            _ =&gt; {
                println!("Some other shape");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Rust does not support C++-style fallthrough where some behavior can be done
before falling through to the next case. However, in Rust one can match on
multiple enum variants simultaneously, so long as the simultaneous match
patterns bind the same names with the same types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Shape {
</span><span class="boring">    Rectangle { width: f64, height: f64 },
</span><span class="boring">    Triangle { base: f64, height: f64 },
</span><span class="boring">}
</span><span class="boring">
</span>impl Shape {
    fn bounding_area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { height, width }
            | Shape::Triangle {
                height,
                base: width,
            } =&gt; width * height,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-the-value-without-checking-the-discriminant"><a class="header" href="#accessing-the-value-without-checking-the-discriminant">Accessing the value without checking the discriminant</a></h2>
<p>Unlike with C-style unions, Rust always requires matching on the discriminant
before accessing the values. If the variant is already known, e.g., due to an
earlier check, then the code can usually be refactored to encode the knowledge
in the type so that the second check (and corresponding error handling) can be
omitted.</p>
<p>A C++ program like the following requires more restructuring of the types to
achieve the same goal in Rust.</p>
<p>The corresponding Rust program requires defining separate types for each variant
of the <code>Shape</code> enum so that the fact that all of the value are of a given type
can be expressed in the type system by having an array of <code>Triangle</code> instead of
an array of <code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

// Uses the same Shape definition.
enum Tag { Rectangle, Triangle };

struct Shape {
  Tag tag;
  union {
    struct {
      double width;
      double height;
    } rectangle;
    struct {
      double base;
      double height;
    } triangle;
  };
};

std::vector&lt;Shape&gt; get_shapes() {
  return std::vector&lt;Shape&gt;{
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Triangle, {.triangle = {1.0, 1.0}}},
      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},
  };
}

std::vector&lt;Shape&gt; get_shapes();

int main() {
  std::vector&lt;Shape&gt; shapes = get_shapes();

  auto is_triangle = [](Shape shape) {
    return shape.tag == Triangle;
  };

  // Create an iterator that only sees the
  // triangles. (std::views::filter is from C++20,
  // but the same effect can be acheived with a
  // custom iterator.)
  auto triangles =
      shapes | std::views::filter(is_triangle);

  double total_base = 0.0;
  for (auto &amp;triangle : triangles) {
    // Skip checking the tag because we know we
    // have only triangles.
    total_base += triangle.triangle.base;
  }

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Define a separate struct for each variant.
struct Rectangle { width: f64, height: f64 }
struct  Triangle { base: f64, height: f64 }

enum Shape {
    Rectangle(Rectangle),
    Triangle(Triangle),
}

fn get_shapes() -&gt; Vec&lt;Shape&gt; {
    vec![
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Triangle(Triangle {
            base: 1.0,
            height: 1.0,
        }),
        Shape::Rectangle(Rectangle {
            width: 1.0,
            height: 1.0,
        }),
    ]
}

fn main() {
    let shapes = get_shapes();

    // This iterator only iterates over triangles
    // and demonstrates that by iterating over
    // the Triangle type instead of the Shape type.
    let triangles = shapes
        .iter()
        // Keep only the triangles
        .filter_map(|shape| match shape {
            Shape::Triangle(t) =&gt; Some(t),
            _ =&gt; None,
        });

    let mut total_base = 0.0;
    for triangle in triangles {
        // Because the iterator produces Triangles
        // instead of Shapes, base can be accessed
        // directly.
        total_base += triangle.base;
    }
}</code></pre></pre>
</div>
<p>This kind of use is common enough in Rust that the variants are often designed
to have their own types from the start.</p>
<p>This approach is also possible in C++. It is more commonly used along with
<code>std::variant</code> in C++17 or later.</p>
<h2 id="stdvariant-since-c17"><a class="header" href="#stdvariant-since-c17"><code>std::variant</code> (since C++17)</a></h2>
<p>When programming in C++ standards since C++17, <code>std::variant</code> can be used to
represent a tagged union in a way that has more in common with Rust enums.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        } else if constexpr (std::is_same_v&lt;T, Triangle&gt;) {
          return 0.5 * arg.base * arg.height;
        }
      },
      shape);
}
</code></pre>
<p>Because Rust doesn't depend on templates for this language feature, error
messages when a variant is missed or when a new variant is added are easier to
read, which removes one of the barriers to using tagged unions more frequently.
Compare the errors in C++ (using gcc) and Rust when the <code>Triangle</code> case is
omitted.</p>
<p>The following two programs have the same error: each fails to handle a case of
<code>Shape</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;variant&gt;

struct Rectangle {
  double width;
  double height;
};

struct Triangle {
  double base;
  double height;
};

using Shape = std::variant&lt;Rectangle, Triangle&gt;;

double area(const Shape &amp;shape) {
  return std::visit(
      [](auto &amp;&amp;arg) -&gt; double {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
          return arg.width * arg.height;
        }
      },
      shape);
}
</code></pre>
<pre><code class="language-rust ignore">enum Shape {
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle {
                width,
                height,
            } =&gt; width * height,
        }
    }
}</code></pre>
</div>
<p>However, the error messages differ significantly.</p>
<div class="comparison">
<pre><code class="language-text">example.cc: In instantiation of area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt; [with auto:27 = const Triangle&amp;]:
/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from constexpr _Res std::__invoke_impl(__invoke_other, _Fn&amp;&amp;, _Args&amp;&amp; ...) [with _Res = double; _Fn = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}]
   61 |     { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from constexpr typename std::__invoke_result&lt;_Functor, _ArgTypes&gt;::type std::__invoke(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Args = {const Triangle&amp;}; typename __invoke_result&lt;_Functor, _ArgTypes&gt;::type = double]
   96 |       return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   97 |                                         std::forward&lt;_Args&gt;(__args)...);
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1060:24:   required from static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl&lt;std::__detail::__variant::_Multi_array&lt;_Result_type (*)(_Visitor, _Variants ...)&gt;, std::integer_sequence&lt;long unsigned int, __indices ...&gt; &gt;::__visit_invoke(_Visitor&amp;&amp;, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;&amp;&amp;; _Variants = {const std::variant&lt;Rectangle, Triangle&gt;&amp;}; long unsigned int ...__indices = {1}]
 1060 |           return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),
      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1061 |               __element_by_index_or_cookie&lt;__indices&gt;(
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1062 |                 std::forward&lt;_Variants&gt;(__vars))...);
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1820:5:   required from constexpr decltype(auto) std::__do_visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Result_type = __detail::__variant::__deduce_visit_result&lt;double&gt;; _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}]
 1820 |                   _GLIBCXX_VISIT_CASE(1)
      |                   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/14.2.1/variant:1882:34:   required from constexpr std::__detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; std::visit(_Visitor&amp;&amp;, _Variants&amp;&amp; ...) [with _Visitor = area(const Shape&amp;)::&lt;lambda(auto:27&amp;&amp;)&gt;; _Variants = {const variant&lt;Rectangle, Triangle&gt;&amp;}; __detail::__variant::__visit_result_t&lt;_Visitor, _Variants ...&gt; = double]
 1882 |             return std::__do_visit&lt;_Tag&gt;(
      |                    ~~~~~~~~~~~~~~~~~~~~~^
 1883 |               std::forward&lt;_Visitor&gt;(__visitor),
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1884 |               static_cast&lt;_Vp&gt;(__variants)...);
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
example.cc:17:20:   required from here
   17 |   return std::visit(
      |          ~~~~~~~~~~^
   18 |       [](auto &amp;&amp;arg) -&gt; double {
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 |         using T = std::decay_t&lt;decltype(arg)&gt;;
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 |         if constexpr (std::is_same_v&lt;T, Rectangle&gt;) {
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 |           return arg.width * arg.height;
      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   22 |         }
      |         ~
   23 |       },
      |       ~~
   24 |       shape);
      |       ~~~~~~
example.cc:23:7: error: no return statement in constexpr function returning non-void
   23 |       },
      |       ^
example.cc: In lambda function:
example.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `&amp;Shape::Triangle { .. }` not covered
 --&gt; example.rs:8:15
  |
8 |         match self {
  |               ^^^^ pattern `&amp;Shape::Triangle { .. }` not covered
  |
note: `Shape` defined here
 --&gt; example.rs:1:6
  |
1 | enum Shape {
  |      ^^^^^
2 |     Rectangle { width: f64, height: f64 },
3 |     Triangle { base: f64, height: f64 },
  |     -------- not covered
  = note: the matched value is of type `&amp;Shape`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
12~             } =&gt; width * height,
13~             &amp;Shape::Triangle { .. } =&gt; todo!(),
  |
</code></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;tagged_unions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;8019115c-c84b-4b79-a18d-d2e83ff984da&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. }\n            | MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            MediaFile::Image { height, width, .. } =&gt; // fallthrough\n            MediaFile::Video { height, width, .. } =&gt; height * width,\n        }\n    }\n}\n```\n&quot;,&quot;```rust\nimpl MediaFile {\n    fn size(&amp;self) -&gt; usize {\n        match self {\n            MediaFile::Text { length, .. } =&gt; *length,\n            _ =&gt; self.height * self.width,\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs is the most idiomatic translation of the\ngiven C++ program?\n\n```c++\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n\nenum class MediaType { Text, Image, Video };\n\nclass MediaFile {\npublic:\n  MediaType type;\n  union {\n    struct {\n      std::string language;\n      size_t length;\n    } text;\n    struct {\n      size_t height;\n      size_t width;\n    } image;\n    struct {\n      size_t height;\n      size_t width;\n      std::chrono::nanoseconds duration;\n    } video;\n  };\n\n  // constructors omitted for brevity\n\n  size_t size() const {\n    switch (type) {\n    case MediaType::Text:\n      return text.length;\n    case MediaType::Image:\n      return image.height * image.width;\n    case MediaType::Video:\n      return video.height * video.width;\n    }\n    // Should not reach here\n    return 0;\n  }\n};\n```\n\nAll of the Rust programs use this definition of `MediaFile`.\n\n```rust\nenum MediaFile {\n    Text {\n        language: String,\n        length: usize,\n    },\n    Image {\n        height: usize,\n        width: usize,\n    },\n    Video {\n        height: usize,\n        width: usize,\n        duration: std::time::Duration,\n    },\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h1>
<p>In C++ the encapsulation boundary is the class. In Rust the encapsulation
boundary is the module, which may contain several types along with standalone
functions. In larger projects, the crate may also act as an encapsulation
boundary.</p>
<p>This difference means that in Rust one is more likely to have multiple, tightly
coupled types that work together which are defined in one module and
encapsulated as a whole.</p>
<p>This section provides ways to translate between C++ and Rust's notions of
encapsulation both mechanically and conceptually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-files"><a class="header" href="#header-files">Header files</a></h1>
<p>One use of header files in C++ is to expose declarations that are defined in one
translation units to other translation units without requiring the duplication
of the declarations in multiple files. By convention, declarations that are not
included in the header are considered to be private to the defining translation
unit (though, to enforce this convention other mechanisms, such as <a href="idioms/encapsulation//idioms/encapsulation/anonymous_namespaces.html">anonymous
namespaces</a>, are required).</p>
<p>In contrast, Rust uses neither textually-included header files nor forward
declarations. Instead, Rust modules control visibility and linkage
simultaneously and expose public definitions for use by other modules.</p>
<div class="comparison">
<pre><code class="language-cpp">// person.h
class Person {
  std::string name;

public:
  Person(std::string name) : name(name) {}
  const std::string &amp;getName();
};

// person.cc
#include &lt;string&gt;
#include "person.h"

const std::string &amp;Person::getName() {
  return this-&gt;name;
}

// client.cc
#include &lt;string&gt;
#include "person.h"

int main() {
  Person p("Alice");
  const std::string &amp;name = p.getName();

  // ...
}
</code></pre>
<pre><code class="language-rust ignore">// person.rs
pub struct Person {
    name: String,
}

impl Person {
    pub fn new(name: String) -&gt; Person {
        Person { name }
    }

    pub fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

// client.rs
mod person;

use person::*;

fn main() {
    let p = Person::new("Alice".to_string());
    // doesn't compile, private field
    // let name = p.name;
    let name = p.name();

    //...
}</code></pre>
</div>
<p>In <code>person.rs</code>, the <code>Person</code> type is public but the <code>name</code> field is not. This
prevents both direct construction of values of the type (similar to private
members preventing aggregate initialization in C++) and prevents field access.
The static method <code>Person::new(String)</code> and method <code>Person::name()</code> are exposed
to clients of the module by the <code>pub</code> visibility declarations.</p>
<p>In the <code>client</code> module, the <code>mod</code> declaration defines the content of <code>person.rs</code>
as a submodule named <code>person</code>. The <code>use</code> declaration brings the contents of the
<code>person</code> module into scope.</p>
<h2 id="the-essence-of-the-difference"><a class="header" href="#the-essence-of-the-difference">The essence of the difference</a></h2>
<p>A C++ program is a collection of translation units. Header files are required to
make providing forward declarations of definitions from other translation units
manageable.</p>
<p>A Rust program is a tree of modules. Definitions in one module may access items
from other modules based on visibility declarations given in the definitions of
the module themselves.</p>
<h2 id="submodules-and-additional-visibility-features"><a class="header" href="#submodules-and-additional-visibility-features">Submodules and additional visibility features</a></h2>
<p>Modules and visibility declarations are more powerful than shown in the above
example. More details on how to use modules, <code>pub</code>, and <code>use</code> to achieve
encapsulation goals are described in the chapter on <a href="idioms/encapsulation/./idioms/encapsulation/private_members.html">private members and
friends</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;headers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Even if in C++ you wouldn't use namespaces to structure the program, in Rust\nsplitting programs into separate files also means splitting them into separate\nmodules.\n&quot;,&quot;id&quot;:&quot;4665b8ad-511f-4e0b-9dff-bf53e2a8f931&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n// square.rs\npub struct Square {\n    width: f64,\n}\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// square.rsi\npub struct Square {\n    width: f64;\n}\n\nimpl Square {\n    fn area(&amp;self) -&gt; f64;\n}\n\n// square.rs\nmod square;\n\nimpl Square {\n    pub fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;,&quot;```rust\n// square.rs\nstruct Square {\n    width: f64,\n}\n\nimpl Square {\n    fn area(&amp;self) -&gt; f64 {\n        self.width * self.width\n    }\n}\n\n// main.rs\nmod square;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;,&quot;```rust\n// square.rs\nmod square {\n    struct Square {\n        width: f64,\n    }\n\n    impl Square {\n        fn area(&amp;self) -&gt; f64 {\n            self.width * self.width\n        }\n    }\n}\n\n// main.rs\nmod square;\n\nuse square::*;\n\nfn main() {\n    let square = Square { width: 3.0 };\n\n    println!(\&quot;{}\&quot;, square.area());\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the idiomatic equivalent to the following C++ program?\n\n```cpp\n// square.h\nstruct Square {\n  double width;\n\n  double area() const;\n};\n\n// square.cc\n#include \&quot;square.h\&quot;\n\ndouble Square::area() const {\n  return this-&gt;width * this.width;\n}\n\n// main.cc\n#include \&quot;square.h\&quot;\n#include &lt;iostream&gt;\n\nint main() {\n  Square square(3.0);\n\n  std::cout &lt;&lt; square.area() &lt;&lt; std::endl;\n}\n```\n&quot;}},{&quot;id&quot;:&quot;e3948224-44d7-47d1-bf37-d5667fd8c9bb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `mod` defines a module and `greeting.rs` is not a\nvalid module body.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile and prints `Hello!` to standard out.\n&quot;,&quot;It does not compile because the `main.rs` file must include an explicit `use\ngreetings;` statement.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n// greetings.rs\nprintln!(\&quot;Hello!\&quot;);\n```\n\n```rust\n// main.rs\nfn main() {\n    #[path = \&quot;greetings.rs\&quot;]\n    mod greetings;\n}\n```\n&quot;}},{&quot;context&quot;:&quot;In Rust, `mod` defines a module whose body happens to be given in another file.\nThe whole program is compiled from the root file (in this case `main.rs`) as a\ntree of modules.\n&quot;,&quot;id&quot;:&quot;68d431c0-8d39-4f4f-804c-bb6e7baa8d2b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nmod greetings {\n    pub fn print_greeting() {\n        print_hello();\n        print_goodbye();\n    }\n\n    fn print_hello() {\n        println!(\&quot;Hello!\&quot;);\n    }\n\n    fn print_goodbye() {\n        println!(\&quot;Goodbye!\&quot;);\n    }\n}\n\nuse greetings::*;\n\nfn main() {\n    print_greeting();\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn print_greeting() {\n   print_hello();\n   print_goodbye();\n}\n\nfn print_hello() {\n    println!(\&quot;Hello!\&quot;);\n}\n\nfn print_goodbye() {\n    println!(\&quot;Goodbye!\&quot;);\n}\n\nfn main() {\n    print_hello();\n}\n```\n&quot;,&quot;```rust\nmod greetings {\n    pub fn print_greeting() {\n        print_hello();\n        print_goodbye();\n    }\n\n    fn print_hello() {\n        println!(\&quot;Hello!\&quot;);\n    }\n\n    fn print_goodbye() {\n        println!(\&quot;Goodbye!\&quot;);\n    }\n}\n\nmod main {\n    use greetings::*;\n\n    fn main() {\n        print_greeting();\n    }\n}\n```\n&quot;,&quot;```rust\nmod main {\n    mod greetings {\n        pub fn print_greeting() {\n            print_hello();\n            print_goodbye();\n        }\n\n        fn print_hello() {\n            println!(\&quot;Hello!\&quot;);\n        }\n\n        fn print_goodbye() {\n            println!(\&quot;Goodbye!\&quot;);\n        }\n    }\n\n    use greetings::*;\n\n    fn main() {\n        print_greeting();\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which single-file Rust program is equivalent to this program which is split\nacross multiple files?\n\n```rust\n// greetings.rs\npub fn print_greeting() {\n   print_hello();\n   print_goodbye();\n}\n\nfn print_hello() {\n    println!(\&quot;Hello!\&quot;);\n}\n\nfn print_goodbye() {\n    println!(\&quot;Goodbye!\&quot;);\n}\n\n// main.rs\nmod greetings;\n\nuse greetings::*;\n\nfn main() {\n    print_greeting();\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Since neither `mod` nor `use` performs textual inclusion, it is possible to have\nrecurisve modules within a single crate.\n&quot;,&quot;id&quot;:&quot;b2d00b6a-8efa-40e5-98c7-f9c54f48d09a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program does compile and prints `true`.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because the files have a cyclical dependency.\n&quot;,&quot;It does not compile because `even.rs` and `odd.rs` don't have `mod`\ndeclarations for each other.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n// even.rs\nuse crate::odd::*;\n\npub fn is_even(n: u64) -&gt; bool {\n    if n == 0 {\n        true\n    } else {\n        is_odd(n - 1)\n    }\n}\n\n// odd.rs\nuse crate::even::*;\n\npub fn is_odd(n: u64) -&gt; bool {\n    if n == 1 {\n        true\n    } else {\n        is_even(n - 1)\n    }\n}\n\n// main.rs\nmod even;\nmod odd;\n\nuse even::*;\n\nfn main() {\n    println!(\&quot;{}\&quot;, is_even(4));\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-namespaces-and-static"><a class="header" href="#anonymous-namespaces-and-static">Anonymous namespaces and <code>static</code></a></h1>
<p>Anonymous namespaces in C++ are used to avoid symbol collisions between
different translation units. Such collisions violate <a href="https://timsong-cpp.github.io/cppwp/n4950/basic.def.odr#14">the one definition
rule</a> and result in
undefined behavior (which at best manifests as linking errors).</p>
<p>For example, without the use of anonymous namespaces, the following would result
in undefined behavior (and no linking error, due to the use of <code>inline</code> producing
weak symbols in the object files).</p>
<pre><code class="language-cpp">/// a.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}

/// b.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}
</code></pre>
<p>C++ static declarations are also used to achieve the same goal by making it so that
a declaration has internal linkage (and so is not visible outside of the
translation unit).</p>
<p>Rust avoids the linkage problem by controlling linkage and visibility
simultaneously, with declarations always also being definitions. Instead of
translation units, programs are structured in terms of
<a href="idioms/encapsulation//idioms/encapsulation/headers.html">modules</a>, which provide both namespaces and
visibility controls over definitions, enabling the Rust compiler to guarantee
that symbol collision issues cannot happen.</p>
<p>The following Rust program achieves the same goal as the C++ program above, in
terms of avoiding the collision of the two functions while making them available
for use within the defining files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.rs
<span class="boring">mod a {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span>
// b.rs
<span class="boring">mod b {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Additionally,</p>
<ol>
<li>Unlike C++ namespaces, Rust modules (which provide namespacing as well as
visibility controls) can only be defined once, and this is checked by the
compiler.</li>
<li>Each file <a href="https://doc.rust-lang.org/stable/book/ch07-05-separating-modules-into-different-files.html">defines a module which has to be explicitly included in the module
hierarchy</a>.</li>
<li>Modules from Rust crates (libraries) are always qualified with some root
module name, so they cannot conflict. If they would conflict, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">the root
module name must be replaced with some user-chosen
name</a>.</li>
</ol>
<h2 id="caveats-about-c-interoperability"><a class="header" href="#caveats-about-c-interoperability">Caveats about C interoperability</a></h2>
<p>When using libraries not managed by Rust, the usual problems can occur if there are symbol collisions in the
object files. This can arise when using C or C++ static or dynamic libraries.
It can also arise when using Rust static or dynamic libraries built for use in C or
C++ programs.</p>
<p>Rust provides <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a> to bypass name mangling
in order to produce functions that can be easily
referred to from C or C++. This can also cause undefined behavior due to name collision.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;anonymous_namespaces&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4ed5c1ed-81e3-448d-b20a-8f0eac301489&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n// colors.rs\npub fn red() {}\nfn blue() {}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// colors.rs\nmod colors {\n    pub fn red() {}\n    fn blue() {}\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;,&quot;```rust\n// colors.rs\nmod colors {\n    fn red() {}\n\n    mod {\n        fn blue() {}\n    }\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is an idiomatic translation of the following C++ program?\n\n```cpp\n// colors.h\nnamespace colors {\n  void red();\n}\n\n// colors.cc\n#include \&quot;colors.h\&quot;\n\nnamespace colors {\n  void red() {}\n\n  namespace {\n    void blue() {}\n  }\n}\n\n// main.cc\n#include \&quot;colors.h\&quot;\n\nusing namespace colors;\n\nint main() {}\n```\n&quot;}},{&quot;context&quot;:&quot;Even if in C++ you wouldn't use namespaces to structure the program, in Rust\nsplitting programs into separate files also means splitting them into separate\nmodules.\n&quot;,&quot;id&quot;:&quot;eb1bde49-9ca5-4e8d-b6f3-d49c95393dfb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;red&quot;,&quot;a::red&quot;,&quot;violet&quot;,&quot;b::violet&quot;,&quot;other_colors::green&quot;,&quot;a::other_colors::green&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;orange&quot;,&quot;green&quot;,&quot;indigo&quot;,&quot;a::green&quot;],&quot;prompt&quot;:&quot;In the following Rust program, which items would be visible within the `main`\nfunction?\n\n```rust\n// a.rs\npub fn red() {}\nfn orange() {}\n\nmod other_colors {\n    pub fn green() {}\n    fn blue() {}\n}\n\n// b.rs\npub fn indigo() {};\npub fn violet() {};\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::violet;\n\nfn main() {\n   // What is visible here?\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Lack of `pub` is like putting it in an anonymous namespace in terms of\nvisibility outside of the defining module.\n\n`mod` is not `#include`. `mod` defines a module, and using items from the module\nrequires either importing or qualification.\n\nResolving ambiguous items works the same as it does with C++ namespaces.\nAmbiguous use is the error, not having conflicting names in scope.\n&quot;,&quot;id&quot;:&quot;b3c2c70b-26b7-4396-8f8a-0e21541896cf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\nfn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs compile?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="type-equivalents"><a class="header" href="#type-equivalents">Type equivalents</a></h1>
<p>The type equivalents listed in this document are equivalent for the purposes of
programming in Rust as one would program in C++. They are not necessarily
equivalent in terms of being useful for interacting with C or C++ programs via
an FFI. For types that are useful for interoperability with C or C++, see the
<a href="https://doc.rust-lang.org/std/ffi/index.html">Rust <code>std::ffi</code> module
documentation</a> and the <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI
documentation in the Rustonomicon</a>.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer types</a></h3>
<p>In C++, many of the integer types (like <code>int</code> and <code>long</code>) have implementation
defined widths. In Rust, integer types are always specified with their widths,
much like the types in <code>&lt;cstdint&gt;</code> in C++. When it isn't clear what integer type
to use, <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">it is common to default to <code>i32</code>, which is the type that Rust defaults
to for integer
literals</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>uint8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>uint16_t</code></td><td><code>u16</code></td></tr>
<tr><td><code>uint32_t</code></td><td><code>u32</code></td></tr>
<tr><td><code>uint64_t</code></td><td><code>u64</code></td></tr>
<tr><td><code>int8_t</code></td><td><code>i8</code></td></tr>
<tr><td><code>int16_t</code></td><td><code>i16</code></td></tr>
<tr><td><code>int32_t</code></td><td><code>i32</code></td></tr>
<tr><td><code>int64_t</code></td><td><code>i64</code></td></tr>
<tr><td><code>size_t</code></td><td><code>usize</code></td></tr>
<tr><td></td><td><code>isize</code></td></tr>
</tbody></table>
</div>
<p>In C++ <code>size_t</code> is conventionally used only for sizes and offsets. The same is
true in Rust for <code>usize</code>, which is the pointer-sized integer type. The <code>isize</code>
type is the signed equivalent of <code>usize</code> and has no direct equivalent in C++.
The <code>isize</code> type is typically only used to represent pointer offsets.</p>
<h3 id="floating-point-types"><a class="header" href="#floating-point-types">Floating point types</a></h3>
<p>As with integer types in C++, the floating point types <code>float</code>, <code>double</code>, and
<code>long double</code> have implementation defined widths. C++23 introduced types
guaranteed to be IEEE 754 floats of specific widths. Of those, <code>float32_t</code> and
<code>float64_t</code> correspond to what is usually expected from <code>float</code> and <code>double</code>.
Rust's floating point types are analogous to these.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>float16_t</code></td><td></td></tr>
<tr><td><code>float32_t</code></td><td><code>f32</code></td></tr>
<tr><td><code>float64_t</code></td><td><code>f64</code></td></tr>
<tr><td><code>float128_t</code></td><td></td></tr>
</tbody></table>
</div>
<p>The Rust types analogous to <code>float16_t</code> and <code>float128_t</code> (<code>f16</code> and <code>f128</code>) are
<a href="https://github.com/rust-lang/rust/issues/116909">not yet available in stable
Rust</a>.</p>
<h3 id="raw-memory-types"><a class="header" href="#raw-memory-types">Raw memory types</a></h3>
<p>In C++ pointers to or arrays of <code>char</code>, <code>unsigned char</code>, or <code>byte</code> are used to
represent raw memory. In Rust, arrays (<code>[u8; N]</code>), vectors (<code>Vec&lt;u8&gt;</code>), or
slices (<code>&amp;[u8]</code>) of <code>u8</code> are used to accomplish the same goal. However,
accessing the underlying memory of another Rust value in that way requires
unsafe Rust. There are <a href="idioms/TODO">libraries</a> for creating safe wrappers around that
kind of access for purposes such as serialization or interacting with hardware.</p>
<h3 id="character-and-string-types"><a class="header" href="#character-and-string-types">Character and string types</a></h3>
<p>The C++ <code>char</code> or <code>wchar_t</code> types have implementation defined widths. Rust does
not have an equivalent to these types. When working with string encodings in
Rust one would use unsigned integer types where one would use the fixed width
character types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>char8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u16</code></td></tr>
</tbody></table>
</div>
<p>The Rust <code>char</code> type represents a Unicode scalar value. Thus, a Rust <code>char</code> is
the same size as a <code>u32</code>. For working with characters in Rust strings (which are
guaranteed to be valid UTF-8), the <code>char</code> type is appropriate. For representing
a byte, one should instead use <code>u8</code>.</p>
<p>The Rust standard library includes a type for UTF-8 strings and string slices:
<code>String</code> and <code>&amp;str</code>, respectively. Both types guarantee that represented strings
are valid UTF-8. The Rust <code>char</code> type is appropriate for representing elements
of a <code>String</code>.</p>
<p>Because <code>str</code> (without the reference) is a slice, it is unsized and therefore
must be used behind a pointer-like construct, such as a reference or box. For
this reason, string slices are often described as <code>&amp;str</code> instead of <code>str</code> in
documentation, even though they can also be used as <code>Box&lt;str&gt;</code>, <code>Rc&lt;str&gt;</code>, etc.</p>
<p>Rust also includes types for platform-specific string representations and slices
of those strings:
<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a>
and <code>&amp;std::ffi::OsStr</code>. While these strings use the OS-specific representation,
to use one with the Rust FFI, it must still be converted to a
<a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a>.</p>
<p>Unlike C++ which has <code>std::u16string</code>, Rust has no specific representation for
UTF-16 strings. Something like <code>Vec&lt;u16&gt;</code> can be used, but the type will not
guarantee that its contents are a valid UTF-16 string. Rust does provide a
mechanisms for converting <code>String</code> to and from a UTF-16 encoding
(<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.encode_utf16"><code>String::encode_utf16</code></a>
and
<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a>,
among others) as well as similar mechanisms for accessing the underlying UTF-8
encoding
(https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8).</p>
<div class="table-wrapper"><table><thead><tr><th>Purpose</th><th>Rust type</th></tr></thead><tbody>
<tr><td>representing text</td><td><code>String</code> and <code>&amp;str</code></td></tr>
<tr><td>representing bytes</td><td>vectors, arrays, or slices of <code>u8</code></td></tr>
<tr><td>interacting with OS</td><td><code>OsString</code> and <code>&amp;OsStr</code></td></tr>
<tr><td>representing UTF-8</td><td><code>String</code></td></tr>
<tr><td>representing UTF-16</td><td>use <a href="idioms/TODO">a library</a></td></tr>
</tbody></table>
</div>
<h3 id="boolean-types"><a class="header" href="#boolean-types">Boolean types</a></h3>
<p>The <code>bool</code> type in Rust is analogous to the <code>bool</code> type in C++. Unlike C++, Rust
makes <a href="https://doc.rust-lang.org/reference/types/boolean.html">guarantees about the size, alignment, and bit pattern used to represent
values of the <code>bool</code>
type</a>.</p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<p>The following table maps the ownership-managing classes from C++ to equivalents
types in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Use</th><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>Owned</td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td>Single owner, dynamic storage</td><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>Box&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::rc::Rc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, immutable, thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>std::sync::Arc&lt;T&gt;</code></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, not thread-safe</td><td><code>std::shared_ptr&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><code>std::rc::Rc&lt;std::cell::RefCell&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Shared owner, dynamic storage, mutable, thread-safe</td><td><code>std::shared_ptr&lt;std::mutex&lt;T&gt;&gt;</code></td><td><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html"><code>std::sync::Arc&lt;std::mutex::Mutex&lt;T&gt;&gt;</code></a></td></tr>
<tr><td>Const reference</td><td><code>const &amp;T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable reference</td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr>
<tr><td>Const observer pointer</td><td><code>const *T</code></td><td><code>&amp;T</code></td></tr>
<tr><td>Mutable observer pointer</td><td><code>*T</code></td><td><code>&amp;mut T</code></td></tr>
</tbody></table>
</div>
<p>In C++, the thread safety of <code>std::shared_ptr</code> is more nuanced than it appears
in this table (e.g., some uses may require <code>std::atomic</code>). However, in safe Rust
the compiler will prevent the incorrect use of the shared owner types.</p>
<p>Unlike with C++ references, Rust can have references-to-references. Rust
references are more like observer pointers than they are like C++ references.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>Both C++ and Rust containers own their elements. However, in both the element
type may be a non-owning type, such as a pointer in C++ or a reference in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>C++ type</th><th>Rust type</th></tr></thead><tbody>
<tr><td><code>std::vector&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::array&lt;T, N&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.array.html"><code>[T; N]</code></a></td></tr>
<tr><td><code>std::list&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>std::collections::LinkedList&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::deque&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::stack&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>std::collections::BTreeMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::unordered_map&lt;K,V&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>std::collections::HashMap&lt;K,V&gt;</code></a></td></tr>
<tr><td><code>std::set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>std::collections::BTreeSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::unordered_set&lt;K&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>std::collections::HashSet&lt;K&gt;</code></a></td></tr>
<tr><td><code>std::priority_queue&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html"><code>std::collections::BinaryHeap&lt;T&gt;</code></a></td></tr>
<tr><td><code>std::span&lt;T&gt;</code></td><td><a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>&amp;[T]</code></a></td></tr>
</tbody></table>
</div>
<p>For maps and sets instead of the container being parameterized over the hash or
comparison function used, the types require that the key types implement the
<code>std::hash::Hash</code> (unordered) or <code>std::cmp::Ord</code> (ordered) traits. To use the containers
with different hash or comparison functions, one must use a wrapper type with a
different implementation of the required trait.</p>
<p>Some C++ container types provided by the STL have no equivalent in Rust. Many of
those have equivalents available in third-party <a href="idioms/TODO">libraries</a>.</p>
<p>One significant different in the use of these types between C++ in Rust is with
the <code>Vec&lt;T&gt;</code> and array <code>[T; N]</code> types, from which slice references <code>&amp;[T]</code> or
<code>&amp;mut [T]</code> to part or all of the data can be cheaply created. For this reason,
when defining a function that does not modify the length of a vector and does
not need to statically know the number of elements in an array, it is more
idiomatic to take a parameter as <code>&amp;[T]</code> or <code>&amp;mut [T]</code> than as a reference to the
owned type.</p>
<p>In C++ it is better to take begin and end iterators than a <code>span</code> when possible,
since iterators are more general. The same is true with Rust and taking a
generic type that implements <code>IntoIter&lt;&amp;T&gt;</code> or <code>IntoIter&lt;&amp;mut T&gt;</code> instead of
<code>&amp;[T]</code>.</p>
<div class="comparison">
<pre><code class="language-c++">#include &lt;iterator&gt;
#include &lt;vector&gt;

template &lt;typename InputIter&gt;
void go(InputIter first, InputIter last) {
  for (auto it = first; it != last; ++it) {
    // ...
  }
}

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3};
  go(v.begin(), v.end());
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::iter::IntoIterator;

fn go&lt;'a&gt;(iter: impl IntoIterator&lt;Item = &amp;'a mut i32&gt;) {
    for x in iter {
        // ...
    }
}

fn main() {
    let mut v = vec![1, 2, 3];
    go(&amp;mut v);
}</code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;type_equivalents&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4fb18334-8405-438d-8d3e-859a8823bccf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It is guaranteed in safe Rust to represent a valid Unicode scalar value.\n&quot;,&quot;It is 32 bits wide.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It is equivalent to the C++ `wchar` type.\n&quot;,&quot;It is equivalent to the C++ `char` type.\n&quot;,&quot;It is equivalent to the C++ `char8_t` type.\n&quot;,&quot;It is equivalent to the C++ `int32_t` type.\n&quot;,&quot;It is 8 bits wide.\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about the Rust `char` type.\n&quot;}},{&quot;id&quot;:&quot;5586766c-b5ce-4bea-b995-da0b3c548b0d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It provides thread-safe read access to a value of type `T`.\n&quot;,&quot;It represents shared ownership of a value of type `T`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It provides thread-safe write access to a value of type `T`.\n&quot;,&quot;It can be empty (i.e., not own some value of type `T`).\n&quot;],&quot;prompt&quot;:&quot;Which of the following are true about `std::sync::Arc&lt;T&gt;`.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>In C++, constructors initialize objects.</p>
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person(int a) : age(a) {}
};

int main() {
  Person person(42);
  // ...
}
</code></pre>
<p>At the point when a constructor is executed, storage for the object has been
allocated and the constructor is only performing initialization.</p>
<pre><code class="language-cpp">class Person {
  int age;
  // non-owning pointer
  Person *best_friend;

public:
  Person(int a) : age(a), best_friend(this) {}
};

int main() {
  Person person(42);
  // ...
}
</code></pre>
<p>Rust does not have constructors in the same way as C++. In Rust, there is a
single fundamental way to create an object, which is to initialize all of its
members at once. The term "constructor" or "constructor method" in Rust refers
to something more like a factory: a static method associated with a type (i.e.,
a method that does not have a <code>self</code> parameter), which returns a value of the
type.</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
    age: i32
}

impl Person {
    const fn with_age(a: i32) -&gt; Self {
        Self { age: a }
    }
}

fn main() {
    let person = Person::with_age(42);
    // ...
}</code></pre></pre>
<p>Typically the primary constructor for a type is named <code>new</code>, especially if it
takes no arguments. See the chapter on <a href="idioms/constructors/default_constructors.html">default
constructors</a>. Constructors based on
some specific property of the value are usually named <code>with_details</code> (e.g.,
<code>Person::with_name</code>). See the <a href="https://rust-lang.github.io/api-guidelines/naming.html">naming
guidelines</a> for the
conventions on how to name constructor methods in Rust.</p>
<p>If the fields to be initialized are visible, there is a reasonable default
value, and the value does not manage a resource, then it is also common to use
record update syntax to initialize a value based on some default value.</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

impl Point {
    const fn zero() -&gt; Self {
        Self { x: 0, y: 0, z: 0 }
    }
}

fn main() {
    let x_unit = Point {
        x: 1,
        ..Point::zero()
    };
    // ...
}</code></pre></pre>
<p>Despite the name, "record update syntax" does not modify a record but instead
creates a new value based on another one, taking ownership of it in order to do
so.</p>
<h2 id="storage-allocation-vs-initialization"><a class="header" href="#storage-allocation-vs-initialization">Storage allocation vs initialization</a></h2>
<p>The actual construction of a structure or enum value in Rust occurs where the
structure construction syntax <code>A { ... }</code> is, after the evaluation of the
expressions for the fields.</p>
<p>A significant implication of this difference is that storage is not allocated
for a struct in Rust at the point where the constructor method (such as
<code>Person::with_age</code>) is called, and in fact is not allocated until after the
values of the fields of a struct have been computed (in terms of the semantics
of the language  the optimizer may still avoid the copy). Therefore there is no
easy way in Rust to write the C++ example above where the class stores a pointer to
itself upon construction (this requires tools like <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> and <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>).</p>
<h2 id="fallible-constructors"><a class="header" href="#fallible-constructors">Fallible constructors</a></h2>
<p>In C++ the only way constructors can indicate failure is by throwing exceptions. In Rust, because constructors are normal static methods, fallible constructors
can instead return <code>Result</code> (akin to <code>std::expected</code>) or <code>Option</code> (akin to
<code>std::optional</code>).</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

class Person {
  int age;

public:
  Person(int a) : age(a) {
    if (age &lt; 0) {
      throw std::domain_error("Bad argument");
    }
  }
};

int main() {
  try {
    Person person(-4);
  } catch (const std::domain_error &amp;e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Person {
    age: i32,
}

#[derive(Debug)]
struct NegativeAgeError(i32);

impl Person {
    fn with_age(a: i32) -&gt; Result&lt;Self, NegativeAgeError&gt; {
        if a &lt; 0 {
            Err(NegativeAgeError(a))
        } else {
            Ok(Self { age: a })
        }
    }
}

fn main() {
    match Person::with_age(-4) {
        Err(err) =&gt; {
            println!("{err:?}");
        }
        Ok(person) =&gt; {
            // ...
        }
    }
}</code></pre></pre>
</div>
<p>See <a href="idioms//exceptions.html">the chapter on exceptions</a> for more information on how C++
exceptions and exception handling translate to Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-constructors"><a class="header" href="#default-constructors">Default constructors</a></h1>
<p>C++ has a special concept of default constructors to support several scenarios
in which they are implicitly called.</p>
<pre><code class="language-cpp">class Person {
    int age;

public:
    // Default constructor
    Person() : age(0) {}
}
</code></pre>
<p>Rust does not have a notion of a default constructor in the same way as in C++.
Some of the uses cases are achieved via a different mechanism or with different
conventions, and others do not apply to Rust.</p>
<p>If a structure has a useful default value (such as would be constructed by a
default constructor in C++), then the type should provide
<a href="https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits">both</a>
a <code>new</code> method that takes no arguments and an implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code>
trait</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
   age: i32,
}

impl Person {
    pub const fn new() -&gt; Self {
        Self { age: 0 }
    }
}

impl Default for Person {
    fn default() -&gt; Self {
        Self::new()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implicit-initialization-of-class-members"><a class="header" href="#implicit-initialization-of-class-members">Implicit initialization of class members</a></h2>
<p>In C++ if a member is not explicitly initialized by a constructor, then it is
default-initialized. When the type of the member is a class, the
default-initialization invokes the default constructor.</p>
<p>In Rust, if all of the fields of a struct implement the <code>Default</code> trait, then an
implementation for the structure can be provided by the compiler.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
}

class Student {
  Person person;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The use of the derive macros in Rust is equivalent to writing the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    age: i32,
}

impl Default for Person {
    fn default() -&gt; Self {
        Self {
            age: Default::default()
        }
    }
}

struct Student {
    person: Person,
}

impl Default for Student {
    fn default() -&gt; Self {
        Self {
            person: Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike C++ where the default initialization value for integers is indeterminate,
in Rust the default value for the primitive integer and floating point types is
zero.</p>
<p>Deriving the <code>Default</code> trait has a similar effect on code concision as eliding
initialization in C++. In situations where all of the types implement the
<code>Default</code> trait, but only some of the fields should have their default values,
one can use <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update
syntax</a>
to define a constructor method without enumerating the values for all of the
fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    age: i32,
}

#[derive(Default)]
struct Student {
    person: Person,
    favorite_color: Option&lt;String&gt;,
}

impl Student {
    pub fn with_favorite_color(color: String) -&gt; Self {
        Student {
            favorite_color: Some(color),
            ..Default::default()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implicit-initialization-of-array-values"><a class="header" href="#implicit-initialization-of-array-values">Implicit initialization of array values</a></h2>
<p>In C++, arrays without explicit initialization are default-initialized using the
default constructors.</p>
<p>In Rust, the value with which to initialize the array must be provided.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
};

int main() {
  Person people[3];
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    // std::array::from_fn provides the index to the callback
    let people: [Person; 3] = 
        std::array::from_fn(|_| Default::default());
    // ...
}</code></pre></pre>
</div>
<p>If the type happens to be <a href="idioms/constructors//idioms/constructors/copy_and_move_constructors.html#trivially-copyable-types">trivially
copyable</a>,
then a shorthand can be used.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: [Person; 3] = [Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="container-element-initialization"><a class="header" href="#container-element-initialization">Container element initialization</a></h2>
<p>In C++, the default constructor could be used to implicitly define collection
types, such as <code>std::vector</code>. Before C++11 one value would be default
constructed, and the elements would be copy constructed from that initial
element. Since C++11, all elements are default constructed.</p>
<p>As with array initialization, the values must be explicitly specified in Rust.
The vector can be constructed from an array, enabling the same syntax as with
arrays.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;vector&gt;

class Person {
  int age;

public:
  Person() : age(0) {}
}

int main() {
  std::vector&lt;Person&gt; v(3);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
    age: i32,
}

fn main() {
    let people_arr: [Person; 3] = std::array::from_fn(|_| Default::default());
    let people: Vec&lt;Person&gt; = Vec::from(people_arr);
    // ...
}</code></pre></pre>
</div>
<p>If the type implements the <code>Clone</code> trait, then the array can be constructed
using the <code>vec!</code> macro. See the chapter on <a href="idioms/constructors//idioms/constructors/copy_and_move_constructors.html">copy
constructors</a> for more
details on <code>Clone</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let people: Vec&lt;Person&gt; = vec![Default::default(); 3];
    // ...
}</code></pre></pre>
<h2 id="implicit-initialization-of-local-variables"><a class="header" href="#implicit-initialization-of-local-variables">Implicit initialization of local variables</a></h2>
<p>In C++, the default constructor is used to perform default-initialization of
local variables that are not explicitly initialized.</p>
<p>In Rust, initialization of local variables is always explicit.</p>
<div class="comparison">
<pre><code class="language-cpp">class Person {
  int age;

public:
  Person() : age(0) {}
};

int main() {
  Person person;
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Default)]
struct Person {
    age: i32,
}

fn main() {
    let person = Person::default();
    // ...
}</code></pre></pre>
</div>
<h2 id="implicit-initialization-of-the-base-class-object"><a class="header" href="#implicit-initialization-of-the-base-class-object">Implicit initialization of the base class object</a></h2>
<p>In C++, the default constructor is used to initialize the base class object if
it no other constructor is specified.</p>
<pre><code class="language-cpp">class Base {
  int x;

public:
  Base() : x(0) {}
};

class Derived : Base {
public:
  // Calls the default constructor for Base
  Derived() {}
};
</code></pre>
<p>Since Rust does not have inheritance, there is no equivalent to this case.
See the chapter on <a href="idioms/constructors//idioms/data_modeling/inheritance_and_reuse.html">implementation
reuse</a> or the section on <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits
in the Rust book</a> for
alternatives.</p>
<h2 id="stdunique_ptr"><a class="header" href="#stdunique_ptr"><code>std::unique_ptr</code></a></h2>
<p>There are some additional cases where the <code>Default</code> trait is used in Rust, but
default constructors are not used for initialization in C++.</p>
<p>Rust's equivalent of smart pointers implement <code>Default</code> by delegating to the
<code>Default</code> implementation of the contained type.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Person {
  age: i32,
}

fn main() {
    let b: Box&lt;Person&gt; = Default::default();
    // ...
}</code></pre></pre>
<p>This differs from the treatment of <code>std::unique_ptr</code> C++ because unlike <code>Box</code>,
<code>std::unique_ptr</code> is nullable, and so the default constructor for
<code>std:unique_ptr</code> produces a pointer that owns nothing. The equivalent type in
Rust is <code>Option&lt;Box&lt;Person&gt;&gt;</code>, for which the <code>Default</code> implementation produces
<code>None</code>.</p>
<h2 id="other-uses-of-default"><a class="header" href="#other-uses-of-default">Other uses of <code>Default</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>
makes use of <code>Default</code>, which makes getting a default value when the <code>Option</code>
does not contain a value more convenient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: Option&lt;i32&gt;) {
    let a: i32 = x.unwrap_or_default();
    // if x was None, then a is 0

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>In C++, <code>std::optional</code> does not have an equivalent method.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;default_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust does not have implicit default initialization like C++ does. Variables must\nbe explicitly initialized before use, or the program will fail to compile.\n&quot;,&quot;id&quot;:&quot;5019323d-1534-4c70-a8e7-b015f87be228&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `w` is not explicitly initialized before it is used.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile because `Widget` does not implement the `Default` trait.\n&quot;,&quot;It does not compile because `Widget` does not implement a `new` method.\n&quot;,&quot;It does not compile because `Widget` does not implement both the `Default`\ntrait and a `new` method.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\nstruct Widget {\n    color: String,\n}\n\nfn main() {\n    let w: Widget;\n    println!(\&quot;{}\&quot;, w.color);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;When there is a reasonable default value, it is most idiomatic in Rust to\nprovide [both a `new` method and an implementation of the `Default`\ntrait.](https://rust-lang.github.io/api-guidelines/interoperability.html?highlight=default#types-eagerly-implement-common-traits-c-common-traits)\n&quot;,&quot;id&quot;:&quot;a436177e-821d-45d1-8e46-4fafc3d78cd3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Vec2 {\n     pub fn new() -&gt; Self {\n        Vec2 { x: 0.0, y: 0.0 }\n     }\n}\n\nimpl Default for Vec2 {\n     fn default() -&gt; Self {\n        Self::new()\n     }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Vec2 {\n     pub fn new() -&gt; Self {\n        Vec2 { x: 0.0, y: 0.0 }\n     }\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64;\n    pub y: f64;\n}\n\nimpl Default for Vec2 {\n     fn default() -&gt; Self {\n        Self::new()\n     }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n\n    Vec2() : x(0.0), y(0.0) {}\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-move-constructors"><a class="header" href="#copy-and-move-constructors">Copy and move constructors</a></h1>
<p>In both C++ and Rust, one rarely has to write copy or move constructors (or
their Rust equivalents) by hand. In C++ this is because the implicit definitions
are good enough for most purposes, especially when using smart pointers (i.e.,
following <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of
zero</a>). In Rust this
is because move semantics are the default, and the automatically derived
implementations of the <code>Clone</code> and <code>Copy</code> traits are good enough for most
purposes.</p>
<p>For the following C++ classes, the implicitly defined copy and move constructors
are sufficient. The equivalent in Rust uses a derive macro provided by the
standard library to implement the corresponding traits.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;memory&gt;
</span><span class="boring">#include &lt;string&gt;
</span><span class="boring">
</span>struct Age {
  unsigned int years;

  Age(unsigned int years) : years(years) {}

  // copy and move constructors and destructor
  // implicitly declared and defined
};

struct Person {
  Age age;
  std::string name;
  std::shared_ptr&lt;Person&gt; best_friend;

  Person(Age age,
         std::string name,
         std::shared_ptr&lt;Person&gt; best_friend)
      : age(age), name(name),
        best_friend(best_friend) {}

  // copy and move constructors and destructor
  // implicilty declared and defined
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Clone, Copy)]
struct Age {
    years: u32,
}

#[derive(Clone)]
struct Person {
    age: Age,
    name: String,
    best_friend: Rc&lt;Person&gt;,
}
<span class="boring">}</span></code></pre></pre>
</div>
<h2 id="user-defined-constructors"><a class="header" href="#user-defined-constructors">User-defined constructors</a></h2>
<p>On the other hand, the following example requires a user-defined copy and move
constructor because it manages a resource (a pointer acquired from a C library).
The equivalent in Rust requires a custom implementation of the <code>Clone</code> trait.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

// widget.h
struct widget_t;
widget_t *alloc_widget();
void free_widget(widget_t *);
void copy_widget(widget_t *dst, widget_t *src);

// widget.cc
class Widget {
  widget_t *widget;

public:
  Widget() : widget(alloc_widget()) {}

  Widget(const Widget &amp;other) : widget(alloc_widget()) {
    copy_widget(widget, other.widget);
  }

  Widget(Widget &amp;&amp;other) : widget(other.widget) {
    other.widget = nullptr;
  }

  ~Widget() {
    free_widget(widget);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod example {
</span>mod widget_ffi {
    // Models an opaque type.
    // See https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs
    #[repr(C)]
    pub struct CWidget {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(
            *mut u8,
            core::marker::PhantomPinned,
        )&gt;,
    }

    extern "C" {
        pub fn make_widget() -&gt; *mut CWidget;
        pub fn copy_widget(
            dst: *mut CWidget,
            src: *mut CWidget,
        );
        pub fn free_widget(ptr: *mut CWidget);
    }
}

use self::widget_ffi::*;

struct Widget {
    widget: *mut CWidget,
}

impl Widget {
    fn new() -&gt; Self {
        Widget {
            widget: unsafe { make_widget() },
        }
    }
}

impl Clone for Widget {
    fn clone(&amp;self) -&gt; Self {
        let widget = unsafe { make_widget() };
        unsafe {
            copy_widget(widget, self.widget);
        }
        Widget { widget }
    }
}

impl Drop for Widget {
    fn drop(&amp;mut self) {
        unsafe { free_widget(self.widget) };
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</div>
<p>Just as with how in C++ it is uncommon to need user-defined implementations for
copy and move constructors or user-defined implementations for destructors, in
Rust it is rare to need to implement the <code>Clone</code> and <code>Drop</code> traits by hand for
types that do not represent resources.</p>
<p>There is one exception to this. If the type has type parameters, it might be
desirable to implement <code>Clone</code> (and <code>Copy</code>) manually even if the clone should be
done field-by-field. See the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#how-can-i-implement-clone">standard library documentation of
<code>Clone</code></a>
and <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#how-can-i-implement-copy">of
<code>Copy</code></a>
for details.</p>
<h2 id="trivially-copyable-types"><a class="header" href="#trivially-copyable-types">Trivially copyable types</a></h2>
<p>In C++, a class type is trivially copyable when it has no non-trivial copy
constructors, move constructors, copy assignment operators, move assignment
operators and it has a trivial destructor. Values of a trivially copyable type
are able to be copied by copying their bytes.</p>
<p>In the first C++ example above, <code>Age</code> is trivially copyable, but <code>Person</code> is
not. This is because despite using a default copy constructor, the constructor
is not trivial because <code>std::string</code> and <code>std::shared_ptr</code> are not trivially
copyable.</p>
<p>Rust indicates whether types are trivially copyable with the <code>Copy</code> trait. Just
as with trivially copyable types in C++, values of types that implement <code>Copy</code>
in Rust can be copied by copying their bytes. Rust requires explicit calls to
the <code>clone</code> method to make copies of values of types that do not implement
<code>Copy</code>.</p>
<p>In the first Rust example above, <code>Age</code> implements the <code>Copy</code> trait but <code>Person</code>
does not. This is because neither <code>std::String</code> nor <code>Rc&lt;Person&gt;</code> implement
<code>Copy</code>. They do not implement <code>Copy</code> because they own data that lives on the
heap, and so are not trivially copyable.</p>
<p>Rust prevents implementing <code>Copy</code> for a type if any of its fields are not
<code>Copy</code>, but does not prevent implementing <code>Copy</code> for types that should not be
copied bit-for-bit due to their intended meaning, which is usually indicated by
a user-defined <code>Clone</code> implementation.</p>
<p>Rust does not permit the implementation of both <code>Copy</code> and <code>Drop</code> for the same
type. This aligns with the C++ standard's requirement that trivially copyable
types not implement a user-defined destructor.</p>
<h2 id="move-constructors"><a class="header" href="#move-constructors">Move constructors</a></h2>
<p>In Rust, all types support move semantics by default, and custom move semantics
cannot be (and do not need to be) defined. This is because what "move" means in
Rust is not the same as it is in C++. In Rust, moving a value means changing
what owns the value. In particular, there is no "old" object to be destructed
after a move, because the compiler will prevent the use of a variable whose
value has been moved.</p>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment operators</a></h2>
<p>Rust does not have a copy or move assignment operator. Instead, assignment
either moves (by transferring ownership), explicitly clones and then moves, or
implicitly copies and then moves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Box::&lt;u32&gt;::new(5);
    let y = x; // moves
    let z = y.clone(); // explicitly clones and then moves the clone
    let w = *y; // implicitly copies the content of the Box and then moves the copy
}</code></pre></pre>
<p>For situations where something like a user-defined copy assignment could avoid
allocations, the <code>Clone</code> trait has an additional method called <code>clone_from</code>. The
method is automatically defined, but can be overridden when implementing the
<code>Clone</code> trait to provide an efficient implementation.</p>
<p>The method is not used for normal assignments, but can be explicitly used in
situations where the performance of the assignment is significant and would be
improved by using the more efficient implementation, if one is defined. The
implementation can be made more efficient because <code>clone_from</code> takes ownership
of the object to which the values are being assigned, and so can do things like
reuse memory to avoid allocations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn go(x: &amp;Vec&lt;u32&gt;) {
    let mut y = vec![0; x.len()];
    // ...
    y.clone_from(&amp;x);
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-concerns-and-copy"><a class="header" href="#performance-concerns-and-copy">Performance concerns and <code>Copy</code></a></h2>
<p>The decision to implement <code>Copy</code> should be based on the semantics of the type,
not on performance. If the size of objects being copied is a concern, then one
should instead use a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) or put the value on the heap
(<a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> or
<a href="https://doc.rust-lang.org/std/rc/index.html"><code>Rc&lt;T&gt;</code></a>). These approaches
correspond to passing by reference, or using a <code>std::unique_ptr</code> or
<code>std::shared_ptr</code> in C++.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;copy_and_move_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;A type can only implement `Copy` if all of its fields implement `Copy`, just how\nin C++ a type is only trivially copyable if all of its members are. `Box` does\nnot implement `Copy`.\n&quot;,&quot;id&quot;:&quot;ec3c58d9-cb13-4f88-ac67-7c1d5baf46e2&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because `Box` doesn't implement `Copy`, so `Copy` can't be\nimplemented for `BinaryTreeNode`.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile because `Box` doesn't implement `Clone`, so `Clone` can't be\nderived for `BinaryTreeNode`.\n&quot;,&quot;It does not compile because only one of `Clone` or `Copy` can be implemented for\na type.\n&quot;,&quot;It does not compile because `Drop` is not implemented for `BinaryTreeNode`\neven though `Clone` is.\n&quot;],&quot;prompt&quot;:&quot;Does the following program compile?\n\n```rust\n#[derive(Clone, Copy)]\nstruct BinaryTreeNode {\n    value: i32,\n    left_child: Option&lt;Box&lt;BinaryTreeNode&gt;&gt;,\n    right_child: Option&lt;Box&lt;BinaryTreeNode&gt;&gt;,\n}\n```\n&quot;}},{&quot;context&quot;:&quot;While `Copy` requires `Clone`, it does not pose any constraints on the\nimplementation of clone. Even though the given implementation of `Clone` is most\ncertainly wrong, the program will still compile.\n&quot;,&quot;id&quot;:&quot;0a4bc647-44c9-4244-9dfc-3002d6abc069&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does compile, but implementing `Clone` in a way that doesn't match `Copy` is\na bad idea.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because only one of `Clone` or `Copy` can be implemented\nfor a type.\n&quot;,&quot;It does not compile because `Clone` must be derived in order to derive `Copy`.\n&quot;,&quot;It does not compile because `Drop` is not implemented for `Age` even though\n`Clone` is.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\n#[derive(Copy)]\nstruct Age {\n    value: u32,\n}\n\nimpl Clone for Age {\n    fn clone(&amp;self) -&gt; Self {\n       Age {\n           value: 1 + self.value,\n       }\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The C++ `Vec2` implements a copy constructor which corresponds to the `Clone`\ntrait in Rust. It is also trivially copyable, which corresponds to implementing\nthe `Copy` trait in Rust.\n&quot;,&quot;id&quot;:&quot;4636f71a-599b-46d3-a6e6-e0c35b344140&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n#[derive(Clone, Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n#[derive(Clone)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\n#[derive(Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n};\n```\n&quot;}},{&quot;context&quot;:&quot;The C++ `Vec2` has a user-defined copy constructor which corresponds to the\n`Clone` trait in Rust. Despite being user-defined, it does exactly what the\ndefault trait would do. Because the implementation is user-defined, it prevents\nthe type from being trivially copyable, which corresponds to not implementing\nthe `Copy` trait in Rust.\n&quot;,&quot;id&quot;:&quot;c8e3b4da-19a1-42e9-97d4-bbb61dcd5652&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n#[derive(Clone)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n#[derive(Clone, Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\n#[derive(Copy)]\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;,&quot;```rust\npub struct Vec2 {\n    pub x: f64,\n    pub y: f64,\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nstruct Vec2 {\n    double x;\n    double y;\n\n    Vec2(Vec2&amp; other) : x(other.x), y(other.y) {};\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="out-parameters"><a class="header" href="#out-parameters">Out parameters</a></h1>
<p>There are several idioms in C++ that involve the use of out parameters: passing
pointers or references to functions for the function to mutate to provide its
results.</p>
<p>The chapters in this section address idiomatic ways to achieve the same goals
that out parameters are used for in C++. Many of the Rust idioms resemble the
recommended alternatives to out parameters when programming against newer C++
standards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h1>
<p>One idiom for returning multiple values from a function or method in C++ is to
pass in references to which the values can be assigned.</p>
<p>There are several reasons why this idiom might be used:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, or</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic translation of this program into Rust makes use of either
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> or a named
structure for the return type.</p>
<div class="comparison">
<pre><code class="language-cpp">void get_point(int &amp;x, int &amp;y) {
  x = 5;
  y = 6;
}

int main() {
  int x, y;
  get_point(x, y);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn get_point() -&gt; (i32, i32) {
    (5, 6)
}

fn main() {
    let (x, y) = get_point();
    // ...
}</code></pre></pre>
</div>
<p>Rust has a dedicated tuple syntax and supports pattern matching with <code>let</code>
bindings in part to support use cases like this one.</p>
<h2 id="problems-with-the-direct-transliteration"><a class="header" href="#problems-with-the-direct-transliteration">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but Rust requires the initialization of the variables before they can be
passed to a function. The resulting program is not idiomatic Rust.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOMATIC RUST
fn get_point(x: &amp;mut i32, y: &amp;mut i32) {
    *x = 5;
    *y = 6;
}

fn main() {
    let mut x = 0; // initialized to arbitrary values
    let mut y = 0;
    get_point(&amp;mut x, &amp;mut y);
    // ...
}</code></pre></pre>
<p>This approach requires assigning arbitrary initial values to the variables and
making the variables mutable, both of which make it harder for the compiler to
help with avoiding programming errors.</p>
<p>Additionally, the Rust compiler is tuned for optimizing the idiomatic version of
the program, and produces a significantly faster binary for that version.</p>
<p>In situations where the performance of memory allocation is a concern (such as
when it is necessary to reuse entire buffers in memory), the trade-offs may be
different. That situation is discussed in the chapter on <a href="idioms/out_params//idioms/out_params/pre-allocated_buffers.html">pre-allocated
buffers</a>.</p>
<h2 id="similarities-with-idiomatic-c-since-c11"><a class="header" href="#similarities-with-idiomatic-c-since-c11">Similarities with idiomatic C++ since C++11</a></h2>
<p>In C++11 and later, <code>std::pair</code> and <code>std::tuple</code> are available for returning
multiple values instead of assigning to reference parameters.</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;utility&gt;

std::pair&lt;int, int&gt; get_point() {
  return std::make_pair(5, 6);
}

int main() {
  int x, y;
  std::tie(x, y) = get_point();
  // ...
}
</code></pre>
<p>This more closely aligns with the normal Rust idiom for returning multiple
values.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;multiple_return&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e30276-7ebe-499e-b8b0-4acfb815feaa&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n) -&gt; (&amp;[u8], &amp;[u8]);\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n) -&gt; (usize, usize);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    remaining: &amp;mut &amp;[u8],\n) -&gt; &amp;[u8];\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic translation of this C++ function\nsignature into a Rust function signature?\n\n```cpp\nvoid main() {}\n```\n\n```cpp\n#include &lt;cstdint&gt;\n\nvoid splitAt(std::uint8_t *data,\n             std::size_t dataSize,\n             uint8_t **left,\n             std::size_t *leftSize,\n             uint8_t **right,\n             std::size_t *rightSize);\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="optional-return-values"><a class="header" href="#optional-return-values">Optional return values</a></h1>
<p>One idiom in C++ for optionally producing a result from a method or function is
to use a reference parameter along with a boolean or integer return value to
indicate whether the result was produced. This might be done for the same
reasons as for using <a href="idioms/out_params//idioms/out_params/multiple_return.html">out parameters for multiple return
values</a>:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, and</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic Rust approach for optionally returning a value is to return a
value of type <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

bool safe_divide(unsigned int dividend,
                 unsigned int divisor,
                 unsigned int &amp;quotient) {
  if (divisor != 0) {
    quotient = dividend / divisor;
    return true;
  } else {
    return false;
  }
}

void go(unsigned int dividend,
        unsigned int divisor) {
  unsigned int quotient;
  if (safe_divide(dividend, divisor, quotient)) {
    std::cout &lt;&lt; quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn safe_divide(
    dividend: u32,
    divisor: u32,
) -&gt; Option&lt;u32&gt; {
    if divisor != 0 {
        Some(dividend / divisor)
    } else {
        None
    }
}

fn go(dividend: u32, divisor: u32) {
    match safe_divide(dividend, divisor) {
        Some(quotient) =&gt; {
            println!("{}", quotient);
        }
        None =&gt; {
            println!("Division failed!");
        }
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
</div>
<p>When there is useful information to provide in the failing case, the <a href="https://doc.rust-lang.org/std/result/"><code>Result</code>
type</a> can be used instead. The <a href="idioms/out_params//idioms/exceptions.html">chapter
on error handling</a> describes the use of <code>Result</code>.</p>
<h2 id="returning-a-pointer"><a class="header" href="#returning-a-pointer">Returning a pointer</a></h2>
<p>When the value being returned is a pointer, another common idiom in C++ is to
use <code>nullptr</code> to represent the optional case. In the Rust translation of that
idiom, <code>Option</code> is also used, along with a reference type, such as <code>&amp;</code> or <code>Box</code>.
See <a href="idioms/out_params//idioms/null/sentinel_values.html#nullptr">the chapter on using <code>nullptr</code> as a sentinel
value</a> for more details.</p>
<h2 id="problems-with-the-direct-transliteration-1"><a class="header" href="#problems-with-the-direct-transliteration-1">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but the resulting code is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOIMATIC RUST
fn safe_divide(dividend: u32, divisor: u32, quotient: &amp;mut u32) -&gt; bool {
    if divisor != 0 {
        *quotient = dividend / divisor;
        true
    } else {
        false
    }
}

fn go(dividend: u32, divisor: u32) {
    let mut quotient: u32 = 0; // initliazed to arbitrary value
    if safe_divide(dividend, divisor, &amp;mut quotient) {
        println!("{}", quotient);
    } else {
        println!("Division failed!");
    }
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<p>This shares the same problems as with using out-parameters for <a href="idioms/out_params//idioms/out_params/multiple_return.html#problems-with-the-direct-transliteration">multiple return
values</a>.</p>
<h2 id="similarities-with-c-since-c17"><a class="header" href="#similarities-with-c-since-c17">Similarities with C++ since C++17</a></h2>
<p>C++17 and later offer <code>std::optional</code>, which can be used to express optional
return values in a way similar to the idiomatic Rust example.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;optional&gt;

std::optional&lt;unsigned int&gt; safe_divide(unsigned int dividend,
                                        unsigned int divisor) {
  if (divisor != 0) {
    return std::optional&lt;unsigned int&gt;(dividend / divisor);
  } else {
    return std::nullopt;
  }
}

void go(unsigned int dividend, unsigned int divisor) {
  if (auto quotient = safe_divide(dividend, divisor)) {
    std::cout &lt;&lt; *quotient &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "Division failed!" &lt;&lt; std::endl;
  }
}

int main() {
  go(10, 2);
  go(10, 0);
}
</code></pre>
<h2 id="helpful-option-utilities"><a class="header" href="#helpful-option-utilities">Helpful <code>Option</code> utilities</a></h2>
<p>Rust provides several syntactic sugars for simplifying use of functions that return <code>Option</code>. If a failure should be propagated to the caller, then use the <code>?</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: u32, divisor: u32) -&gt; Option&lt;()&gt; {
    let quotient = safe_divide(dividend, divisor)?;
    println!("{}", quotient);
    Some(())
}
<span class="boring">}</span></code></pre></pre>
<p>If <code>None</code> should not be propagated, it is sometimes clearer to use <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let-else</code>
syntax</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn go(dividend: u32, divisor: u32) {
    let Some(quotient) = safe_divide(dividend, divisor) else {
        println!("Division failed!");
        return;
    };
    println!("{}", quotient);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>If there is a default value that should be used in the <code>None</code> case, the
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>Option::unwrap_or</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option::unwrap_or_else</code></a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default</code></a>,
or
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
methods can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn safe_divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {
</span><span class="boring">    if divisor != 0 {
</span><span class="boring">        Some(dividend / divisor)
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn expensive_computation() -&gt; u32 {
    // ...
<span class="boring">   0
</span>}

fn go(dividend: u32, divisor: u32) {
    // If None, returns the given value.
    let result = safe_divide(dividend, divisor).unwrap_or(0);

    // If None, returns the result of calling the given function.
    let result2 = safe_divide(dividend, divisor).unwrap_or_else(expensive_computation);

    // If None, returns Default::default(), which is 0 for u32.
    let result3 = safe_divide(dividend, divisor).unwrap_or_default();

    // If None, panics. Prefer the other methods!
    // let result3 = safe_divide(dividend, divisor).unwrap();
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    go(10, 2);
</span><span class="boring">    go(10, 0);
</span><span class="boring">}</span></code></pre></pre>
<p>In performance-sensitive code where you have manually checked that the result is
guaranteed to be <code>Some</code>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_unchecked"><code>Option::unwrap_unchecked</code></a>
can be used, but is an unsafe method.</p>
<p>There are <a href="https://doc.rust-lang.org/std/option/#boolean-operators">additional utility
methods</a> that enable
concise handling of <code>Option</code> values, which this book covers in the chapter on
<a href="idioms/out_params//idioms/exceptions.html">exceptions and error handling</a>.</p>
<h2 id="an-alternative-approach"><a class="header" href="#an-alternative-approach">An alternative approach</a></h2>
<p>An alternative approach in Rust to returning optional values is to require that
the caller of a function prove that the value with which they call a function
will not result in the failing case.</p>
<p>For the above safe division example, this involves the caller guaranteeing that
the provided divisor is non-zero. In the following example this is done with a
dynamic check. In other contexts the evidence needed may be available
statically, provided from callers further upstream, or used more than once. In
those cases, this approach reduces both runtime cost and code complexity.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::num::NonZero;

fn safe_divide(dividend: u32, divisor: NonZero&lt;u32&gt;) -&gt; u32 {
    // This is more efficient because the overflow check is skipped.
    dividend / divisor
}

fn go(dividend: u32, divisor: u32) {
    let Ok(safe_divisor) = NonZero::try_from(divisor) else {
        println!("Can't divide!");
        return;
    };

    let quotient = safe_divide(dividend, safe_divisor);
    println!("{}", quotient);
}

fn main() {
    go(10, 2);
    go(10, 0);
}</code></pre></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;optional_return&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;6471e372-6552-41e9-88c6-7b7f6665928e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) -&gt; Option&lt;&amp;'a mut [u8]&gt; {\n    if buf1.len() &gt;= needed_len {\n        Some(buf1)\n    } else if buf2.len() &gt;= needed_len {\n        Some(buf2)\n    } else {\n        None\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut &amp;'a mut [u8],\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) {\n    if buf1.len() &gt;= needed_len {\n        *buffer = buf1;\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = buf2;\n    }\n}\n```\n&quot;,&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut &amp;'a mut [u8],\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) -&gt; bool {\n    if buf1.len() &gt;= needed_len {\n        *buffer = buf1;\n        return true;\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = buf2;\n        return true;\n    }\n\n    return false;\n}\n```\n&quot;,&quot;```rust\nfn choose_buffer&lt;'a&gt;(\n    needed_len: usize,\n    buffer: &amp;mut Option&lt;&amp;'a mut [u8]&gt;,\n    buf1: &amp;'a mut [u8],\n    buf2: &amp;'a mut [u8],\n) {\n    if buf1.len() &gt;= needed_len {\n        *buffer = Some(buf1);\n    } else if buf2.len() &gt;= needed_len {\n        *buffer = Some(buf2);\n    } else {\n        *buffer = None;\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic translation of C++ function into\nRust?\n\n```cpp\n#include &lt;cstdint&gt;\n\nvoid chooseBuffer(std::size_t neededLen,\n                  std::uint8_t **buffer,\n                  std::size_t *bufferLen,\n                  uint8_t *buf1,\n                  std::size_t buf1Len,\n                  uint8_t *buf2,\n                  std::size_t buf2Len) {\n\tif (buf1Len &gt;= neededLen) {\n\t\t*buffer = buf1;\n\t\t*bufferLen = buf1Len;\n\t} else if (buf2Len &gt;= neededLen) {\n\t\t*buffer = buf2;\n\t\t*bufferLen = buf2Len;\n\t} else {\n\t\t*buffer = nullptr;\n\t\t*bufferLen = 0;\n\t}\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
