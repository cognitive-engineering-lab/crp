<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Template classes, functions, and methods - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="template-classes-functions-and-methods"><a class="header" href="#template-classes-functions-and-methods">Template classes, functions, and methods</a></h1>
<p>The most common uses of templates in C++ are to define classes, methods, traits,
or functions that work for any type (or at least for any type that provides
certain methods). This use case is common in the STL for container classes (such
as <code>&lt;vector&gt;</code>) and for the algorithms library (<code>&lt;algorithm&gt;</code>).</p>
<p>The following example defines a template for a directed graph represented as an
adjacency list, where the graph is generic in the type of the labels on the
nodes. Though the example shows a template class, the same comparisons with Rust
apply to template methods and template functions.</p>
<p>The same kind of reusable code can be created in Rust using generic types.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  std::vector&lt;Label&gt; nodeLabels;

public:
  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(label);
    return numNodes() - 1;
  }

  void addEdge(size_t from, size_t to) {
    size_t numNodes = this-&gt;numNodes();
    if (from &gt;= numNodes || to &gt;= numNodes) {
      throw std::invalid_argument(
          "Node index out of range");
    }
    adjacencies[from].push_back(to);
  }

  size_t numNodes() const {
    return adjacencies.size();
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DirectedGraph&lt;Label&gt; {
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    node_labels: Vec&lt;Label&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn add_node(
        &amp;mut self,
        label: Label,
    ) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn add_edge(
        &amp;mut self,
        from: usize,
        to: usize,
    ) -&gt; Result&lt;(), &amp;str&gt; {
        let num_nodes = self.num_nodes();
        if from &gt;= num_nodes || to &gt;= num_nodes {
            Err("Node index out of range.")
        } else {
            self.adjacencies[from].push(to);
            Ok(())
        }
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In the use case demonstrated in the above example, there are few practical
differences between using C++ template to define a class and using and Rust's
generics to define a struct. Whenever one would use a template that takes a
<code>typename</code> or <code>class</code> parameter in C++, one can instead take a type parameter in
Rust.</p>
<h2 id="operations-on-the-parameterized-type"><a class="header" href="#operations-on-the-parameterized-type">Operations on the parameterized type</a></h2>
<p>The differences become more apparent when one attempts to perform operations on
the values. The following code listing adds a method to get the smallest node in
the graph to both the Rust and the C++ examples.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;optional&gt;
<span class="boring">#include &lt;stdexcept&gt;
</span><span class="boring">#include &lt;vector&gt;
</span>
template &lt;typename Label&gt;
class DirectedGraph {
<span class="boring">  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
</span><span class="boring">  std::vector&lt;Label&gt; nodeLabels;
</span><span class="boring">
</span>public:
<span class="boring">  size_t addNode(Label label) {
</span><span class="boring">    adjacencies.push_back(std::vector&lt;size_t&gt;());
</span><span class="boring">    nodeLabels.push_back(label);
</span><span class="boring">    return numNodes() - 1;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  void addEdge(size_t from, size_t to) {
</span><span class="boring">    size_t numNodes = this-&gt;numNodes();
</span><span class="boring">    if (from &gt;= numNodes || to &gt;= numNodes) {
</span><span class="boring">      throw std::invalid_argument(
</span><span class="boring">          "Node index out of range");
</span><span class="boring">    }
</span><span class="boring">    adjacencies[from].push_back(to);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  size_t numNodes() const {
</span><span class="boring">    return adjacencies.size();
</span><span class="boring">  }
</span><span class="boring">
</span>  std::optional&lt;size_t&gt; smallestNode() {
    if (nodeLabels.empty()) {
      return std::nullopt;
    }
    Label &amp;least = nodeLabels[0];
    size_t index = 0;

    for (int i = 1; i &lt; nodeLabels.size(); i++) {
      if (least &gt; nodeLabels[i]) {
        least = nodeLabels[i];
        index = i;
      }
    }
    return std::optional(index);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        // Matches the C++, but is not the idomatic
        // implementation!
        if self.node_labels.is_empty() {
            None
        } else {
            let mut least = &amp;self.node_labels[0];
            let mut index = 0;
            for i in 1..self.node_labels.len() {
                if *least &gt; self.node_labels[i] {
                    least = &amp;self.node_labels[i];
                    index = i;
                }
            }
            Some(index)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The major difference between these implementations is that in the C++ version
<code>operator&gt;</code> is used on the values without knowing whether the operator is
defined for the type. In the Rust version, there is a constraint requiring that
the <code>Label</code> type implement the <code>Ord</code> trait. (See the chapter on <a href="/idioms/data_modeling/concepts.html">concepts,
interfaces, and static dispatch</a> for more
details on Rust traits and how they relate to C++ concepts.)</p>
<p>Unlike C++ templates, generic definitions in Rust are type checked at the point
of definition rather than at the point of use. This means that for operations to
be used on values with the type of a type parameter, the parameter has to be
constrained to types that implement some trait. As can be seen in the above
example, much like with C++ concepts and <code>requires</code>, the constraint can be
required for individual methods rather than for the whole generic class.</p>
<p>It is best practice in Rust to put the trait bounds on the specific things that
require the bounds, in order to make the overall use of the types more flexible.</p>
<p>As an aside, a more idiomatic implementation of <code>smallest_node</code> makes use of
Rust's iterators. This style of implementation may take some getting used to for
programmers more accustomed to implementations in the style used in the earlier
example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        self.node_labels
            .iter()
            .enumerate()
            .map(|(i, l)| (l, i))
            .min()
            .map(|(_, i)| i)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>An even more idiomatic implementation would make use of the <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.position_min">itertools
crate</a>.</p>
<pre><code class="language-rust ignore">use itertools::*;

<span class="boring">pub struct DirectedGraph&lt;Label&gt; {
</span><span class="boring">    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    node_labels: Vec&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
<span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        DirectedGraph {
</span><span class="boring">            adjacencies: Vec::new(),
</span><span class="boring">            node_labels: Vec::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_node(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        label: Label,
</span><span class="boring">    ) -&gt; usize {
</span><span class="boring">        self.adjacencies.push(Vec::new());
</span><span class="boring">        self.node_labels.push(label);
</span><span class="boring">        self.num_nodes() - 1
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn num_nodes(&amp;self) -&gt; usize {
</span><span class="boring">        self.node_labels.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_edge(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        from: usize,
</span><span class="boring">        to: usize,
</span><span class="boring">    ) -&gt; Result&lt;(), &amp;str&gt; {
</span><span class="boring">        if from &gt; self.num_nodes()
</span><span class="boring">            || to &gt; self.num_nodes()
</span><span class="boring">        {
</span><span class="boring">            Err("Node not in graph.")
</span><span class="boring">        } else {
</span><span class="boring">            self.adjacencies[from].push(to);
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn smallest_node(&amp;self) -&gt; Option&lt;usize&gt;
    where
        Label: Ord,
    {
        self.node_labels.iter().position_min()
    }
}</code></pre>
<h2 id="constexpr-template-parameters"><a class="header" href="#constexpr-template-parameters"><code>constexpr</code> template parameters</a></h2>
<p>Rust also supports the equivalent of constexpr template parameters. For example,
one can define a generic function that returns an array consecutive integers
starting from a specific value and whose size is determined at compile time.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cstddef&gt;

template &lt;size_t N&gt;
std::array&lt;int, N&gt;
makeSequentialArray(int start) {
  std::array&lt;int, N&gt; arr;
  for (size_t i = 0; i &lt; N; i++) {
    arr[i] = start + i;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_sequential_array&lt;const N: usize&gt;(
    start: i32,
) -&gt; [i32; N] {
    std::array::from_fn(|i| start + i as i32)
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The corresponding idiomatic Rust function uses the helper <code>std::array::from_fn</code>
to construct the array. <code>from_fn</code> itself takes as type parameters the element
type and the constant. Those arguments are elided because Rust can infer them,
because both are part of the type of the produced array.</p>
<h2 id="rusts-self-type"><a class="header" href="#rusts-self-type">Rust's <code>Self</code> type</a></h2>
<p>Within a Rust struct defintion, <code>impl</code> block, or <code>impl</code> trait block, there is a
<code>Self</code> type that is in scope. The <code>Self</code> type is the type of the class being
defined with all of the generic type parameters filled in. It can be useful to
refer to this type especially in cases where there are many parameters that
would otherwise have to be listed out.</p>
<p>The <code>Self</code> type is necessary when defining generic traits to refer to the
concrete implementing type. Because Rust does not have inheritance between
concrete types and does not have method overriding, this is sufficient to avoid
the need to pass the implementing type as a type parameter.</p>
<p>For examples of this, see the chapter on the <a href="/patterns/crtp.html#method-chaining">curiously reoccurring template
pattern</a>.</p>
<h2 id="a-note-on-type-checking-and-type-errors"><a class="header" href="#a-note-on-type-checking-and-type-errors">A note on type checking and type errors</a></h2>
<p>The checking of generic types at the point of definition rather than at the
point of template expansion impacts when errors are detected and how they are
reported. Some of this difference cannot be achieved by consistently using C++
concepts to declare the operations required.</p>
<p>For example, one might accidentally make the <code>nodeLabels</code> member a vector of
<code>size_t</code> instead of a vector of the label parameter. If all of the test cases
for the graph used label types that were convertible to integers, the error
would not be detected.</p>
<p>A similar Rust program fails to compile, even without a function that
instantiates the generic structure with a concrete type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;vector&gt;

template &lt;typename Label&gt;
class DirectedGraph {
  // The mistake is here: size_t should be Label
  std::vector&lt;std::vector&lt;size_t&gt;&gt; adjacencies;
  std::vector&lt;size_t&gt; nodeLabels;

public:
  Label getNode(size_t nodeId) {
    return nodeLabels[nodeId];
  }

  size_t addNode(Label label) {
    adjacencies.push_back(std::vector&lt;size_t&gt;());
    nodeLabels.push_back(label);
    return numNodes() - 1;
  }

  size_t numNodes() const {
    return adjacencies.size();
  }
};

#define BOOST_TEST_MODULE DirectedGraphTests
#include &lt;boost/test/included/unit_test.hpp&gt;

BOOST_AUTO_TEST_CASE(test_add_node_int) {
  DirectedGraph&lt;int&gt; g;
  auto n1 = g.addNode(1);
  BOOST_CHECK_EQUAL(1, g.getNode(n1));
}

BOOST_AUTO_TEST_CASE(test_add_node_float) {
  DirectedGraph&lt;float&gt; g;
  float label = 1.0f;
  auto n1 = g.addNode(label);
  BOOST_CHECK_CLOSE(label, g.getNode(n1), 0.0001);
}
</code></pre>
<pre><code class="language-rust ignore">pub struct DirectedGraph&lt;Label&gt; {
    // The mistake is here: size_t should be Label
    adjacencies: Vec&lt;Vec&lt;usize&gt;&gt;,
    node_labels: Vec&lt;usize&gt;,
}

impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
    pub fn new() -&gt; Self {
        DirectedGraph {
            adjacencies: Vec::new(),
            node_labels: Vec::new(),
        }
    }

    pub fn get_node(
        &amp;self,
        node_id: usize,
    ) -&gt; Option&lt;&amp;Label&gt; {
        self.node_labels.get(node_id)
    }

    pub fn add_node(
        &amp;mut self,
        label: Label,
    ) -&gt; usize {
        self.adjacencies.push(Vec::new());
        self.node_labels.push(label);
        self.num_nodes() - 1
    }

    pub fn num_nodes(&amp;self) -&gt; usize {
        self.node_labels.len()
    }
}</code></pre>
</div>
<p>Despite the error, the C++ example compiles and passes the tests.</p>
<pre><code class="language-text">Running 2 test cases...

*** No errors detected
</code></pre>
<p>Even without test cases, the Rust example fails to compile and produces a
message useful for identifying the error.</p>
<pre><code class="language-text">error[E0308]: mismatched types
    --&gt; example.rs:26:31
     |
6    | impl&lt;Label&gt; DirectedGraph&lt;Label&gt; {
     |      ----- found this type parameter
...
26   |         self.node_labels.push(label);
     |                          ---- ^^^^^ expected `usize`, found type parameter `Label`
     |                          |
     |                          arguments to this method are incorrect
     |
     = note:        expected type `usize`
             found type parameter `Label`
</code></pre>
<h2 id="lifetimes-parameters"><a class="header" href="#lifetimes-parameters">Lifetimes parameters</a></h2>
<p>Rust's generics are also used for classes, methods, traits, and functions that
are generic in the lifetimes of the references they manipulate. Unlike other
type parameters, the using a function with different lifetimes does not cause
additional copies of the function to be generated in the compiled code, because
lifetimes do not impact the runtime representation.</p>
<p>The chapter on concepts includes <a href="/idioms/data_modeling/concepts.html#generics-and-lifetimes">examples of how lifetimes interact with Rust's
generics</a>.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>One significant difference between C++ templates and Rust generics is that C++
templates are actually a more general purpose macro language, supporting things
like conditional compilation (e.g., when used in conjunction with <code>if constexpr</code>, <code>requires</code>, or <code>std::enable_if</code>). Rust supports these use cases with
its macro system, which differs significantly from C++. The most common use of
the macro system, conditional compilation, is provided by <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">the <code>cfg</code> attribute
and <code>cfg!</code> macro</a>.</p>
<p>The separation of conditional compilation from generics in Rust involves similar
design considerations as the omission of <a href="/idioms/data_modeling/template_specialization.html">template
specialization</a> from Rust.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;templates&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;07a5f967-6274-456e-ba10-ccc66bea69b7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt; {\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt;\n    where\n        K: Eq,\n    {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt; {\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt; {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;,&quot;```rust\nuse std::collections::vec_deque::*;\n\npub struct Assoc&lt;K, V&gt; {\n    assocs: VecDeque&lt;(K, V)&gt;,\n}\n\nimpl&lt;K, V&gt; Assoc&lt;K, V&gt;\nwhere\n    K: Eq,\n{\n    pub fn insert(&amp;mut self, key: K, value: V) {\n        self.assocs.push_front((key, value));\n    }\n\n    pub fn lookup(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt; {\n        for (k, v) in &amp;self.assocs {\n            if *k == key {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename K, typename V&gt;\nclass Assoc {\n  std::vector&lt;std::pair&lt;K, V&gt;&gt; assocs;\n\npublic:\n  void insert(K key, V value) {\n    assocs.push_front(std::make_pair(key, value));\n  }\n\n  std::optional&lt;V &amp;&gt; lookup(K key) const {\n    K k;\n    V v;\n    for (std::pair&lt;K, V&gt; assoc : assocs) {\n      std::tie(k, v) = assoc;\n      if (k == key) {\n        return std::make_optional(v);\n      }\n    }\n    return std::nullopt;\n  }\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Template classes, functions, and methods">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../idioms/data_modeling/inheritance_and_reuse.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../idioms/data_modeling/template_specialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../idioms/data_modeling/inheritance_and_reuse.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../idioms/data_modeling/template_specialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
