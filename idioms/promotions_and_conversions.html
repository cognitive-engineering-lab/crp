<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type promotions and conversions - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-promotions-and-conversions"><a class="header" href="#type-promotions-and-conversions">Type promotions and conversions</a></h1>
<h2 id="lvalue-to-rvalue"><a class="header" href="#lvalue-to-rvalue">lvalue to rvalue</a></h2>
<p>In C++ lvalues are automatically converted to rvalues when needed.</p>
<p>In Rust the equivalent of lvalues are "place expressions" (expressions that
represent memory locations) and the equivalent of rvalues are "value
expressions". Place expressions are automatically converted to value expressions
when needed.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  // Local variables are lvalues,
  int x(0);
  // and therefore may be assigned to.
  x = 42;

  // x is converted to an lvalue when needed.
  int y = x + 1;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Local variables are place expressions,
    let mut x = 0;
    // and therefore may be assigned to.
    x = 42;

    // x is converted to a value expression when
    // needed.
    let y = x + 1;
}</code></pre></pre>
</div>
<h2 id="array-to-pointer"><a class="header" href="#array-to-pointer">Array to pointer</a></h2>
<p>In C++, arrays are automatically converted to pointers as required.</p>
<p>The equivalent to this in Rust is the automatic conversion of vector and array
references to slice references.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstring&gt;

int main() {
  char example[6] = "hello";
  char other[6];

  // strncpy takes arguments of type char*
  strncpy(other, example, 6);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn third(ts: &amp;[char]) -&gt; Option&lt;&amp;char&gt; {
    ts.get(2)
}

fn main() {
    let vec: Vec&lt;char&gt; = vec!['a', 'b', 'c'];
    let arr: [char; 3] = ['a', 'b', 'c'];

    third(&amp;vec);
    third(&amp;arr);
}</code></pre></pre>
</div>
<p>Because slice references can be easily used in a memory-safe way, it is
generally recommended in Rust to define functions in terms of slice references
instead of in terms of references to vectors or arrays, unless vector-specific
or array-specific functionality is needed.</p>
<p>Unlike in C++ where the conversion from arrays to pointers is built into the
language, this is actually a general mechanism provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a>, which provides one
kind of <a href="./user-defined_conversions.html">user-defined conversion</a>.</p>
<h2 id="function-to-pointer"><a class="header" href="#function-to-pointer">Function to pointer</a></h2>
<p>In C++ functions and static member functions are automatically converted to
function pointers.</p>
<p>Rust performs the same conversion. In addition to functions and members that do
not take <code>self</code> as an argument, constructors (proper constructors) also have
function type and can be converted to function pointers. Non-capturing closures
do not have function type, but can also be converted to function pointers.</p>
<div class="comparison">
<pre><code class="language-cpp">int twice(int n) {
  return n * n;
}

struct MyPair {
  int x;
  int y;

  MyPair(int x, int y) : x(x), y(y) {}

  static MyPair make() {
    return MyPair{0, 0};
  }
};

int main() {
  // convert a function to a function pointer
  int (*twicePtr)(int) = twice;
  int result = twicePtr(5);

  // Per C++23 11.4.5.1.6, can't take the address
  // of a constructor.
  // MyPair (*ctor)(int, int) = MyPair::MyPair;
  // MyPair pair = ctor(10, 20);

  // convert a static method to a function
  // pointer
  MyPair (*methodPtr)() = MyPair::make;
  MyPair pair2 = methodPtr();

  // convert a non-capturing closure to a
  // function pointer
  int (*closure)(int) = [](int x) -&gt; int {
    return x * 5;
  };
  int closureRes = closure(2);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn twice(x: i32) -&gt; i32 {
    x * x
}

struct MyPair(i32, i32);

impl MyPair {
    fn new() -&gt; MyPair {
        MyPair(0, 0)
    }
}

fn main() {
    // convert a function to a function pointer
    let twicePtr: fn(i32) -&gt; i32 = twice;
    let res = twicePtr(5);

    // convert a constructor to a function pointer
    let ctorPtr: fn(i32, i32) -&gt; MyPair = MyPair;
    let pair = ctorPtr(10, 20);

    // convert a static method to a function
    // pointer
    let methodPtr: fn() -&gt; MyPair = MyPair::new;
    let pair2 = methodPtr();

    // convert a non-capturing closure to a
    // function pointer
    let closure: fn(i32) -&gt; i32 = |x: i32| x * 5;
    let closureRes = closure(2);
}</code></pre></pre>
</div>
<h2 id="numeric-promotion-and-numeric-conversion"><a class="header" href="#numeric-promotion-and-numeric-conversion">Numeric promotion and numeric conversion</a></h2>
<p>In C++ there are several kinds of implicit conversions that occur between
numeric types. The most commonly encountered are numeric promotions, which
convert numeric types to larger types.</p>
<p>These lossless conversions are not implicit in Rust. Instead, they must be
performed explicitly using the <code>Into::into()</code> method. These conversions are
provided by implementations of the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits. The list
of conversions provided by the Rust standard library is <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors">listed on the
documentation
page</a> for
the trait.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  int x(42);
  long y = x;

  float a(1.0);
  double b = a;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let y: i64 = x.into();

    let a: f32 = 1.0;
    let b: f64 = a.into();
}</code></pre></pre>
</div>
<p>There are several implicit conversions that occur in C++ that are not lossless.
For example, integers can be implicitly converted to unsigned integers in C++.</p>
<p>In Rust, these conversions are also required to be explicit and are provided by
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> traits
which require handling the cases where the value does not map to the other type.</p>
<div class="comparison">
<pre><code class="language-cpp">int main() {
  int x(42);
  unsigned int y(x);

  float a(1.0);
  double b(a);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;

fn main() {
    let x: i32 = 42;
    let y: u32 = match x.try_into() {
        Ok(x) =&gt; x,
        Err(err) =&gt; {
            panic!("Can't convert! {:?}", err);
        }
    };
}</code></pre></pre>
</div>
<p>Some conversions that occur in C++ are supported by neither <code>From</code> nor <code>TryFrom</code>
because there is not a clear choice of conversion or because they are not
value-preserving. For example, in C++ <code>int32_t</code> can implicitly be converted to
<code>float</code> despite <code>float</code> not being able to represent all 32 bit integers
precisely, but in Rust there is no <code>TryFrom&lt;i32&gt;</code> implementation for <code>f32</code>.</p>
<p>In Rust the only way to convert from an <code>i32</code> to an <code>f32</code> is with the <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#r-expr.as.coercions"><code>as</code>
operator</a>.
The operator can actually be used to convert between other primitive types as
well and does not panic or produce undefined behavior, but may not convert in
the desired way (e.g., it may use a different rounding mode than desired or it
may truncate rather than saturate as desired).</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  int32_t x(42);
  float a = x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let a: f32 = x as f32;
}</code></pre></pre>
</div>
<h3 id="isize-and-usize"><a class="header" href="#isize-and-usize"><code>isize</code> and <code>usize</code></a></h3>
<p>In the Rust standard library the <code>isize</code> and <code>usize</code> types are used for values
intended to used be indices (much like <code>size_t</code> in C++). However, their use for
other purposes is usually discouraged in favor of using explicitly sized types
such as <code>u32</code>. This results a situation where values of type <code>u32</code> have to be
converted to <code>usize</code> for use in indexing, but <code>Into&lt;usize&gt;</code> is not implemented
for <code>u32</code>.</p>
<p>In these cases, best practice is to use <code>TryInto</code>, and if further error handling
of the failure cause is not desired, to call <code>unwrap</code>, creating a panic at the
point of conversion.</p>
<p>This is preferred because it prevents the possibility of moving forward with an
incorrect value. E.g., consider converting a <code>u64</code> to a <code>usize</code> that has a
32-bit representation with <code>as</code>, which truncates the result. A value that is one
greater than the <code>u32::MAX</code> will truncate to <code>0</code>, which would probably result in
successfully retrieving the wrong value from a data structure, thus masking a
bug and producing unexpected behavior.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>In C++ enums can be implicitly converted to integer types.</p>
<p>In Rust the conversion requires the use of the <code>as</code> operator, and providing
<code>From</code> and <code>TryFrom</code> implementations to move back and forth between the enum and
its representation type is recommended. Examples and additional details are
given in the <a href="./data_modeling/enums.html">chapter on enums</a>.</p>
<h2 id="qualification-conversion"><a class="header" href="#qualification-conversion">Qualification conversion</a></h2>
<p>In C++ qualification conversions enable the use of const (or volatile) values
where the const (or volatile) qualifier is not expected.</p>
<p>In Rust the equivalent enables the use of <code>mut</code> variables and <code>mut</code> references
to be used where non-<code>mut</code> variables or references are expected.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

void display(const std::string &amp;msg) {
  std::cout &lt;&lt; "Displaying: " &lt;&lt; msg &lt;&lt; std::endl;
}

int main() {
  // no const qualifier
  std::string message("hello world");

  // used where const expected
  display(message);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn display(msg: &amp;str) {
    println!("{}", msg);
}

fn main() {
    let mut s: String = "hello world".to_string();
    let message: &amp;mut str = s.as_mut();
    display(message);
}</code></pre></pre>
</div>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer literals</a></h2>
<p>In C++ integer literals with no suffix indicating type have the smallest type in
which they can fit from <code>int</code>, <code>long int</code>, or <code>long long int</code>. When the literal
is then assigned to a variable of a different type, an implicit conversion is
performed.</p>
<p>In Rust, integer literals have their type inferred depending on context. When
there is insufficient information to infer a type either <code>i32</code> is assumed or may
require some type annotation to be given.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  // Compiles without error (but with a warning).
  uint32_t x = 4294967296;

  // assumes int
  auto y = 1;

  // literal is given a larger type, so it prints
  // correctly
  std::cout &lt;&lt; 4294967296 &lt;&lt; std::endl;

  // these work as expected
  std::cout &lt;&lt; INT64_C(4294967296) &lt;&lt; std::endl;

  uint64_t z = INT64_C(4294967296);
  std::cout &lt;&lt; z &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // error: literal out of range for `u32`
    // let x: u32 = 4294967296;

    // assumes i32
    let y = 1;

    // fails to compile because it is inferred as i32
    // print!("{}", 4294967296);

    // These work, though.
    println!("{}", 4294967296u64);

    let z: u64 = 4294967296;
    println!("{}", z);
}</code></pre></pre>
</div>
<h2 id="safe-bools"><a class="header" href="#safe-bools">Safe bools</a></h2>
<p>The safe bool idiom exists to make it possible to use types as conditions. Since
C++11 this idiom is straightforward to implement.</p>
<p>In Rust instead of converting the value to a boolean, the normal idiom matches
on the value instead. Depending on the situation, the mechanism used for
matching might be <code>match</code>, <code>if let</code>, or <code>let else</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Wire {
  bool ready;
  unsigned int value;

  explicit operator bool() const { return ready; }
};

int main() {
  Wire w{false, 0};
  // ...

  if (w) {
    // use w.value
  } else {
    // do something else
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">enum Wire {
    Ready(u32),
    NotReady,
}

fn main() {
    let wire = Wire::NotReady;
    // ...

    // match
    match wire {
        Wire::Ready(v) =&gt; {
            // use value v
        }
        Wire::NotReady =&gt; {
            // do something else
        }
    }

    // if let
    if let Wire::Ready(v) = wire {
        // use value v
    }

    // let else
    let Wire::Ready(v) = wire else {
        // do something that doesn't continue,
        // like early return
        return;
    };
}</code></pre></pre>
</div>
<h2 id="user-defined-conversions"><a class="header" href="#user-defined-conversions">User-defined conversions</a></h2>
<p>User-defined conversions are covered in a <a href="./user-defined_conversions.html">separate
chapter</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;promotions_and_conversions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;98badbec-d894-490a-929b-327021cda0c3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::convert::TryInto;\n\nfn main() {\n    let x = 4294967296i64;\n\n    match TryInto::&lt;i32&gt;::try_into(x) {\n        Ok(y) =&gt; {\n            // ...\n        }\n        Err(err) =&gt; {\n            // ...\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn main() {\n    let x = 4294967296i64;\n    if Into::&lt;i64&gt;::into(i32::MIN) &lt; x\n        &amp;&amp; x &lt; Into::&lt;i64&gt;::into(i32::MAX)\n    {\n        let y = x as i32;\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n&quot;,&quot;```rust\nfn main() {\n    let x = 4294967296i64;\n    let y = x as i32;\n    if y as i64 == x {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n\nint main() {\n  int64_t x(4294967296);\n\n  if (std::numeric_limits&lt;int32_t&gt;::min() &lt; x &amp;&amp;\n      x &lt; std::numeric_limits&lt;int32_t&gt;::max()) {\n    int32_t y(x);\n    // ...\n  } else {\n    // ...\n  }\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Type promotions and conversions">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/type_equivalents.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../idioms/user-defined_conversions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/type_equivalents.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../idioms/user-defined_conversions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
