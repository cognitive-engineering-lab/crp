<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type promotions and conversions - Rust Phrasebook for C++ Programmers</title>


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Phrasebook for C++ Programmers</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-promotions-and-conversions"><a class="header" href="#type-promotions-and-conversions">Type promotions and conversions</a></h1>
<h2 id="lvalue-to-rvalue"><a class="header" href="#lvalue-to-rvalue">lvalue to rvalue</a></h2>
<p>In C++ lvalues are automatically converted to rvalues when needed.</p>
<pre><code class="language-cpp">int main() {
    int x(0); // Local variables are an lvalues,
    x = 42; // and therefore may be assigned to.

    int y = x + 1; // x can be converted to an lvalue when needed.

    return 0;
}
</code></pre>
<p>In Rust the equivalent of lvalues are "place expressions" (expressions that
represent memory locations) and the equivalent of rvalues are "value
expressions". Place expressions are automatically converted to value expressions
when needed.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 0; // Local variables are an lvalues,
    x = 42; // and therefore may be assigned to.

    let y = x + 1; // and therefore may be assigned to.
}</code></pre></pre>
<h2 id="array-to-pointer"><a class="header" href="#array-to-pointer">Array to pointer</a></h2>
<p>In C++, arrays are automatically converted to pointers as required.</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;

int main() {
  char example[6] = "hello";
  char other[6];

  // strncpy takes arguments of type char*
  strncpy(other, example, 6);

  return 0;
}
</code></pre>
<p>The equivalent to this in Rust is the automatic conversion of vector and array
references to slice references.</p>
<pre><pre class="playground"><code class="language-rust">fn third(ts: &amp;[char]) -&gt; Option&lt;&amp;char&gt; {
    ts.get(2)
}

fn main() {
    let vec: Vec&lt;char&gt; = vec!['a', 'b', 'c'];
    let arr: [char; 3] = ['a', 'b', 'c'];

    third(&amp;vec);
    third(&amp;arr);
}</code></pre></pre>
<p>Because slice references can be easily used in a memory-safe way, it is
generally recommended in Rust to define functions in terms of slice references
instead of in terms of references to vectors or arrays, unless vector-specific
or array-specific functionality is needed.</p>
<p>Unlike in C++ where the conversion from arrays to pointers is built into the
language, this is actually a general mechanism provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a>, which provides one
kind of <a href="/idioms/user-defined_conversions.html">user-defined conversion</a>.</p>
<h2 id="function-to-pointer"><a class="header" href="#function-to-pointer">Function to pointer</a></h2>
<p>In C++ functions and static member functions are automatically converted to
function pointers.</p>
<pre><code class="language-cpp">int twice(int n) { return n * n; }

int main() {
  int (*twicePtr)(int) = twice;
  int result = twicePtr(5);

  return 0;
}
</code></pre>
<p>Rust performs the same conversion. In addition to functions and members that do
not take <code>self</code> as an argument, constructors (proper constructors) also have
function type and can be converted to function pointers. Non-capturing closures
do not have function type, but can also be converted to function pointers. There
is no syntax in Rust for the function type itself.</p>
<pre><pre class="playground"><code class="language-rust">fn twice(x: i32) -&gt; i32 {
    x * x
}

struct MyPair(i32, i32);

impl MyPair {
    fn new() -&gt; MyPair {
        MyPair(0, 0)
    }
}

fn main() {
    let twicePtr: fn(i32) -&gt; i32 = twice;
    let res = twicePtr(5);

    let ctorPtr: fn(i32, i32) -&gt; MyPair = MyPair;
    let pair = ctorPtr(10, 20);

    let methodPtr: fn() -&gt; MyPair = MyPair::new;
    let pair2 = methodPtr();

    let closure: fn(i32) -&gt; i32 = |x: i32| x * 5;
    let closureRes = closure(2);
}</code></pre></pre>
<h2 id="numeric-promotion-and-numeric-conversion"><a class="header" href="#numeric-promotion-and-numeric-conversion">Numeric promotion and numeric conversion</a></h2>
<p>In C++ there are several kinds of implicit conversions that occur between
numeric types. The most commonly encountered are numeric promotions, which
convert numeric types to larger types.</p>
<pre><code class="language-cpp">int main() {
  int x(0);
  long y = x;

  float a(1.0);
  double b = a;

  return 0;
}
</code></pre>
<p>These lossless conversions are not implicit in Rust. Instead, they must be
performed explicitly using the <code>Into::into()</code> method. These conversions are
provided by implementations of the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits. The list
of conversions provided by the Rust standard library is <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors">listed on the
documentation
page</a> for
the trait.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let y: i64 = x.into();

    let a: f32 = 1.0;
    let b: f64 = a.into();
}</code></pre></pre>
<p>There are several implicit conversions that occur in C++ that are not lossless.
For example, integers can be implicitly converted to unsigned integers in C++.</p>
<pre><code class="language-cpp">int main() {
  int x(42);
  unsigned int y = x;

  return 0;
}
</code></pre>
<p>In Rust, these conversions are also required to be explicit and are provided by
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> traits
which require handling the cases where the value does not map to the other type.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;

fn main() {
    let x: i32 = 42;
    let y: u32 = match x.try_into() {
        Ok(x) =&gt; x,
        Err(err) =&gt; {
            panic!("Can't convert! {:?}", err);
        }
    };
}</code></pre></pre>
<p>Some conversions that occur in C++ are supported by neither <code>From</code> nor <code>TryFrom</code>
because the conversion is either insufficiently obvious or because they are not
value-preserving. For example, in C++ <code>int32_t</code> can implicitly be converted to
<code>float</code> despite <code>float</code> not being able to represent all 32 bit the integers
precisely.</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  int32_t x(42);
  float a = x;

  return 0;
}
</code></pre>
<p>In Rust the only way to convert from an <code>i32</code> to an <code>f32</code> is with the <a href="https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#r-expr.as.coercions"><code>as</code>
operator</a>.
The operator can actually be used to convert between other primitive types as
well and does not panic or produce undefined behavior, but may not convert in
the desired way (e.g., it may use a different rounding mode than desired or it
may truncate rather than saturate as desired).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42;
    let a: f32 = x as f32;
}</code></pre></pre>
<h3 id="isize-and-usize"><a class="header" href="#isize-and-usize"><code>isize</code> and <code>usize</code></a></h3>
<p>In the Rust standard library the <code>isize</code> and <code>usize</code> types are used for values
intended to used be indices (much like <code>size_t</code> in C++). However, their use for
other purposes is usually discouraged in favor of using explicitly sized types
such as <code>u32</code>. This results a situation where values of type <code>u32</code> have to be
converted to <code>usize</code> for use in indexing, but <code>Into&lt;usize&gt;</code> is not implemented
for <code>u32</code>.</p>
<p>In these cases, best practice is to use <code>TryInto</code>, and if further error handling
of the failure cause is not desired, to call <code>unwrap</code>, creating a panic at the
point of conversion.</p>
<p>This is preferred because it prevents the possibility of moving forward with an
incorrect value. E.g., consider converting a <code>u64</code> to a <code>usize</code> that has a
32-bit representation with <code>as</code>, which truncates the result. A value that is one
greater than the <code>u32::MAX</code> will truncate to <code>0</code>, which would probably result in
successfully retrieving a value from a data structure, thus masking a bug and
producing unexpected behavior.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>In C++ enums can be implicitly converted to integer types.</p>
<pre><code class="language-cpp">enum Shape {
  Triangle = 0,
  Circle,
};

int main() {
  int shape = Triangle;

  return 0;
}
</code></pre>
<p>In Rust the conversion requires the use of the <code>as</code> operator, and providing
<code>From</code> and <code>TryFrom</code> implementations to move back and forth between the enum and
its representation type is recommended. Examples and additional details are
given in the <a href="/idioms/data_modeling/enums.html">chapter on enums</a>.</p>
<h2 id="qualification-conversion"><a class="header" href="#qualification-conversion">Qualification conversion</a></h2>
<p>In C++ qualification conversions enable the use of const (or volatile) values
where the const (or volatile) qualifier is not expected.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

void display(const std::string &amp;str) {
  std::cout &lt;&lt; "Displaying: " &lt;&lt; str &lt;&lt; std::endl;
}

int main() {
  // no const qualifier
  std::string message("hello world");

  // used where const expected
  display(message);

  return 0;
}
</code></pre>
<p>In Rust the equivalent enables the use of <code>mut</code> variables and <code>mut</code> references
to be used where non-<code>mut</code> variables or references are expected.</p>
<pre><pre class="playground"><code class="language-rust">fn display(msg: &amp;str) {
    println!("{}", msg);
}

fn main() {
    let mut s: String = "hello world".to_string();
    let msg: &amp;mut str = s.as_mut();
    display(msg);
}</code></pre></pre>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer literals</a></h2>
<p>In C++ integer literals with no suffix indicating type have the smallest type in
which they can fit from <code>int</code>, <code>long int</code>, or <code>long long int</code>. When the literal
is then assigned to a variable of a different type, an implicit conversion is
performed.</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

int main() {
  // Compiles without error (but with a warning).
  uint32_t y = 4294967296;

  return 0;
}
</code></pre>
<p>In Rust, integer literals have their type inferred depending on context. When
there is insufficient information to infer a type either <code>i32</code> is assumed or may
require some type annotation to be given.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // error: literal out of range for `u32`
    // let x: u32 = 4294967296;

    let x = 1; // assumes i32

    // fails to compile because it is inferred as i32
    // print!("{}", 4294967296);

    // These work, though.
    println!("{}", 4294967296u64);

    let y: u64 = 4294967296;
    println!("{}", y);
}</code></pre></pre>
<h2 id="safe-bools"><a class="header" href="#safe-bools">Safe bools</a></h2>
<p>The safe bool idiom exists to make it possible to use types as conditions. Since
C++11 this idiom is straightforward to implement.</p>
<pre><code class="language-cpp">struct Wire {
  bool ready;
  unsigned int value;

  explicit operator bool() const { return ready; }
};

int main() {
  Wire w{false, 0};
  // ...

  if (w) {
    // use w.value
  } else {
    // do something else
  }

  return 0;
}
</code></pre>
<p>In Rust instead of converting the value to a boolean, the normal idiom matches
on the value instead. Depending on the situation, the mechanism used for
matching might be <code>match</code>, <code>if let</code>, or <code>let else</code>.</p>
<pre><pre class="playground"><code class="language-rust">enum Wire {
    Ready(u32),
    NotReady,
}

fn main() {
    let wire = Wire::NotReady;
    // ...

    // match
    match wire {
        Wire::Ready(v) =&gt; {
            // use value v
        }
        Wire::NotReady =&gt; {
            // do something else
        }
    }

    // if let
    if let Wire::Ready(v) = wire {
        // use value v
    }

    // let else
    let Wire::Ready(v) = wire else {
        // do something that doesn't continue, like early return
        return;
    };
}</code></pre></pre>
<h2 id="user-defined-conversions"><a class="header" href="#user-defined-conversions">User-defined conversions</a></h2>
<p>User-defined conversions are covered in a <a href="/idioms/user-defined_conversions.html">separate
chapter</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/encapsulation/setters_and_getters.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../idioms/user-defined_conversions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/encapsulation/setters_and_getters.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../idioms/user-defined_conversions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
