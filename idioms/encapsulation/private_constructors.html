<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Private constructors - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="private-constructors"><a class="header" href="#private-constructors">Private constructors</a></h1>
<p>In C++ constructors for classes can be made private by declaring them private,
or by defining a class using <code>class</code> and using the default private visibility.</p>
<p>In Rust, constructors (the actual constructors, not <a href="../constructors.html">"constructor
methods"</a>) for structs are visible from wherever the
type and all fields are visible. To achieve similar visibility restrictions as
in the C++ example, an additional private field needs to be added to the struct
in Rust. Because Rust supports zero-sized types, the additional field can have
no performance cost. The <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit
type</a> has zero size and can
be used for this purpose.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

struct Person {
  std::string name;
  int age;

private:
  Person() = default;
};

int main() {
  // fails to compile, Person::Person() private
  // Person nobody;

  // fails to compile since C++20
  // Person alice{"Alice", 42};
  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">mod person {
    pub struct Person {
        pub name: String,
        pub age: i32,
        _private: (),
    }

    impl Person {
        pub fn new(
            name: String,
            age: i32,
        ) -&gt; Person {
            Person {
                name,
                age,
                _private: (),
            }
        }
    }
}

use person::*;

fn main() {
    // field `_private` of struct `person::Person`
    // is private
    // let alice = Person {
    //     name: "Alice".to_string(),
    //     age: 42,
    //     _private: (),
    // };

    // cannot construct `person::Person` with
    // struct literal syntax due to private fields
    // let bob = Person {
    //     name: "Bob".to_string(),
    //     age: 55,
    // };

    let carol =
        Person::new("Carol".to_string(), 20);
    // Can match on the public fields, and then
    // use .. to ignore the remaning ones.
    let Person { name, age, .. } = carol;
}</code></pre></pre>
</div>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Unlike C++ unions, but like <code>std::variant</code>, Rust enums do not have direct
control over the visibility of their variants or the fields of their variants.
In the following example, the <code>circle</code> variant of the <code>Shape</code> union is not
public, so it can only be accessed from within the definition of <code>Shape</code>, as it
is by the <code>make_circle</code> static method.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Triangle {
  double base;
  double height;
};

struct Circle {
  double radius;
};

union Shape {
  Triangle triangle;

private:
  Circle circle;

public:
  static Shape make_circle(double radius) {
    Shape s;
    s.circle = Circle(radius);
    return s;
  };
};

int main() {
  Shape triangle;
  triangle.triangle = Triangle{1.0, 2.0};
  Shape circle = Shape::make_circle(1.0);

  // fails to compile
  // circle.circle = Circle{1.0};

  // fails to compile
  // std::cout &lt;&lt; shape.circle.radius;
}
</code></pre>
<p>In Rust visibility modifiers cannot be applied to individual enum variants or
their fields.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum Shape {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }
}

use shape::*;

fn main() {
    // Variant constructor is accesssible despite not being marked pub.
    let triangle = Shape::Triangle {
        base: 1.0,
        height: 2.0,
    };

    let circle = Shape::Circle { radius: 1.0 };

    // Fields accessbile despite not being marked pub.
    match circle {
        Shape::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle { radius } =&gt; {
            println!("Circle {}", radius);
        }
    }
}</code></pre></pre>
<p>Instead, to control construction of and pattern matching on the enum
implementation, one of two approaches can be taken. The first controls
construction of and access to the fields, but not inspection of which variant is
active.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub struct Triangle {
        pub base: f64,
        pub height: f64,
        _private: (),
    }
    pub struct Circle {
        pub radius: f64,
        _private: (),
    }

    pub enum Shape {
        Triangle(Triangle),
        Circle(Circle),
    }

    impl Shape {
        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape::Triangle(Triangle {
                base,
                height,
                _private: (),
            })
        }

        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape::Circle(Circle {
                radius,
                _private: (),
            })
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    match circle {
        Shape::Triangle(Triangle { base, height, .. }) =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        Shape::Circle(Circle { radius, .. }) =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The second places the enum in a struct with a private field, preventing both
construction and inspection from outside of the module.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new_circle(radius: f64) -&gt; Shape {
            Shape(ShapeKind::Circle { radius })
        }

        pub fn new_triangle(base: f64, height: f64) -&gt; Shape {
            Shape(ShapeKind::Triangle { base, height })
        }

        pub fn print(&amp;self) {
            match self.0 {
                ShapeKind::Triangle { base, height } =&gt; {
                    println!("Triangle: {}, {}", base, height);
                }
                ShapeKind::Circle { radius } =&gt; {
                    println!("Circle: {}", radius);
                }
            }
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new_triangle(1.0, 2.0);
    let circle = Shape::new_circle(1.0);

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(_) -&gt; {}
    // }

    circle.print();
}</code></pre></pre>
<p>If the purpose of making the variants private is to ensure that invariants are
met, then it can be useful to expose the implementing enum (<code>ShapeKind</code>) but not
the field of the wrapping struct (<code>Shape</code>), with the invariants only being
guaranteed when the wrapping struct is used. In this case, it is necessary to
make the field private and define a getter function, since otherwise the field
would be modifiable, possibly violating the invariant that the wrapping struct
represents.</p>
<pre><pre class="playground"><code class="language-rust">mod shape {
    pub enum ShapeKind {
        Triangle { base: f64, height: f64 },
        Circle { radius: f64 },
    }

    // The field of Shape is private.
    pub struct Shape(ShapeKind);

    impl Shape {
        pub fn new(kind: ShapeKind) -&gt; Option&lt;Shape&gt; {
            // ... check invariants ...
            Some(Shape(kind))
        }

        pub fn get_kind(&amp;self) -&gt; &amp;ShapeKind {
            &amp;self.0
        }
    }
}

use shape::*;

fn main() {
    let triangle = Shape::new(ShapeKind::Triangle {
        base: 1.0,
        height: 2.0,
    });
    let Some(circle) = Shape::new(ShapeKind::Circle { radius: 1.0 }) else {
        return;
    };

    // Does not compile because Shape has private fields.
    // match circle {
    //   Shape(c) =&gt; {}
    // };

    match circle.get_kind() {
        ShapeKind::Triangle { base, height } =&gt; {
            println!("Triangle: {}, {}", base, height);
        }
        ShapeKind::Circle { radius } =&gt; {
            println!("Circle: {}", radius);
        }
    }
}</code></pre></pre>
<p>The situation in Rust resembles the situation in C++ when using <code>std::variant</code>,
for which it is not possible to make the variants themselves private. Instead
either the constructors for the types that form the variants can be made private
or the variant can be wrapped in a class with appropriate visibility controls.</p>
<h2 id="rusts-non_exhaustive-annotation"><a class="header" href="#rusts-non_exhaustive-annotation">Rust's <code>#[non_exhaustive]</code> annotation</a></h2>
<p>If a struct or enum is intended to be public within a
<a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crate</a>, but
should not be constructed outside of the crate, then the <code>#[non_exhaustive]</code>
attribute can be used to constrain construction. The attribute can be applied to
both structs and to individual enum variants with the same effect as adding a
private field.</p>
<p>However, the attribute applies the constraint at the level of the crate, not at
the level of a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Person {
    pub name: String,
    pub age: i32,
}

pub enum Shape {
    #[non_exhaustive]
    Triangle { base: f64, height: f64 },
    #[non_exhaustive]
    Circle { radius: f64 },
}
<span class="boring">}</span></code></pre></pre>
<p>The attribute is more typically used to force clients of a library to include
the wildcard when matching on the struct fields, making it so that adding
additional fields to a struct is not breaking change (i.e., that it does not
<a href="https://doc.rust-lang.org/cargo/reference/semver.html">require the increase of the major version component when using semantic
versioning</a>).</p>
<p>Applying the <code>#[non_exhasutive]</code> attribute to the enum itself makes it as if one
of the variants were private, requiring a wildcard when matching on the variant
itself. This has the same effect in terms of versioning as when used on a struct
but is less advantageous. In most cases, code failing to compile when a new enum
variant is added is desirable, since that indicates a new case that requires
handling logic.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;private_constructors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;62d1037a-740b-4f66-a195-741fa73f59fc&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`Person` can be constructed in `test_method`.\n&quot;,&quot;`_private` can be accessed in `test_method`.\n&quot;,&quot;`name` can be accessed in `test_method`.\n&quot;,&quot;`name` can be accessed in `main`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Person` can be constructed in `main`.\n&quot;,&quot;`_private` can be accessed in `main`.\n&quot;,&quot;Values of type `Person` are larger than values of type `Pet`.\n&quot;],&quot;prompt&quot;:&quot;Which statements are true about the following Rust program?\n\n```rust\nmod people {\n    pub struct Person {\n        pub name: String,\n        pub age: i32,\n        _private: (),\n    }\n\n    pub struct Pet {\n        pub name: String,\n        pub age: i32,\n    }\n\n    fn test_method() {\n      // ...\n    }\n}\n\nuse people::*;\n\nfn main() {\n    // ...\n}\n```\n&quot;}},{&quot;id&quot;:&quot;df42cbcd-d5c0-486d-9509-371d05bc2145&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nmod vec {\n    pub struct Vec2 {\n        x: f64,\n        y: f64,\n    }\n\n    impl Vec2 {\n        pub fn new() -&gt; Vec2 {\n            Vec2 { x: 0.0, y: 0.0 }\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct Vec2 {\n    x: f64,\n    y: f64,\n}\n\nimpl Vec2 {\n    pub fn new() -&gt; Vec2 {\n        Vec2 { x: 0.0 , y: 0.0 }\n    }\n}\n```\n&quot;,&quot;```rust\nmod vec {\n    pub struct Vec2 {\n        x: f64,\n        y: f64,\n        _private: (),\n    }\n\n    impl Vec2 {\n        fn new() -&gt; Vec2 {\n            Vec2 { x: 0.0, y: 0.0 }\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is the most idiomatic translation of the following C++ program?\n\n```cpp\nclass Vec2 {\n  double x;\n  double y;\n\npublic:\n  Vec2() : x(0.0), y(0.0) {}\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Private constructors">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../idioms/encapsulation/private_and_friends.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../idioms/encapsulation/setters_and_getters.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../idioms/encapsulation/private_and_friends.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../idioms/encapsulation/setters_and_getters.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q3W4ES0FTM"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q3W4ES0FTM');
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
