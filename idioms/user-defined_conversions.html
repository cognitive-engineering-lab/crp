<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>User-defined conversions - C++ to Rust Phrasebook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A book to help translate C++ idioms into Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust Phrasebook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/crp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-defined-conversions"><a class="header" href="#user-defined-conversions">User-defined conversions</a></h1>
<p>In C++ user-defined conversions are created using <a href="https://en.cppreference.com/w/cpp/language/converting_constructor">converting
constructors</a>
or <a href="https://en.cppreference.com/w/cpp/language/cast_operator">conversion
functions</a>. Because
converting constructors are opt-out (via the <code>explicit</code> specifier), implicit
conversions occur with regularity in C++ code. In the following example both the
assignments and the function calls make use of implicit conversions as provided
by a converting constructor.</p>
<p>Rust makes significantly less use of implicit conversions. Instead most
conversions are explicit. The
<a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code></a> module
provides several traits for working with user-defined conversions. In Rust, the
below example makes use of explicit conversions by implementing the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code>
trait</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Widget {
  Widget(int) {}
  Widget(int, int) {}
};

void process(Widget w) {}

int main() {
  Widget w1 = 1;
  Widget w2 = {4, 5};
  process(1);
  process({4, 5});

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(_x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;(i32, i32)&gt; for Widget {
    fn from(_x: (i32, i32)) -&gt; Widget {
        Widget
    }
}

fn process(w: Widget) {}

fn main() {
    let w1: Widget = 1.into();
    // For construction this is more idiomatic:
    let w1b = Widget::from(1);

    let w2: Widget = (4, 5).into();
    // For construction this is more idiomatic:
    let w2b = Widget::from((4, 5));

    process(1.into());
    process((4, 5).into());
}</code></pre></pre>
</div>
<p>The <code>into</code> method used above is provided via a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">blanket
implementations</a>
for the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into trait</code></a>
for types that implement the <code>From</code> trait. Because of the existence of the
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html#impl-Into%3CU%3E-for-T">blanket
implementation</a>,
it is generally preferred to implement the <code>From</code> trait instead of the <code>Into</code>
trait, and let the <code>Into</code> trait be provided by that blanket implementation.</p>
<h2 id="conversion-functions"><a class="header" href="#conversion-functions">Conversion functions</a></h2>
<p>C++ conversion functions enable conversions in the other direction, from the
defined class to another type.</p>
<p>To achieve the same in Rust, the <code>From</code> trait can be implemented in the other
direction. At least one of the source type or the target type must be defined in
the same crate as the trait implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;utility&gt;

struct Point {
  int x;
  int y;

  operator std::pair&lt;int, int&gt;() const {
    return std::pair(x, y);
  }
};

void process(std::pair&lt;int, int&gt;) {}

int main() {
  Point p1{1, 2};
  Point p2{3, 4};

  std::pair&lt;int, int&gt; xy = p1;
  process(p2);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(p: Point) -&gt; (i32, i32) {
        (p.x, p.y)
    }
}

fn process(x: (i32, i32)) {}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };

    let xy: (i32, i32) = p1.into();
    process(p2.into());
}</code></pre></pre>
</div>
<p>Conversion functions are is often used to implement the safe bool pattern in
C++, <a href="./promotions_and_conversions.html#safe-bools">which is addressed in a different way in
Rust</a>.</p>
<h2 id="borrowing-conversions"><a class="header" href="#borrowing-conversions">Borrowing conversions</a></h2>
<p>The methods in the <code>From</code> and <code>Into</code> traits take ownership of the values to be
converted. When this is not desired in C++, the conversion function can just
take and return references.</p>
<p>To achieve the same in Rust the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code>
trait</a> or <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code>
trait</a> are used.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

struct Person {
  std::string name;

  operator std::string &amp;() {
    return this-&gt;name;
  }
};

void process(const std::string &amp;name) {
  std::cout &lt;&lt; name &lt;&lt; std::endl;
}

int main() {
  Person alice{"Alice"};

  process(alice);

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct Person {
    name: String,
}

impl AsRef&lt;str&gt; for Person {
    fn as_ref(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}

fn process(name: &amp;str) {
    println!("{}", name);
}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice.as_ref());
}</code></pre></pre>
</div>
<p>It is common to use <code>AsRef</code> or <code>AsMut</code> as a trait bound in function definitions.
Using generics with an <code>AsRef</code> or <code>AsMut</code> bound allows clients to call the
functions with anything that can be cheaply viewed as the type that the function
wants to work with. Using this technique, the above definition of <code>process</code>
would be defined as in the following example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsRef&lt;str&gt; for Person {
</span><span class="boring">    fn as_ref(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn process&lt;T: AsRef&lt;str&gt;&gt;(name: T) {
    println!("{}", name.as_ref());
}

fn main() {
    let alice = Person {
        name: "Alice".to_string(),
    };

    process(alice);
}</code></pre></pre>
<p>This technique is often used with functions that take file system paths, so that
literal strings can more easily be used as paths.</p>
<h2 id="fallible-conversions"><a class="header" href="#fallible-conversions">Fallible conversions</a></h2>
<p>In C++ when conversions might fail it is possible (though usually discouraged)
to throw an exception from the converting constructor or converting function.</p>
<p>Error handling in Rust <a href="./exceptions.html">does not use exceptions</a>. Instead
the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code> trait</a>
and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code> trait</a>
are used for fallible conversions. These traits differ from <code>From</code> and <code>Into</code> in
that they return a <code>Result</code>, which may indicate a failing case. When a
conversion may fail one should implement <code>TryFrom</code> and rely on the client to
call <code>unwrap</code> on the result, rather than panic in a <code>From</code> implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;string&gt;

class NonEmpty {
  std::string s;

public:
  NonEmpty(std::string s) : s(s) {
    if (this-&gt;s.empty()) {
      throw std::domain_error("empty string");
    }
  }
};

int main() {
  std::string s("");
  NonEmpty x = s; // throws

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::convert::TryInto;

struct NonEmpty {
    s: String,
}

#[derive(Clone, Copy, Debug)]
struct NonEmptyStringError;

impl TryFrom&lt;String&gt; for NonEmpty {
    type Error = NonEmptyStringError;

    fn try_from(
        s: String,
    ) -&gt; Result&lt;NonEmpty, NonEmptyStringError&gt;
    {
        if s.is_empty() {
            Err(NonEmptyStringError)
        } else {
            Ok(NonEmpty { s })
        }
    }
}

fn main() {
    let res: Result&lt;
        NonEmpty,
        NonEmptyStringError,
    &gt; = "".to_string().try_into();
    match res {
        Ok(ne) =&gt; {
            println!("Converted!");
        }
        Err(err) =&gt; {
            println!("Couldn't convert");
        }
    }
}</code></pre></pre>
</div>
<p>Just like with <code>From</code> and <code>Into</code>, there is a <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#impl-TryInto%3CU%3E-for-T">blanket
implementation</a>
for <code>TryInto</code> for everything that implements <code>TryFrom</code>.</p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Rust does have one kind of user-defined implicit conversion, called <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion">deref
coercions</a>,
provided by the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code>
trait</a> and
<a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code>trait</a>. These
coercions exist for making pointer-like types more ergonomic to use.</p>
<p>An <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">example</a> of implementing
the traits for a custom pointer-like type is given in the Rust book.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>A summary of when to use which kind of conversion interface is given in the
documentation for the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code>
module</a>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;user-defined_conversions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;There is a blanket implementation for `TryInto` for every type that implements\n`TryFrom`, so it is better to implement `TryFrom` and rely on the blanket\nimplementation for `TryInto`.\n&quot;,&quot;id&quot;:&quot;d6790d33-5130-47ba-ba96-c6718978131f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse std::convert::TryFrom;\n\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct IsNaN;\n\nimpl TryFrom&lt;f64&gt; for NotNaN {\n    type Error = IsNaN;\n    fn try_from(\n        x: f64,\n    ) -&gt; Result&lt;Self, Self::Error&gt; {\n        if x.is_nan() {\n            Err(IsNaN)\n        } else {\n            Ok(Self { value: x })\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\nimpl From&lt;f64&gt; for NotNaN {\n    fn from(x: f64) -&gt; Self {\n        if x.is_nan() {\n            panic!(\&quot;Is NaN!\&quot;);\n        }\n        Self { value: x }\n    }\n}\n```\n&quot;,&quot;```rust\nuse std::convert::TryInto;\n\npub struct NotNaN {\n    value: f64,\n}\n\nimpl NotNaN {\n    pub fn value(&amp;self) -&gt; f64 {\n        self.value\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct IsNaN;\n\nimpl TryInto&lt;NotNaN&gt; for f64 {\n    type Error = IsNaN;\n\n    fn try_into(\n        self,\n    ) -&gt; Result&lt;NotNaN, Self::Error&gt; {\n        if self.is_nan() {\n            Err(IsNaN)\n        } else {\n            Ok(NotNaN { value: self })\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust program is the most idiomatic translation of the following C++\nprogram?\n\n```cpp\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n\nclass NotNaN {\n  double value;\n\npublic:\n  NotNaN(double x) : value(x) {\n    if (std::isnan(value)) {\n      throw std::domain_error(\&quot;NaN\&quot;);\n    }\n  }\n\n  double getValue() {\n    return value;\n  }\n};\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"></div>
<script type="text/javascript" src="../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../quiz/style.css">

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=User-defined conversions">Click here to leave us feedback about this page.</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../idioms/promotions_and_conversions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../idioms/overloading.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../idioms/promotions_and_conversions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../idioms/overloading.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q3W4ES0FTM"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q3W4ES0FTM');
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../telemetry/dist/telemetry.iife.js"></script>


    </div>
    </body>
</html>
